package phases

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
	"github.com/insolar/insolar/network/consensusv1/packets"
)

// CommunicatorMock implements Communicator
type CommunicatorMock struct {
	t minimock.Tester

	funcExchangePhase1          func(ctx context.Context, originClaim *packets.NodeAnnounceClaim, participants []insolar.NetworkNode, packet *packets.Phase1Packet) (m1 map[insolar.Reference]*packets.Phase1Packet, err error)
	inspectFuncExchangePhase1   func(ctx context.Context, originClaim *packets.NodeAnnounceClaim, participants []insolar.NetworkNode, packet *packets.Phase1Packet)
	afterExchangePhase1Counter  uint64
	beforeExchangePhase1Counter uint64
	ExchangePhase1Mock          mCommunicatorMockExchangePhase1

	funcExchangePhase2          func(ctx context.Context, state *ConsensusState, participants []insolar.NetworkNode, packet *packets.Phase2Packet) (m1 map[insolar.Reference]*packets.Phase2Packet, err error)
	inspectFuncExchangePhase2   func(ctx context.Context, state *ConsensusState, participants []insolar.NetworkNode, packet *packets.Phase2Packet)
	afterExchangePhase2Counter  uint64
	beforeExchangePhase2Counter uint64
	ExchangePhase2Mock          mCommunicatorMockExchangePhase2

	funcExchangePhase21          func(ctx context.Context, state *ConsensusState, packet *packets.Phase2Packet, additionalRequests []*AdditionalRequest) (ra1 []packets.ReferendumVote, err error)
	inspectFuncExchangePhase21   func(ctx context.Context, state *ConsensusState, packet *packets.Phase2Packet, additionalRequests []*AdditionalRequest)
	afterExchangePhase21Counter  uint64
	beforeExchangePhase21Counter uint64
	ExchangePhase21Mock          mCommunicatorMockExchangePhase21

	funcExchangePhase3          func(ctx context.Context, participants []insolar.NetworkNode, packet *packets.Phase3Packet) (m1 map[insolar.Reference]*packets.Phase3Packet, err error)
	inspectFuncExchangePhase3   func(ctx context.Context, participants []insolar.NetworkNode, packet *packets.Phase3Packet)
	afterExchangePhase3Counter  uint64
	beforeExchangePhase3Counter uint64
	ExchangePhase3Mock          mCommunicatorMockExchangePhase3

	funcInit          func(ctx context.Context) (err error)
	inspectFuncInit   func(ctx context.Context)
	afterInitCounter  uint64
	beforeInitCounter uint64
	InitMock          mCommunicatorMockInit
}

// NewCommunicatorMock returns a mock for Communicator
func NewCommunicatorMock(t minimock.Tester) *CommunicatorMock {
	m := &CommunicatorMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ExchangePhase1Mock = mCommunicatorMockExchangePhase1{mock: m}
	m.ExchangePhase1Mock.callArgs = []*CommunicatorMockExchangePhase1Params{}

	m.ExchangePhase2Mock = mCommunicatorMockExchangePhase2{mock: m}
	m.ExchangePhase2Mock.callArgs = []*CommunicatorMockExchangePhase2Params{}

	m.ExchangePhase21Mock = mCommunicatorMockExchangePhase21{mock: m}
	m.ExchangePhase21Mock.callArgs = []*CommunicatorMockExchangePhase21Params{}

	m.ExchangePhase3Mock = mCommunicatorMockExchangePhase3{mock: m}
	m.ExchangePhase3Mock.callArgs = []*CommunicatorMockExchangePhase3Params{}

	m.InitMock = mCommunicatorMockInit{mock: m}
	m.InitMock.callArgs = []*CommunicatorMockInitParams{}

	return m
}

type mCommunicatorMockExchangePhase1 struct {
	mock               *CommunicatorMock
	defaultExpectation *CommunicatorMockExchangePhase1Expectation
	expectations       []*CommunicatorMockExchangePhase1Expectation

	callArgs []*CommunicatorMockExchangePhase1Params
	mutex    sync.RWMutex
}

// CommunicatorMockExchangePhase1Expectation specifies expectation struct of the Communicator.ExchangePhase1
type CommunicatorMockExchangePhase1Expectation struct {
	mock    *CommunicatorMock
	params  *CommunicatorMockExchangePhase1Params
	results *CommunicatorMockExchangePhase1Results
	Counter uint64
}

// CommunicatorMockExchangePhase1Params contains parameters of the Communicator.ExchangePhase1
type CommunicatorMockExchangePhase1Params struct {
	ctx          context.Context
	originClaim  *packets.NodeAnnounceClaim
	participants []insolar.NetworkNode
	packet       *packets.Phase1Packet
}

// CommunicatorMockExchangePhase1Results contains results of the Communicator.ExchangePhase1
type CommunicatorMockExchangePhase1Results struct {
	m1  map[insolar.Reference]*packets.Phase1Packet
	err error
}

// Expect sets up expected params for Communicator.ExchangePhase1
func (mmExchangePhase1 *mCommunicatorMockExchangePhase1) Expect(ctx context.Context, originClaim *packets.NodeAnnounceClaim, participants []insolar.NetworkNode, packet *packets.Phase1Packet) *mCommunicatorMockExchangePhase1 {
	if mmExchangePhase1.mock.funcExchangePhase1 != nil {
		mmExchangePhase1.mock.t.Fatalf("CommunicatorMock.ExchangePhase1 mock is already set by Set")
	}

	if mmExchangePhase1.defaultExpectation == nil {
		mmExchangePhase1.defaultExpectation = &CommunicatorMockExchangePhase1Expectation{}
	}

	mmExchangePhase1.defaultExpectation.params = &CommunicatorMockExchangePhase1Params{ctx, originClaim, participants, packet}
	for _, e := range mmExchangePhase1.expectations {
		if minimock.Equal(e.params, mmExchangePhase1.defaultExpectation.params) {
			mmExchangePhase1.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExchangePhase1.defaultExpectation.params)
		}
	}

	return mmExchangePhase1
}

// Inspect accepts an inspector function that has same arguments as the Communicator.ExchangePhase1
func (mmExchangePhase1 *mCommunicatorMockExchangePhase1) Inspect(f func(ctx context.Context, originClaim *packets.NodeAnnounceClaim, participants []insolar.NetworkNode, packet *packets.Phase1Packet)) *mCommunicatorMockExchangePhase1 {
	if mmExchangePhase1.mock.inspectFuncExchangePhase1 != nil {
		mmExchangePhase1.mock.t.Fatalf("Inspect function is already set for CommunicatorMock.ExchangePhase1")
	}

	mmExchangePhase1.mock.inspectFuncExchangePhase1 = f

	return mmExchangePhase1
}

// Return sets up results that will be returned by Communicator.ExchangePhase1
func (mmExchangePhase1 *mCommunicatorMockExchangePhase1) Return(m1 map[insolar.Reference]*packets.Phase1Packet, err error) *CommunicatorMock {
	if mmExchangePhase1.mock.funcExchangePhase1 != nil {
		mmExchangePhase1.mock.t.Fatalf("CommunicatorMock.ExchangePhase1 mock is already set by Set")
	}

	if mmExchangePhase1.defaultExpectation == nil {
		mmExchangePhase1.defaultExpectation = &CommunicatorMockExchangePhase1Expectation{mock: mmExchangePhase1.mock}
	}
	mmExchangePhase1.defaultExpectation.results = &CommunicatorMockExchangePhase1Results{m1, err}
	return mmExchangePhase1.mock
}

//Set uses given function f to mock the Communicator.ExchangePhase1 method
func (mmExchangePhase1 *mCommunicatorMockExchangePhase1) Set(f func(ctx context.Context, originClaim *packets.NodeAnnounceClaim, participants []insolar.NetworkNode, packet *packets.Phase1Packet) (m1 map[insolar.Reference]*packets.Phase1Packet, err error)) *CommunicatorMock {
	if mmExchangePhase1.defaultExpectation != nil {
		mmExchangePhase1.mock.t.Fatalf("Default expectation is already set for the Communicator.ExchangePhase1 method")
	}

	if len(mmExchangePhase1.expectations) > 0 {
		mmExchangePhase1.mock.t.Fatalf("Some expectations are already set for the Communicator.ExchangePhase1 method")
	}

	mmExchangePhase1.mock.funcExchangePhase1 = f
	return mmExchangePhase1.mock
}

// When sets expectation for the Communicator.ExchangePhase1 which will trigger the result defined by the following
// Then helper
func (mmExchangePhase1 *mCommunicatorMockExchangePhase1) When(ctx context.Context, originClaim *packets.NodeAnnounceClaim, participants []insolar.NetworkNode, packet *packets.Phase1Packet) *CommunicatorMockExchangePhase1Expectation {
	if mmExchangePhase1.mock.funcExchangePhase1 != nil {
		mmExchangePhase1.mock.t.Fatalf("CommunicatorMock.ExchangePhase1 mock is already set by Set")
	}

	expectation := &CommunicatorMockExchangePhase1Expectation{
		mock:   mmExchangePhase1.mock,
		params: &CommunicatorMockExchangePhase1Params{ctx, originClaim, participants, packet},
	}
	mmExchangePhase1.expectations = append(mmExchangePhase1.expectations, expectation)
	return expectation
}

// Then sets up Communicator.ExchangePhase1 return parameters for the expectation previously defined by the When method
func (e *CommunicatorMockExchangePhase1Expectation) Then(m1 map[insolar.Reference]*packets.Phase1Packet, err error) *CommunicatorMock {
	e.results = &CommunicatorMockExchangePhase1Results{m1, err}
	return e.mock
}

// ExchangePhase1 implements Communicator
func (mmExchangePhase1 *CommunicatorMock) ExchangePhase1(ctx context.Context, originClaim *packets.NodeAnnounceClaim, participants []insolar.NetworkNode, packet *packets.Phase1Packet) (m1 map[insolar.Reference]*packets.Phase1Packet, err error) {
	mm_atomic.AddUint64(&mmExchangePhase1.beforeExchangePhase1Counter, 1)
	defer mm_atomic.AddUint64(&mmExchangePhase1.afterExchangePhase1Counter, 1)

	if mmExchangePhase1.inspectFuncExchangePhase1 != nil {
		mmExchangePhase1.inspectFuncExchangePhase1(ctx, originClaim, participants, packet)
	}

	params := &CommunicatorMockExchangePhase1Params{ctx, originClaim, participants, packet}

	// Record call args
	mmExchangePhase1.ExchangePhase1Mock.mutex.Lock()
	mmExchangePhase1.ExchangePhase1Mock.callArgs = append(mmExchangePhase1.ExchangePhase1Mock.callArgs, params)
	mmExchangePhase1.ExchangePhase1Mock.mutex.Unlock()

	for _, e := range mmExchangePhase1.ExchangePhase1Mock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmExchangePhase1.ExchangePhase1Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExchangePhase1.ExchangePhase1Mock.defaultExpectation.Counter, 1)
		want := mmExchangePhase1.ExchangePhase1Mock.defaultExpectation.params
		got := CommunicatorMockExchangePhase1Params{ctx, originClaim, participants, packet}
		if want != nil && !minimock.Equal(*want, got) {
			mmExchangePhase1.t.Errorf("CommunicatorMock.ExchangePhase1 got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmExchangePhase1.ExchangePhase1Mock.defaultExpectation.results
		if results == nil {
			mmExchangePhase1.t.Fatal("No results are set for the CommunicatorMock.ExchangePhase1")
		}
		return (*results).m1, (*results).err
	}
	if mmExchangePhase1.funcExchangePhase1 != nil {
		return mmExchangePhase1.funcExchangePhase1(ctx, originClaim, participants, packet)
	}
	mmExchangePhase1.t.Fatalf("Unexpected call to CommunicatorMock.ExchangePhase1. %v %v %v %v", ctx, originClaim, participants, packet)
	return
}

// ExchangePhase1AfterCounter returns a count of finished CommunicatorMock.ExchangePhase1 invocations
func (mmExchangePhase1 *CommunicatorMock) ExchangePhase1AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExchangePhase1.afterExchangePhase1Counter)
}

// ExchangePhase1BeforeCounter returns a count of CommunicatorMock.ExchangePhase1 invocations
func (mmExchangePhase1 *CommunicatorMock) ExchangePhase1BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExchangePhase1.beforeExchangePhase1Counter)
}

// Calls returns a list of arguments used in each call to CommunicatorMock.ExchangePhase1.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExchangePhase1 *mCommunicatorMockExchangePhase1) Calls() []*CommunicatorMockExchangePhase1Params {
	mmExchangePhase1.mutex.RLock()

	argCopy := make([]*CommunicatorMockExchangePhase1Params, len(mmExchangePhase1.callArgs))
	copy(argCopy, mmExchangePhase1.callArgs)

	mmExchangePhase1.mutex.RUnlock()

	return argCopy
}

// MinimockExchangePhase1Done returns true if the count of the ExchangePhase1 invocations corresponds
// the number of defined expectations
func (m *CommunicatorMock) MinimockExchangePhase1Done() bool {
	for _, e := range m.ExchangePhase1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExchangePhase1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExchangePhase1Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExchangePhase1 != nil && mm_atomic.LoadUint64(&m.afterExchangePhase1Counter) < 1 {
		return false
	}
	return true
}

// MinimockExchangePhase1Inspect logs each unmet expectation
func (m *CommunicatorMock) MinimockExchangePhase1Inspect() {
	for _, e := range m.ExchangePhase1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommunicatorMock.ExchangePhase1 with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExchangePhase1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExchangePhase1Counter) < 1 {
		if m.ExchangePhase1Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CommunicatorMock.ExchangePhase1")
		} else {
			m.t.Errorf("Expected call to CommunicatorMock.ExchangePhase1 with params: %#v", *m.ExchangePhase1Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExchangePhase1 != nil && mm_atomic.LoadUint64(&m.afterExchangePhase1Counter) < 1 {
		m.t.Error("Expected call to CommunicatorMock.ExchangePhase1")
	}
}

type mCommunicatorMockExchangePhase2 struct {
	mock               *CommunicatorMock
	defaultExpectation *CommunicatorMockExchangePhase2Expectation
	expectations       []*CommunicatorMockExchangePhase2Expectation

	callArgs []*CommunicatorMockExchangePhase2Params
	mutex    sync.RWMutex
}

// CommunicatorMockExchangePhase2Expectation specifies expectation struct of the Communicator.ExchangePhase2
type CommunicatorMockExchangePhase2Expectation struct {
	mock    *CommunicatorMock
	params  *CommunicatorMockExchangePhase2Params
	results *CommunicatorMockExchangePhase2Results
	Counter uint64
}

// CommunicatorMockExchangePhase2Params contains parameters of the Communicator.ExchangePhase2
type CommunicatorMockExchangePhase2Params struct {
	ctx          context.Context
	state        *ConsensusState
	participants []insolar.NetworkNode
	packet       *packets.Phase2Packet
}

// CommunicatorMockExchangePhase2Results contains results of the Communicator.ExchangePhase2
type CommunicatorMockExchangePhase2Results struct {
	m1  map[insolar.Reference]*packets.Phase2Packet
	err error
}

// Expect sets up expected params for Communicator.ExchangePhase2
func (mmExchangePhase2 *mCommunicatorMockExchangePhase2) Expect(ctx context.Context, state *ConsensusState, participants []insolar.NetworkNode, packet *packets.Phase2Packet) *mCommunicatorMockExchangePhase2 {
	if mmExchangePhase2.mock.funcExchangePhase2 != nil {
		mmExchangePhase2.mock.t.Fatalf("CommunicatorMock.ExchangePhase2 mock is already set by Set")
	}

	if mmExchangePhase2.defaultExpectation == nil {
		mmExchangePhase2.defaultExpectation = &CommunicatorMockExchangePhase2Expectation{}
	}

	mmExchangePhase2.defaultExpectation.params = &CommunicatorMockExchangePhase2Params{ctx, state, participants, packet}
	for _, e := range mmExchangePhase2.expectations {
		if minimock.Equal(e.params, mmExchangePhase2.defaultExpectation.params) {
			mmExchangePhase2.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExchangePhase2.defaultExpectation.params)
		}
	}

	return mmExchangePhase2
}

// Inspect accepts an inspector function that has same arguments as the Communicator.ExchangePhase2
func (mmExchangePhase2 *mCommunicatorMockExchangePhase2) Inspect(f func(ctx context.Context, state *ConsensusState, participants []insolar.NetworkNode, packet *packets.Phase2Packet)) *mCommunicatorMockExchangePhase2 {
	if mmExchangePhase2.mock.inspectFuncExchangePhase2 != nil {
		mmExchangePhase2.mock.t.Fatalf("Inspect function is already set for CommunicatorMock.ExchangePhase2")
	}

	mmExchangePhase2.mock.inspectFuncExchangePhase2 = f

	return mmExchangePhase2
}

// Return sets up results that will be returned by Communicator.ExchangePhase2
func (mmExchangePhase2 *mCommunicatorMockExchangePhase2) Return(m1 map[insolar.Reference]*packets.Phase2Packet, err error) *CommunicatorMock {
	if mmExchangePhase2.mock.funcExchangePhase2 != nil {
		mmExchangePhase2.mock.t.Fatalf("CommunicatorMock.ExchangePhase2 mock is already set by Set")
	}

	if mmExchangePhase2.defaultExpectation == nil {
		mmExchangePhase2.defaultExpectation = &CommunicatorMockExchangePhase2Expectation{mock: mmExchangePhase2.mock}
	}
	mmExchangePhase2.defaultExpectation.results = &CommunicatorMockExchangePhase2Results{m1, err}
	return mmExchangePhase2.mock
}

//Set uses given function f to mock the Communicator.ExchangePhase2 method
func (mmExchangePhase2 *mCommunicatorMockExchangePhase2) Set(f func(ctx context.Context, state *ConsensusState, participants []insolar.NetworkNode, packet *packets.Phase2Packet) (m1 map[insolar.Reference]*packets.Phase2Packet, err error)) *CommunicatorMock {
	if mmExchangePhase2.defaultExpectation != nil {
		mmExchangePhase2.mock.t.Fatalf("Default expectation is already set for the Communicator.ExchangePhase2 method")
	}

	if len(mmExchangePhase2.expectations) > 0 {
		mmExchangePhase2.mock.t.Fatalf("Some expectations are already set for the Communicator.ExchangePhase2 method")
	}

	mmExchangePhase2.mock.funcExchangePhase2 = f
	return mmExchangePhase2.mock
}

// When sets expectation for the Communicator.ExchangePhase2 which will trigger the result defined by the following
// Then helper
func (mmExchangePhase2 *mCommunicatorMockExchangePhase2) When(ctx context.Context, state *ConsensusState, participants []insolar.NetworkNode, packet *packets.Phase2Packet) *CommunicatorMockExchangePhase2Expectation {
	if mmExchangePhase2.mock.funcExchangePhase2 != nil {
		mmExchangePhase2.mock.t.Fatalf("CommunicatorMock.ExchangePhase2 mock is already set by Set")
	}

	expectation := &CommunicatorMockExchangePhase2Expectation{
		mock:   mmExchangePhase2.mock,
		params: &CommunicatorMockExchangePhase2Params{ctx, state, participants, packet},
	}
	mmExchangePhase2.expectations = append(mmExchangePhase2.expectations, expectation)
	return expectation
}

// Then sets up Communicator.ExchangePhase2 return parameters for the expectation previously defined by the When method
func (e *CommunicatorMockExchangePhase2Expectation) Then(m1 map[insolar.Reference]*packets.Phase2Packet, err error) *CommunicatorMock {
	e.results = &CommunicatorMockExchangePhase2Results{m1, err}
	return e.mock
}

// ExchangePhase2 implements Communicator
func (mmExchangePhase2 *CommunicatorMock) ExchangePhase2(ctx context.Context, state *ConsensusState, participants []insolar.NetworkNode, packet *packets.Phase2Packet) (m1 map[insolar.Reference]*packets.Phase2Packet, err error) {
	mm_atomic.AddUint64(&mmExchangePhase2.beforeExchangePhase2Counter, 1)
	defer mm_atomic.AddUint64(&mmExchangePhase2.afterExchangePhase2Counter, 1)

	if mmExchangePhase2.inspectFuncExchangePhase2 != nil {
		mmExchangePhase2.inspectFuncExchangePhase2(ctx, state, participants, packet)
	}

	params := &CommunicatorMockExchangePhase2Params{ctx, state, participants, packet}

	// Record call args
	mmExchangePhase2.ExchangePhase2Mock.mutex.Lock()
	mmExchangePhase2.ExchangePhase2Mock.callArgs = append(mmExchangePhase2.ExchangePhase2Mock.callArgs, params)
	mmExchangePhase2.ExchangePhase2Mock.mutex.Unlock()

	for _, e := range mmExchangePhase2.ExchangePhase2Mock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmExchangePhase2.ExchangePhase2Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExchangePhase2.ExchangePhase2Mock.defaultExpectation.Counter, 1)
		want := mmExchangePhase2.ExchangePhase2Mock.defaultExpectation.params
		got := CommunicatorMockExchangePhase2Params{ctx, state, participants, packet}
		if want != nil && !minimock.Equal(*want, got) {
			mmExchangePhase2.t.Errorf("CommunicatorMock.ExchangePhase2 got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmExchangePhase2.ExchangePhase2Mock.defaultExpectation.results
		if results == nil {
			mmExchangePhase2.t.Fatal("No results are set for the CommunicatorMock.ExchangePhase2")
		}
		return (*results).m1, (*results).err
	}
	if mmExchangePhase2.funcExchangePhase2 != nil {
		return mmExchangePhase2.funcExchangePhase2(ctx, state, participants, packet)
	}
	mmExchangePhase2.t.Fatalf("Unexpected call to CommunicatorMock.ExchangePhase2. %v %v %v %v", ctx, state, participants, packet)
	return
}

// ExchangePhase2AfterCounter returns a count of finished CommunicatorMock.ExchangePhase2 invocations
func (mmExchangePhase2 *CommunicatorMock) ExchangePhase2AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExchangePhase2.afterExchangePhase2Counter)
}

// ExchangePhase2BeforeCounter returns a count of CommunicatorMock.ExchangePhase2 invocations
func (mmExchangePhase2 *CommunicatorMock) ExchangePhase2BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExchangePhase2.beforeExchangePhase2Counter)
}

// Calls returns a list of arguments used in each call to CommunicatorMock.ExchangePhase2.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExchangePhase2 *mCommunicatorMockExchangePhase2) Calls() []*CommunicatorMockExchangePhase2Params {
	mmExchangePhase2.mutex.RLock()

	argCopy := make([]*CommunicatorMockExchangePhase2Params, len(mmExchangePhase2.callArgs))
	copy(argCopy, mmExchangePhase2.callArgs)

	mmExchangePhase2.mutex.RUnlock()

	return argCopy
}

// MinimockExchangePhase2Done returns true if the count of the ExchangePhase2 invocations corresponds
// the number of defined expectations
func (m *CommunicatorMock) MinimockExchangePhase2Done() bool {
	for _, e := range m.ExchangePhase2Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExchangePhase2Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExchangePhase2Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExchangePhase2 != nil && mm_atomic.LoadUint64(&m.afterExchangePhase2Counter) < 1 {
		return false
	}
	return true
}

// MinimockExchangePhase2Inspect logs each unmet expectation
func (m *CommunicatorMock) MinimockExchangePhase2Inspect() {
	for _, e := range m.ExchangePhase2Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommunicatorMock.ExchangePhase2 with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExchangePhase2Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExchangePhase2Counter) < 1 {
		if m.ExchangePhase2Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CommunicatorMock.ExchangePhase2")
		} else {
			m.t.Errorf("Expected call to CommunicatorMock.ExchangePhase2 with params: %#v", *m.ExchangePhase2Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExchangePhase2 != nil && mm_atomic.LoadUint64(&m.afterExchangePhase2Counter) < 1 {
		m.t.Error("Expected call to CommunicatorMock.ExchangePhase2")
	}
}

type mCommunicatorMockExchangePhase21 struct {
	mock               *CommunicatorMock
	defaultExpectation *CommunicatorMockExchangePhase21Expectation
	expectations       []*CommunicatorMockExchangePhase21Expectation

	callArgs []*CommunicatorMockExchangePhase21Params
	mutex    sync.RWMutex
}

// CommunicatorMockExchangePhase21Expectation specifies expectation struct of the Communicator.ExchangePhase21
type CommunicatorMockExchangePhase21Expectation struct {
	mock    *CommunicatorMock
	params  *CommunicatorMockExchangePhase21Params
	results *CommunicatorMockExchangePhase21Results
	Counter uint64
}

// CommunicatorMockExchangePhase21Params contains parameters of the Communicator.ExchangePhase21
type CommunicatorMockExchangePhase21Params struct {
	ctx                context.Context
	state              *ConsensusState
	packet             *packets.Phase2Packet
	additionalRequests []*AdditionalRequest
}

// CommunicatorMockExchangePhase21Results contains results of the Communicator.ExchangePhase21
type CommunicatorMockExchangePhase21Results struct {
	ra1 []packets.ReferendumVote
	err error
}

// Expect sets up expected params for Communicator.ExchangePhase21
func (mmExchangePhase21 *mCommunicatorMockExchangePhase21) Expect(ctx context.Context, state *ConsensusState, packet *packets.Phase2Packet, additionalRequests []*AdditionalRequest) *mCommunicatorMockExchangePhase21 {
	if mmExchangePhase21.mock.funcExchangePhase21 != nil {
		mmExchangePhase21.mock.t.Fatalf("CommunicatorMock.ExchangePhase21 mock is already set by Set")
	}

	if mmExchangePhase21.defaultExpectation == nil {
		mmExchangePhase21.defaultExpectation = &CommunicatorMockExchangePhase21Expectation{}
	}

	mmExchangePhase21.defaultExpectation.params = &CommunicatorMockExchangePhase21Params{ctx, state, packet, additionalRequests}
	for _, e := range mmExchangePhase21.expectations {
		if minimock.Equal(e.params, mmExchangePhase21.defaultExpectation.params) {
			mmExchangePhase21.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExchangePhase21.defaultExpectation.params)
		}
	}

	return mmExchangePhase21
}

// Inspect accepts an inspector function that has same arguments as the Communicator.ExchangePhase21
func (mmExchangePhase21 *mCommunicatorMockExchangePhase21) Inspect(f func(ctx context.Context, state *ConsensusState, packet *packets.Phase2Packet, additionalRequests []*AdditionalRequest)) *mCommunicatorMockExchangePhase21 {
	if mmExchangePhase21.mock.inspectFuncExchangePhase21 != nil {
		mmExchangePhase21.mock.t.Fatalf("Inspect function is already set for CommunicatorMock.ExchangePhase21")
	}

	mmExchangePhase21.mock.inspectFuncExchangePhase21 = f

	return mmExchangePhase21
}

// Return sets up results that will be returned by Communicator.ExchangePhase21
func (mmExchangePhase21 *mCommunicatorMockExchangePhase21) Return(ra1 []packets.ReferendumVote, err error) *CommunicatorMock {
	if mmExchangePhase21.mock.funcExchangePhase21 != nil {
		mmExchangePhase21.mock.t.Fatalf("CommunicatorMock.ExchangePhase21 mock is already set by Set")
	}

	if mmExchangePhase21.defaultExpectation == nil {
		mmExchangePhase21.defaultExpectation = &CommunicatorMockExchangePhase21Expectation{mock: mmExchangePhase21.mock}
	}
	mmExchangePhase21.defaultExpectation.results = &CommunicatorMockExchangePhase21Results{ra1, err}
	return mmExchangePhase21.mock
}

//Set uses given function f to mock the Communicator.ExchangePhase21 method
func (mmExchangePhase21 *mCommunicatorMockExchangePhase21) Set(f func(ctx context.Context, state *ConsensusState, packet *packets.Phase2Packet, additionalRequests []*AdditionalRequest) (ra1 []packets.ReferendumVote, err error)) *CommunicatorMock {
	if mmExchangePhase21.defaultExpectation != nil {
		mmExchangePhase21.mock.t.Fatalf("Default expectation is already set for the Communicator.ExchangePhase21 method")
	}

	if len(mmExchangePhase21.expectations) > 0 {
		mmExchangePhase21.mock.t.Fatalf("Some expectations are already set for the Communicator.ExchangePhase21 method")
	}

	mmExchangePhase21.mock.funcExchangePhase21 = f
	return mmExchangePhase21.mock
}

// When sets expectation for the Communicator.ExchangePhase21 which will trigger the result defined by the following
// Then helper
func (mmExchangePhase21 *mCommunicatorMockExchangePhase21) When(ctx context.Context, state *ConsensusState, packet *packets.Phase2Packet, additionalRequests []*AdditionalRequest) *CommunicatorMockExchangePhase21Expectation {
	if mmExchangePhase21.mock.funcExchangePhase21 != nil {
		mmExchangePhase21.mock.t.Fatalf("CommunicatorMock.ExchangePhase21 mock is already set by Set")
	}

	expectation := &CommunicatorMockExchangePhase21Expectation{
		mock:   mmExchangePhase21.mock,
		params: &CommunicatorMockExchangePhase21Params{ctx, state, packet, additionalRequests},
	}
	mmExchangePhase21.expectations = append(mmExchangePhase21.expectations, expectation)
	return expectation
}

// Then sets up Communicator.ExchangePhase21 return parameters for the expectation previously defined by the When method
func (e *CommunicatorMockExchangePhase21Expectation) Then(ra1 []packets.ReferendumVote, err error) *CommunicatorMock {
	e.results = &CommunicatorMockExchangePhase21Results{ra1, err}
	return e.mock
}

// ExchangePhase21 implements Communicator
func (mmExchangePhase21 *CommunicatorMock) ExchangePhase21(ctx context.Context, state *ConsensusState, packet *packets.Phase2Packet, additionalRequests []*AdditionalRequest) (ra1 []packets.ReferendumVote, err error) {
	mm_atomic.AddUint64(&mmExchangePhase21.beforeExchangePhase21Counter, 1)
	defer mm_atomic.AddUint64(&mmExchangePhase21.afterExchangePhase21Counter, 1)

	if mmExchangePhase21.inspectFuncExchangePhase21 != nil {
		mmExchangePhase21.inspectFuncExchangePhase21(ctx, state, packet, additionalRequests)
	}

	params := &CommunicatorMockExchangePhase21Params{ctx, state, packet, additionalRequests}

	// Record call args
	mmExchangePhase21.ExchangePhase21Mock.mutex.Lock()
	mmExchangePhase21.ExchangePhase21Mock.callArgs = append(mmExchangePhase21.ExchangePhase21Mock.callArgs, params)
	mmExchangePhase21.ExchangePhase21Mock.mutex.Unlock()

	for _, e := range mmExchangePhase21.ExchangePhase21Mock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ra1, e.results.err
		}
	}

	if mmExchangePhase21.ExchangePhase21Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExchangePhase21.ExchangePhase21Mock.defaultExpectation.Counter, 1)
		want := mmExchangePhase21.ExchangePhase21Mock.defaultExpectation.params
		got := CommunicatorMockExchangePhase21Params{ctx, state, packet, additionalRequests}
		if want != nil && !minimock.Equal(*want, got) {
			mmExchangePhase21.t.Errorf("CommunicatorMock.ExchangePhase21 got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmExchangePhase21.ExchangePhase21Mock.defaultExpectation.results
		if results == nil {
			mmExchangePhase21.t.Fatal("No results are set for the CommunicatorMock.ExchangePhase21")
		}
		return (*results).ra1, (*results).err
	}
	if mmExchangePhase21.funcExchangePhase21 != nil {
		return mmExchangePhase21.funcExchangePhase21(ctx, state, packet, additionalRequests)
	}
	mmExchangePhase21.t.Fatalf("Unexpected call to CommunicatorMock.ExchangePhase21. %v %v %v %v", ctx, state, packet, additionalRequests)
	return
}

// ExchangePhase21AfterCounter returns a count of finished CommunicatorMock.ExchangePhase21 invocations
func (mmExchangePhase21 *CommunicatorMock) ExchangePhase21AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExchangePhase21.afterExchangePhase21Counter)
}

// ExchangePhase21BeforeCounter returns a count of CommunicatorMock.ExchangePhase21 invocations
func (mmExchangePhase21 *CommunicatorMock) ExchangePhase21BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExchangePhase21.beforeExchangePhase21Counter)
}

// Calls returns a list of arguments used in each call to CommunicatorMock.ExchangePhase21.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExchangePhase21 *mCommunicatorMockExchangePhase21) Calls() []*CommunicatorMockExchangePhase21Params {
	mmExchangePhase21.mutex.RLock()

	argCopy := make([]*CommunicatorMockExchangePhase21Params, len(mmExchangePhase21.callArgs))
	copy(argCopy, mmExchangePhase21.callArgs)

	mmExchangePhase21.mutex.RUnlock()

	return argCopy
}

// MinimockExchangePhase21Done returns true if the count of the ExchangePhase21 invocations corresponds
// the number of defined expectations
func (m *CommunicatorMock) MinimockExchangePhase21Done() bool {
	for _, e := range m.ExchangePhase21Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExchangePhase21Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExchangePhase21Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExchangePhase21 != nil && mm_atomic.LoadUint64(&m.afterExchangePhase21Counter) < 1 {
		return false
	}
	return true
}

// MinimockExchangePhase21Inspect logs each unmet expectation
func (m *CommunicatorMock) MinimockExchangePhase21Inspect() {
	for _, e := range m.ExchangePhase21Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommunicatorMock.ExchangePhase21 with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExchangePhase21Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExchangePhase21Counter) < 1 {
		if m.ExchangePhase21Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CommunicatorMock.ExchangePhase21")
		} else {
			m.t.Errorf("Expected call to CommunicatorMock.ExchangePhase21 with params: %#v", *m.ExchangePhase21Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExchangePhase21 != nil && mm_atomic.LoadUint64(&m.afterExchangePhase21Counter) < 1 {
		m.t.Error("Expected call to CommunicatorMock.ExchangePhase21")
	}
}

type mCommunicatorMockExchangePhase3 struct {
	mock               *CommunicatorMock
	defaultExpectation *CommunicatorMockExchangePhase3Expectation
	expectations       []*CommunicatorMockExchangePhase3Expectation

	callArgs []*CommunicatorMockExchangePhase3Params
	mutex    sync.RWMutex
}

// CommunicatorMockExchangePhase3Expectation specifies expectation struct of the Communicator.ExchangePhase3
type CommunicatorMockExchangePhase3Expectation struct {
	mock    *CommunicatorMock
	params  *CommunicatorMockExchangePhase3Params
	results *CommunicatorMockExchangePhase3Results
	Counter uint64
}

// CommunicatorMockExchangePhase3Params contains parameters of the Communicator.ExchangePhase3
type CommunicatorMockExchangePhase3Params struct {
	ctx          context.Context
	participants []insolar.NetworkNode
	packet       *packets.Phase3Packet
}

// CommunicatorMockExchangePhase3Results contains results of the Communicator.ExchangePhase3
type CommunicatorMockExchangePhase3Results struct {
	m1  map[insolar.Reference]*packets.Phase3Packet
	err error
}

// Expect sets up expected params for Communicator.ExchangePhase3
func (mmExchangePhase3 *mCommunicatorMockExchangePhase3) Expect(ctx context.Context, participants []insolar.NetworkNode, packet *packets.Phase3Packet) *mCommunicatorMockExchangePhase3 {
	if mmExchangePhase3.mock.funcExchangePhase3 != nil {
		mmExchangePhase3.mock.t.Fatalf("CommunicatorMock.ExchangePhase3 mock is already set by Set")
	}

	if mmExchangePhase3.defaultExpectation == nil {
		mmExchangePhase3.defaultExpectation = &CommunicatorMockExchangePhase3Expectation{}
	}

	mmExchangePhase3.defaultExpectation.params = &CommunicatorMockExchangePhase3Params{ctx, participants, packet}
	for _, e := range mmExchangePhase3.expectations {
		if minimock.Equal(e.params, mmExchangePhase3.defaultExpectation.params) {
			mmExchangePhase3.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExchangePhase3.defaultExpectation.params)
		}
	}

	return mmExchangePhase3
}

// Inspect accepts an inspector function that has same arguments as the Communicator.ExchangePhase3
func (mmExchangePhase3 *mCommunicatorMockExchangePhase3) Inspect(f func(ctx context.Context, participants []insolar.NetworkNode, packet *packets.Phase3Packet)) *mCommunicatorMockExchangePhase3 {
	if mmExchangePhase3.mock.inspectFuncExchangePhase3 != nil {
		mmExchangePhase3.mock.t.Fatalf("Inspect function is already set for CommunicatorMock.ExchangePhase3")
	}

	mmExchangePhase3.mock.inspectFuncExchangePhase3 = f

	return mmExchangePhase3
}

// Return sets up results that will be returned by Communicator.ExchangePhase3
func (mmExchangePhase3 *mCommunicatorMockExchangePhase3) Return(m1 map[insolar.Reference]*packets.Phase3Packet, err error) *CommunicatorMock {
	if mmExchangePhase3.mock.funcExchangePhase3 != nil {
		mmExchangePhase3.mock.t.Fatalf("CommunicatorMock.ExchangePhase3 mock is already set by Set")
	}

	if mmExchangePhase3.defaultExpectation == nil {
		mmExchangePhase3.defaultExpectation = &CommunicatorMockExchangePhase3Expectation{mock: mmExchangePhase3.mock}
	}
	mmExchangePhase3.defaultExpectation.results = &CommunicatorMockExchangePhase3Results{m1, err}
	return mmExchangePhase3.mock
}

//Set uses given function f to mock the Communicator.ExchangePhase3 method
func (mmExchangePhase3 *mCommunicatorMockExchangePhase3) Set(f func(ctx context.Context, participants []insolar.NetworkNode, packet *packets.Phase3Packet) (m1 map[insolar.Reference]*packets.Phase3Packet, err error)) *CommunicatorMock {
	if mmExchangePhase3.defaultExpectation != nil {
		mmExchangePhase3.mock.t.Fatalf("Default expectation is already set for the Communicator.ExchangePhase3 method")
	}

	if len(mmExchangePhase3.expectations) > 0 {
		mmExchangePhase3.mock.t.Fatalf("Some expectations are already set for the Communicator.ExchangePhase3 method")
	}

	mmExchangePhase3.mock.funcExchangePhase3 = f
	return mmExchangePhase3.mock
}

// When sets expectation for the Communicator.ExchangePhase3 which will trigger the result defined by the following
// Then helper
func (mmExchangePhase3 *mCommunicatorMockExchangePhase3) When(ctx context.Context, participants []insolar.NetworkNode, packet *packets.Phase3Packet) *CommunicatorMockExchangePhase3Expectation {
	if mmExchangePhase3.mock.funcExchangePhase3 != nil {
		mmExchangePhase3.mock.t.Fatalf("CommunicatorMock.ExchangePhase3 mock is already set by Set")
	}

	expectation := &CommunicatorMockExchangePhase3Expectation{
		mock:   mmExchangePhase3.mock,
		params: &CommunicatorMockExchangePhase3Params{ctx, participants, packet},
	}
	mmExchangePhase3.expectations = append(mmExchangePhase3.expectations, expectation)
	return expectation
}

// Then sets up Communicator.ExchangePhase3 return parameters for the expectation previously defined by the When method
func (e *CommunicatorMockExchangePhase3Expectation) Then(m1 map[insolar.Reference]*packets.Phase3Packet, err error) *CommunicatorMock {
	e.results = &CommunicatorMockExchangePhase3Results{m1, err}
	return e.mock
}

// ExchangePhase3 implements Communicator
func (mmExchangePhase3 *CommunicatorMock) ExchangePhase3(ctx context.Context, participants []insolar.NetworkNode, packet *packets.Phase3Packet) (m1 map[insolar.Reference]*packets.Phase3Packet, err error) {
	mm_atomic.AddUint64(&mmExchangePhase3.beforeExchangePhase3Counter, 1)
	defer mm_atomic.AddUint64(&mmExchangePhase3.afterExchangePhase3Counter, 1)

	if mmExchangePhase3.inspectFuncExchangePhase3 != nil {
		mmExchangePhase3.inspectFuncExchangePhase3(ctx, participants, packet)
	}

	params := &CommunicatorMockExchangePhase3Params{ctx, participants, packet}

	// Record call args
	mmExchangePhase3.ExchangePhase3Mock.mutex.Lock()
	mmExchangePhase3.ExchangePhase3Mock.callArgs = append(mmExchangePhase3.ExchangePhase3Mock.callArgs, params)
	mmExchangePhase3.ExchangePhase3Mock.mutex.Unlock()

	for _, e := range mmExchangePhase3.ExchangePhase3Mock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmExchangePhase3.ExchangePhase3Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExchangePhase3.ExchangePhase3Mock.defaultExpectation.Counter, 1)
		want := mmExchangePhase3.ExchangePhase3Mock.defaultExpectation.params
		got := CommunicatorMockExchangePhase3Params{ctx, participants, packet}
		if want != nil && !minimock.Equal(*want, got) {
			mmExchangePhase3.t.Errorf("CommunicatorMock.ExchangePhase3 got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmExchangePhase3.ExchangePhase3Mock.defaultExpectation.results
		if results == nil {
			mmExchangePhase3.t.Fatal("No results are set for the CommunicatorMock.ExchangePhase3")
		}
		return (*results).m1, (*results).err
	}
	if mmExchangePhase3.funcExchangePhase3 != nil {
		return mmExchangePhase3.funcExchangePhase3(ctx, participants, packet)
	}
	mmExchangePhase3.t.Fatalf("Unexpected call to CommunicatorMock.ExchangePhase3. %v %v %v", ctx, participants, packet)
	return
}

// ExchangePhase3AfterCounter returns a count of finished CommunicatorMock.ExchangePhase3 invocations
func (mmExchangePhase3 *CommunicatorMock) ExchangePhase3AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExchangePhase3.afterExchangePhase3Counter)
}

// ExchangePhase3BeforeCounter returns a count of CommunicatorMock.ExchangePhase3 invocations
func (mmExchangePhase3 *CommunicatorMock) ExchangePhase3BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExchangePhase3.beforeExchangePhase3Counter)
}

// Calls returns a list of arguments used in each call to CommunicatorMock.ExchangePhase3.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExchangePhase3 *mCommunicatorMockExchangePhase3) Calls() []*CommunicatorMockExchangePhase3Params {
	mmExchangePhase3.mutex.RLock()

	argCopy := make([]*CommunicatorMockExchangePhase3Params, len(mmExchangePhase3.callArgs))
	copy(argCopy, mmExchangePhase3.callArgs)

	mmExchangePhase3.mutex.RUnlock()

	return argCopy
}

// MinimockExchangePhase3Done returns true if the count of the ExchangePhase3 invocations corresponds
// the number of defined expectations
func (m *CommunicatorMock) MinimockExchangePhase3Done() bool {
	for _, e := range m.ExchangePhase3Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExchangePhase3Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExchangePhase3Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExchangePhase3 != nil && mm_atomic.LoadUint64(&m.afterExchangePhase3Counter) < 1 {
		return false
	}
	return true
}

// MinimockExchangePhase3Inspect logs each unmet expectation
func (m *CommunicatorMock) MinimockExchangePhase3Inspect() {
	for _, e := range m.ExchangePhase3Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommunicatorMock.ExchangePhase3 with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExchangePhase3Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExchangePhase3Counter) < 1 {
		if m.ExchangePhase3Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CommunicatorMock.ExchangePhase3")
		} else {
			m.t.Errorf("Expected call to CommunicatorMock.ExchangePhase3 with params: %#v", *m.ExchangePhase3Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExchangePhase3 != nil && mm_atomic.LoadUint64(&m.afterExchangePhase3Counter) < 1 {
		m.t.Error("Expected call to CommunicatorMock.ExchangePhase3")
	}
}

type mCommunicatorMockInit struct {
	mock               *CommunicatorMock
	defaultExpectation *CommunicatorMockInitExpectation
	expectations       []*CommunicatorMockInitExpectation

	callArgs []*CommunicatorMockInitParams
	mutex    sync.RWMutex
}

// CommunicatorMockInitExpectation specifies expectation struct of the Communicator.Init
type CommunicatorMockInitExpectation struct {
	mock    *CommunicatorMock
	params  *CommunicatorMockInitParams
	results *CommunicatorMockInitResults
	Counter uint64
}

// CommunicatorMockInitParams contains parameters of the Communicator.Init
type CommunicatorMockInitParams struct {
	ctx context.Context
}

// CommunicatorMockInitResults contains results of the Communicator.Init
type CommunicatorMockInitResults struct {
	err error
}

// Expect sets up expected params for Communicator.Init
func (mmInit *mCommunicatorMockInit) Expect(ctx context.Context) *mCommunicatorMockInit {
	if mmInit.mock.funcInit != nil {
		mmInit.mock.t.Fatalf("CommunicatorMock.Init mock is already set by Set")
	}

	if mmInit.defaultExpectation == nil {
		mmInit.defaultExpectation = &CommunicatorMockInitExpectation{}
	}

	mmInit.defaultExpectation.params = &CommunicatorMockInitParams{ctx}
	for _, e := range mmInit.expectations {
		if minimock.Equal(e.params, mmInit.defaultExpectation.params) {
			mmInit.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInit.defaultExpectation.params)
		}
	}

	return mmInit
}

// Inspect accepts an inspector function that has same arguments as the Communicator.Init
func (mmInit *mCommunicatorMockInit) Inspect(f func(ctx context.Context)) *mCommunicatorMockInit {
	if mmInit.mock.inspectFuncInit != nil {
		mmInit.mock.t.Fatalf("Inspect function is already set for CommunicatorMock.Init")
	}

	mmInit.mock.inspectFuncInit = f

	return mmInit
}

// Return sets up results that will be returned by Communicator.Init
func (mmInit *mCommunicatorMockInit) Return(err error) *CommunicatorMock {
	if mmInit.mock.funcInit != nil {
		mmInit.mock.t.Fatalf("CommunicatorMock.Init mock is already set by Set")
	}

	if mmInit.defaultExpectation == nil {
		mmInit.defaultExpectation = &CommunicatorMockInitExpectation{mock: mmInit.mock}
	}
	mmInit.defaultExpectation.results = &CommunicatorMockInitResults{err}
	return mmInit.mock
}

//Set uses given function f to mock the Communicator.Init method
func (mmInit *mCommunicatorMockInit) Set(f func(ctx context.Context) (err error)) *CommunicatorMock {
	if mmInit.defaultExpectation != nil {
		mmInit.mock.t.Fatalf("Default expectation is already set for the Communicator.Init method")
	}

	if len(mmInit.expectations) > 0 {
		mmInit.mock.t.Fatalf("Some expectations are already set for the Communicator.Init method")
	}

	mmInit.mock.funcInit = f
	return mmInit.mock
}

// When sets expectation for the Communicator.Init which will trigger the result defined by the following
// Then helper
func (mmInit *mCommunicatorMockInit) When(ctx context.Context) *CommunicatorMockInitExpectation {
	if mmInit.mock.funcInit != nil {
		mmInit.mock.t.Fatalf("CommunicatorMock.Init mock is already set by Set")
	}

	expectation := &CommunicatorMockInitExpectation{
		mock:   mmInit.mock,
		params: &CommunicatorMockInitParams{ctx},
	}
	mmInit.expectations = append(mmInit.expectations, expectation)
	return expectation
}

// Then sets up Communicator.Init return parameters for the expectation previously defined by the When method
func (e *CommunicatorMockInitExpectation) Then(err error) *CommunicatorMock {
	e.results = &CommunicatorMockInitResults{err}
	return e.mock
}

// Init implements Communicator
func (mmInit *CommunicatorMock) Init(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmInit.beforeInitCounter, 1)
	defer mm_atomic.AddUint64(&mmInit.afterInitCounter, 1)

	if mmInit.inspectFuncInit != nil {
		mmInit.inspectFuncInit(ctx)
	}

	params := &CommunicatorMockInitParams{ctx}

	// Record call args
	mmInit.InitMock.mutex.Lock()
	mmInit.InitMock.callArgs = append(mmInit.InitMock.callArgs, params)
	mmInit.InitMock.mutex.Unlock()

	for _, e := range mmInit.InitMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmInit.InitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInit.InitMock.defaultExpectation.Counter, 1)
		want := mmInit.InitMock.defaultExpectation.params
		got := CommunicatorMockInitParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmInit.t.Errorf("CommunicatorMock.Init got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmInit.InitMock.defaultExpectation.results
		if results == nil {
			mmInit.t.Fatal("No results are set for the CommunicatorMock.Init")
		}
		return (*results).err
	}
	if mmInit.funcInit != nil {
		return mmInit.funcInit(ctx)
	}
	mmInit.t.Fatalf("Unexpected call to CommunicatorMock.Init. %v", ctx)
	return
}

// InitAfterCounter returns a count of finished CommunicatorMock.Init invocations
func (mmInit *CommunicatorMock) InitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInit.afterInitCounter)
}

// InitBeforeCounter returns a count of CommunicatorMock.Init invocations
func (mmInit *CommunicatorMock) InitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInit.beforeInitCounter)
}

// Calls returns a list of arguments used in each call to CommunicatorMock.Init.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInit *mCommunicatorMockInit) Calls() []*CommunicatorMockInitParams {
	mmInit.mutex.RLock()

	argCopy := make([]*CommunicatorMockInitParams, len(mmInit.callArgs))
	copy(argCopy, mmInit.callArgs)

	mmInit.mutex.RUnlock()

	return argCopy
}

// MinimockInitDone returns true if the count of the Init invocations corresponds
// the number of defined expectations
func (m *CommunicatorMock) MinimockInitDone() bool {
	for _, e := range m.InitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInitCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInit != nil && mm_atomic.LoadUint64(&m.afterInitCounter) < 1 {
		return false
	}
	return true
}

// MinimockInitInspect logs each unmet expectation
func (m *CommunicatorMock) MinimockInitInspect() {
	for _, e := range m.InitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommunicatorMock.Init with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInitCounter) < 1 {
		if m.InitMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CommunicatorMock.Init")
		} else {
			m.t.Errorf("Expected call to CommunicatorMock.Init with params: %#v", *m.InitMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInit != nil && mm_atomic.LoadUint64(&m.afterInitCounter) < 1 {
		m.t.Error("Expected call to CommunicatorMock.Init")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CommunicatorMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockExchangePhase1Inspect()

		m.MinimockExchangePhase2Inspect()

		m.MinimockExchangePhase21Inspect()

		m.MinimockExchangePhase3Inspect()

		m.MinimockInitInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CommunicatorMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CommunicatorMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockExchangePhase1Done() &&
		m.MinimockExchangePhase2Done() &&
		m.MinimockExchangePhase21Done() &&
		m.MinimockExchangePhase3Done() &&
		m.MinimockInitDone()
}
