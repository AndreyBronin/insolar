package packets

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
)

// BitSetMapperMock implements BitSetMapper
type BitSetMapperMock struct {
	t minimock.Tester

	funcIndexToRef          func(index int) (r1 insolar.Reference, err error)
	inspectFuncIndexToRef   func(index int)
	afterIndexToRefCounter  uint64
	beforeIndexToRefCounter uint64
	IndexToRefMock          mBitSetMapperMockIndexToRef

	funcLength          func() (i1 int)
	inspectFuncLength   func()
	afterLengthCounter  uint64
	beforeLengthCounter uint64
	LengthMock          mBitSetMapperMockLength

	funcRefToIndex          func(nodeID insolar.Reference) (i1 int, err error)
	inspectFuncRefToIndex   func(nodeID insolar.Reference)
	afterRefToIndexCounter  uint64
	beforeRefToIndexCounter uint64
	RefToIndexMock          mBitSetMapperMockRefToIndex
}

// NewBitSetMapperMock returns a mock for BitSetMapper
func NewBitSetMapperMock(t minimock.Tester) *BitSetMapperMock {
	m := &BitSetMapperMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.IndexToRefMock = mBitSetMapperMockIndexToRef{mock: m}
	m.IndexToRefMock.callArgs = []*BitSetMapperMockIndexToRefParams{}

	m.LengthMock = mBitSetMapperMockLength{mock: m}

	m.RefToIndexMock = mBitSetMapperMockRefToIndex{mock: m}
	m.RefToIndexMock.callArgs = []*BitSetMapperMockRefToIndexParams{}

	return m
}

type mBitSetMapperMockIndexToRef struct {
	mock               *BitSetMapperMock
	defaultExpectation *BitSetMapperMockIndexToRefExpectation
	expectations       []*BitSetMapperMockIndexToRefExpectation

	callArgs []*BitSetMapperMockIndexToRefParams
	mutex    sync.RWMutex
}

// BitSetMapperMockIndexToRefExpectation specifies expectation struct of the BitSetMapper.IndexToRef
type BitSetMapperMockIndexToRefExpectation struct {
	mock    *BitSetMapperMock
	params  *BitSetMapperMockIndexToRefParams
	results *BitSetMapperMockIndexToRefResults
	Counter uint64
}

// BitSetMapperMockIndexToRefParams contains parameters of the BitSetMapper.IndexToRef
type BitSetMapperMockIndexToRefParams struct {
	index int
}

// BitSetMapperMockIndexToRefResults contains results of the BitSetMapper.IndexToRef
type BitSetMapperMockIndexToRefResults struct {
	r1  insolar.Reference
	err error
}

// Expect sets up expected params for BitSetMapper.IndexToRef
func (mmIndexToRef *mBitSetMapperMockIndexToRef) Expect(index int) *mBitSetMapperMockIndexToRef {
	if mmIndexToRef.mock.funcIndexToRef != nil {
		mmIndexToRef.mock.t.Fatalf("BitSetMapperMock.IndexToRef mock is already set by Set")
	}

	if mmIndexToRef.defaultExpectation == nil {
		mmIndexToRef.defaultExpectation = &BitSetMapperMockIndexToRefExpectation{}
	}

	mmIndexToRef.defaultExpectation.params = &BitSetMapperMockIndexToRefParams{index}
	for _, e := range mmIndexToRef.expectations {
		if minimock.Equal(e.params, mmIndexToRef.defaultExpectation.params) {
			mmIndexToRef.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIndexToRef.defaultExpectation.params)
		}
	}

	return mmIndexToRef
}

// Inspect accepts an inspector function that has same arguments as the BitSetMapper.IndexToRef
func (mmIndexToRef *mBitSetMapperMockIndexToRef) Inspect(f func(index int)) *mBitSetMapperMockIndexToRef {
	if mmIndexToRef.mock.inspectFuncIndexToRef != nil {
		mmIndexToRef.mock.t.Fatalf("Inspect function is already set for BitSetMapperMock.IndexToRef")
	}

	mmIndexToRef.mock.inspectFuncIndexToRef = f

	return mmIndexToRef
}

// Return sets up results that will be returned by BitSetMapper.IndexToRef
func (mmIndexToRef *mBitSetMapperMockIndexToRef) Return(r1 insolar.Reference, err error) *BitSetMapperMock {
	if mmIndexToRef.mock.funcIndexToRef != nil {
		mmIndexToRef.mock.t.Fatalf("BitSetMapperMock.IndexToRef mock is already set by Set")
	}

	if mmIndexToRef.defaultExpectation == nil {
		mmIndexToRef.defaultExpectation = &BitSetMapperMockIndexToRefExpectation{mock: mmIndexToRef.mock}
	}
	mmIndexToRef.defaultExpectation.results = &BitSetMapperMockIndexToRefResults{r1, err}
	return mmIndexToRef.mock
}

//Set uses given function f to mock the BitSetMapper.IndexToRef method
func (mmIndexToRef *mBitSetMapperMockIndexToRef) Set(f func(index int) (r1 insolar.Reference, err error)) *BitSetMapperMock {
	if mmIndexToRef.defaultExpectation != nil {
		mmIndexToRef.mock.t.Fatalf("Default expectation is already set for the BitSetMapper.IndexToRef method")
	}

	if len(mmIndexToRef.expectations) > 0 {
		mmIndexToRef.mock.t.Fatalf("Some expectations are already set for the BitSetMapper.IndexToRef method")
	}

	mmIndexToRef.mock.funcIndexToRef = f
	return mmIndexToRef.mock
}

// When sets expectation for the BitSetMapper.IndexToRef which will trigger the result defined by the following
// Then helper
func (mmIndexToRef *mBitSetMapperMockIndexToRef) When(index int) *BitSetMapperMockIndexToRefExpectation {
	if mmIndexToRef.mock.funcIndexToRef != nil {
		mmIndexToRef.mock.t.Fatalf("BitSetMapperMock.IndexToRef mock is already set by Set")
	}

	expectation := &BitSetMapperMockIndexToRefExpectation{
		mock:   mmIndexToRef.mock,
		params: &BitSetMapperMockIndexToRefParams{index},
	}
	mmIndexToRef.expectations = append(mmIndexToRef.expectations, expectation)
	return expectation
}

// Then sets up BitSetMapper.IndexToRef return parameters for the expectation previously defined by the When method
func (e *BitSetMapperMockIndexToRefExpectation) Then(r1 insolar.Reference, err error) *BitSetMapperMock {
	e.results = &BitSetMapperMockIndexToRefResults{r1, err}
	return e.mock
}

// IndexToRef implements BitSetMapper
func (mmIndexToRef *BitSetMapperMock) IndexToRef(index int) (r1 insolar.Reference, err error) {
	mm_atomic.AddUint64(&mmIndexToRef.beforeIndexToRefCounter, 1)
	defer mm_atomic.AddUint64(&mmIndexToRef.afterIndexToRefCounter, 1)

	if mmIndexToRef.inspectFuncIndexToRef != nil {
		mmIndexToRef.inspectFuncIndexToRef(index)
	}

	params := &BitSetMapperMockIndexToRefParams{index}

	// Record call args
	mmIndexToRef.IndexToRefMock.mutex.Lock()
	mmIndexToRef.IndexToRefMock.callArgs = append(mmIndexToRef.IndexToRefMock.callArgs, params)
	mmIndexToRef.IndexToRefMock.mutex.Unlock()

	for _, e := range mmIndexToRef.IndexToRefMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmIndexToRef.IndexToRefMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIndexToRef.IndexToRefMock.defaultExpectation.Counter, 1)
		want := mmIndexToRef.IndexToRefMock.defaultExpectation.params
		got := BitSetMapperMockIndexToRefParams{index}
		if want != nil && !minimock.Equal(*want, got) {
			mmIndexToRef.t.Errorf("BitSetMapperMock.IndexToRef got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmIndexToRef.IndexToRefMock.defaultExpectation.results
		if results == nil {
			mmIndexToRef.t.Fatal("No results are set for the BitSetMapperMock.IndexToRef")
		}
		return (*results).r1, (*results).err
	}
	if mmIndexToRef.funcIndexToRef != nil {
		return mmIndexToRef.funcIndexToRef(index)
	}
	mmIndexToRef.t.Fatalf("Unexpected call to BitSetMapperMock.IndexToRef. %v", index)
	return
}

// IndexToRefAfterCounter returns a count of finished BitSetMapperMock.IndexToRef invocations
func (mmIndexToRef *BitSetMapperMock) IndexToRefAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIndexToRef.afterIndexToRefCounter)
}

// IndexToRefBeforeCounter returns a count of BitSetMapperMock.IndexToRef invocations
func (mmIndexToRef *BitSetMapperMock) IndexToRefBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIndexToRef.beforeIndexToRefCounter)
}

// Calls returns a list of arguments used in each call to BitSetMapperMock.IndexToRef.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIndexToRef *mBitSetMapperMockIndexToRef) Calls() []*BitSetMapperMockIndexToRefParams {
	mmIndexToRef.mutex.RLock()

	argCopy := make([]*BitSetMapperMockIndexToRefParams, len(mmIndexToRef.callArgs))
	copy(argCopy, mmIndexToRef.callArgs)

	mmIndexToRef.mutex.RUnlock()

	return argCopy
}

// MinimockIndexToRefDone returns true if the count of the IndexToRef invocations corresponds
// the number of defined expectations
func (m *BitSetMapperMock) MinimockIndexToRefDone() bool {
	for _, e := range m.IndexToRefMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IndexToRefMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIndexToRefCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIndexToRef != nil && mm_atomic.LoadUint64(&m.afterIndexToRefCounter) < 1 {
		return false
	}
	return true
}

// MinimockIndexToRefInspect logs each unmet expectation
func (m *BitSetMapperMock) MinimockIndexToRefInspect() {
	for _, e := range m.IndexToRefMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BitSetMapperMock.IndexToRef with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IndexToRefMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIndexToRefCounter) < 1 {
		if m.IndexToRefMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BitSetMapperMock.IndexToRef")
		} else {
			m.t.Errorf("Expected call to BitSetMapperMock.IndexToRef with params: %#v", *m.IndexToRefMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIndexToRef != nil && mm_atomic.LoadUint64(&m.afterIndexToRefCounter) < 1 {
		m.t.Error("Expected call to BitSetMapperMock.IndexToRef")
	}
}

type mBitSetMapperMockLength struct {
	mock               *BitSetMapperMock
	defaultExpectation *BitSetMapperMockLengthExpectation
	expectations       []*BitSetMapperMockLengthExpectation
}

// BitSetMapperMockLengthExpectation specifies expectation struct of the BitSetMapper.Length
type BitSetMapperMockLengthExpectation struct {
	mock *BitSetMapperMock

	results *BitSetMapperMockLengthResults
	Counter uint64
}

// BitSetMapperMockLengthResults contains results of the BitSetMapper.Length
type BitSetMapperMockLengthResults struct {
	i1 int
}

// Expect sets up expected params for BitSetMapper.Length
func (mmLength *mBitSetMapperMockLength) Expect() *mBitSetMapperMockLength {
	if mmLength.mock.funcLength != nil {
		mmLength.mock.t.Fatalf("BitSetMapperMock.Length mock is already set by Set")
	}

	if mmLength.defaultExpectation == nil {
		mmLength.defaultExpectation = &BitSetMapperMockLengthExpectation{}
	}

	return mmLength
}

// Inspect accepts an inspector function that has same arguments as the BitSetMapper.Length
func (mmLength *mBitSetMapperMockLength) Inspect(f func()) *mBitSetMapperMockLength {
	if mmLength.mock.inspectFuncLength != nil {
		mmLength.mock.t.Fatalf("Inspect function is already set for BitSetMapperMock.Length")
	}

	mmLength.mock.inspectFuncLength = f

	return mmLength
}

// Return sets up results that will be returned by BitSetMapper.Length
func (mmLength *mBitSetMapperMockLength) Return(i1 int) *BitSetMapperMock {
	if mmLength.mock.funcLength != nil {
		mmLength.mock.t.Fatalf("BitSetMapperMock.Length mock is already set by Set")
	}

	if mmLength.defaultExpectation == nil {
		mmLength.defaultExpectation = &BitSetMapperMockLengthExpectation{mock: mmLength.mock}
	}
	mmLength.defaultExpectation.results = &BitSetMapperMockLengthResults{i1}
	return mmLength.mock
}

//Set uses given function f to mock the BitSetMapper.Length method
func (mmLength *mBitSetMapperMockLength) Set(f func() (i1 int)) *BitSetMapperMock {
	if mmLength.defaultExpectation != nil {
		mmLength.mock.t.Fatalf("Default expectation is already set for the BitSetMapper.Length method")
	}

	if len(mmLength.expectations) > 0 {
		mmLength.mock.t.Fatalf("Some expectations are already set for the BitSetMapper.Length method")
	}

	mmLength.mock.funcLength = f
	return mmLength.mock
}

// Length implements BitSetMapper
func (mmLength *BitSetMapperMock) Length() (i1 int) {
	mm_atomic.AddUint64(&mmLength.beforeLengthCounter, 1)
	defer mm_atomic.AddUint64(&mmLength.afterLengthCounter, 1)

	if mmLength.inspectFuncLength != nil {
		mmLength.inspectFuncLength()
	}

	if mmLength.LengthMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLength.LengthMock.defaultExpectation.Counter, 1)

		results := mmLength.LengthMock.defaultExpectation.results
		if results == nil {
			mmLength.t.Fatal("No results are set for the BitSetMapperMock.Length")
		}
		return (*results).i1
	}
	if mmLength.funcLength != nil {
		return mmLength.funcLength()
	}
	mmLength.t.Fatalf("Unexpected call to BitSetMapperMock.Length.")
	return
}

// LengthAfterCounter returns a count of finished BitSetMapperMock.Length invocations
func (mmLength *BitSetMapperMock) LengthAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLength.afterLengthCounter)
}

// LengthBeforeCounter returns a count of BitSetMapperMock.Length invocations
func (mmLength *BitSetMapperMock) LengthBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLength.beforeLengthCounter)
}

// MinimockLengthDone returns true if the count of the Length invocations corresponds
// the number of defined expectations
func (m *BitSetMapperMock) MinimockLengthDone() bool {
	for _, e := range m.LengthMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LengthMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLengthCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLength != nil && mm_atomic.LoadUint64(&m.afterLengthCounter) < 1 {
		return false
	}
	return true
}

// MinimockLengthInspect logs each unmet expectation
func (m *BitSetMapperMock) MinimockLengthInspect() {
	for _, e := range m.LengthMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to BitSetMapperMock.Length")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LengthMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLengthCounter) < 1 {
		m.t.Error("Expected call to BitSetMapperMock.Length")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLength != nil && mm_atomic.LoadUint64(&m.afterLengthCounter) < 1 {
		m.t.Error("Expected call to BitSetMapperMock.Length")
	}
}

type mBitSetMapperMockRefToIndex struct {
	mock               *BitSetMapperMock
	defaultExpectation *BitSetMapperMockRefToIndexExpectation
	expectations       []*BitSetMapperMockRefToIndexExpectation

	callArgs []*BitSetMapperMockRefToIndexParams
	mutex    sync.RWMutex
}

// BitSetMapperMockRefToIndexExpectation specifies expectation struct of the BitSetMapper.RefToIndex
type BitSetMapperMockRefToIndexExpectation struct {
	mock    *BitSetMapperMock
	params  *BitSetMapperMockRefToIndexParams
	results *BitSetMapperMockRefToIndexResults
	Counter uint64
}

// BitSetMapperMockRefToIndexParams contains parameters of the BitSetMapper.RefToIndex
type BitSetMapperMockRefToIndexParams struct {
	nodeID insolar.Reference
}

// BitSetMapperMockRefToIndexResults contains results of the BitSetMapper.RefToIndex
type BitSetMapperMockRefToIndexResults struct {
	i1  int
	err error
}

// Expect sets up expected params for BitSetMapper.RefToIndex
func (mmRefToIndex *mBitSetMapperMockRefToIndex) Expect(nodeID insolar.Reference) *mBitSetMapperMockRefToIndex {
	if mmRefToIndex.mock.funcRefToIndex != nil {
		mmRefToIndex.mock.t.Fatalf("BitSetMapperMock.RefToIndex mock is already set by Set")
	}

	if mmRefToIndex.defaultExpectation == nil {
		mmRefToIndex.defaultExpectation = &BitSetMapperMockRefToIndexExpectation{}
	}

	mmRefToIndex.defaultExpectation.params = &BitSetMapperMockRefToIndexParams{nodeID}
	for _, e := range mmRefToIndex.expectations {
		if minimock.Equal(e.params, mmRefToIndex.defaultExpectation.params) {
			mmRefToIndex.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRefToIndex.defaultExpectation.params)
		}
	}

	return mmRefToIndex
}

// Inspect accepts an inspector function that has same arguments as the BitSetMapper.RefToIndex
func (mmRefToIndex *mBitSetMapperMockRefToIndex) Inspect(f func(nodeID insolar.Reference)) *mBitSetMapperMockRefToIndex {
	if mmRefToIndex.mock.inspectFuncRefToIndex != nil {
		mmRefToIndex.mock.t.Fatalf("Inspect function is already set for BitSetMapperMock.RefToIndex")
	}

	mmRefToIndex.mock.inspectFuncRefToIndex = f

	return mmRefToIndex
}

// Return sets up results that will be returned by BitSetMapper.RefToIndex
func (mmRefToIndex *mBitSetMapperMockRefToIndex) Return(i1 int, err error) *BitSetMapperMock {
	if mmRefToIndex.mock.funcRefToIndex != nil {
		mmRefToIndex.mock.t.Fatalf("BitSetMapperMock.RefToIndex mock is already set by Set")
	}

	if mmRefToIndex.defaultExpectation == nil {
		mmRefToIndex.defaultExpectation = &BitSetMapperMockRefToIndexExpectation{mock: mmRefToIndex.mock}
	}
	mmRefToIndex.defaultExpectation.results = &BitSetMapperMockRefToIndexResults{i1, err}
	return mmRefToIndex.mock
}

//Set uses given function f to mock the BitSetMapper.RefToIndex method
func (mmRefToIndex *mBitSetMapperMockRefToIndex) Set(f func(nodeID insolar.Reference) (i1 int, err error)) *BitSetMapperMock {
	if mmRefToIndex.defaultExpectation != nil {
		mmRefToIndex.mock.t.Fatalf("Default expectation is already set for the BitSetMapper.RefToIndex method")
	}

	if len(mmRefToIndex.expectations) > 0 {
		mmRefToIndex.mock.t.Fatalf("Some expectations are already set for the BitSetMapper.RefToIndex method")
	}

	mmRefToIndex.mock.funcRefToIndex = f
	return mmRefToIndex.mock
}

// When sets expectation for the BitSetMapper.RefToIndex which will trigger the result defined by the following
// Then helper
func (mmRefToIndex *mBitSetMapperMockRefToIndex) When(nodeID insolar.Reference) *BitSetMapperMockRefToIndexExpectation {
	if mmRefToIndex.mock.funcRefToIndex != nil {
		mmRefToIndex.mock.t.Fatalf("BitSetMapperMock.RefToIndex mock is already set by Set")
	}

	expectation := &BitSetMapperMockRefToIndexExpectation{
		mock:   mmRefToIndex.mock,
		params: &BitSetMapperMockRefToIndexParams{nodeID},
	}
	mmRefToIndex.expectations = append(mmRefToIndex.expectations, expectation)
	return expectation
}

// Then sets up BitSetMapper.RefToIndex return parameters for the expectation previously defined by the When method
func (e *BitSetMapperMockRefToIndexExpectation) Then(i1 int, err error) *BitSetMapperMock {
	e.results = &BitSetMapperMockRefToIndexResults{i1, err}
	return e.mock
}

// RefToIndex implements BitSetMapper
func (mmRefToIndex *BitSetMapperMock) RefToIndex(nodeID insolar.Reference) (i1 int, err error) {
	mm_atomic.AddUint64(&mmRefToIndex.beforeRefToIndexCounter, 1)
	defer mm_atomic.AddUint64(&mmRefToIndex.afterRefToIndexCounter, 1)

	if mmRefToIndex.inspectFuncRefToIndex != nil {
		mmRefToIndex.inspectFuncRefToIndex(nodeID)
	}

	params := &BitSetMapperMockRefToIndexParams{nodeID}

	// Record call args
	mmRefToIndex.RefToIndexMock.mutex.Lock()
	mmRefToIndex.RefToIndexMock.callArgs = append(mmRefToIndex.RefToIndexMock.callArgs, params)
	mmRefToIndex.RefToIndexMock.mutex.Unlock()

	for _, e := range mmRefToIndex.RefToIndexMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmRefToIndex.RefToIndexMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRefToIndex.RefToIndexMock.defaultExpectation.Counter, 1)
		want := mmRefToIndex.RefToIndexMock.defaultExpectation.params
		got := BitSetMapperMockRefToIndexParams{nodeID}
		if want != nil && !minimock.Equal(*want, got) {
			mmRefToIndex.t.Errorf("BitSetMapperMock.RefToIndex got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRefToIndex.RefToIndexMock.defaultExpectation.results
		if results == nil {
			mmRefToIndex.t.Fatal("No results are set for the BitSetMapperMock.RefToIndex")
		}
		return (*results).i1, (*results).err
	}
	if mmRefToIndex.funcRefToIndex != nil {
		return mmRefToIndex.funcRefToIndex(nodeID)
	}
	mmRefToIndex.t.Fatalf("Unexpected call to BitSetMapperMock.RefToIndex. %v", nodeID)
	return
}

// RefToIndexAfterCounter returns a count of finished BitSetMapperMock.RefToIndex invocations
func (mmRefToIndex *BitSetMapperMock) RefToIndexAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRefToIndex.afterRefToIndexCounter)
}

// RefToIndexBeforeCounter returns a count of BitSetMapperMock.RefToIndex invocations
func (mmRefToIndex *BitSetMapperMock) RefToIndexBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRefToIndex.beforeRefToIndexCounter)
}

// Calls returns a list of arguments used in each call to BitSetMapperMock.RefToIndex.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRefToIndex *mBitSetMapperMockRefToIndex) Calls() []*BitSetMapperMockRefToIndexParams {
	mmRefToIndex.mutex.RLock()

	argCopy := make([]*BitSetMapperMockRefToIndexParams, len(mmRefToIndex.callArgs))
	copy(argCopy, mmRefToIndex.callArgs)

	mmRefToIndex.mutex.RUnlock()

	return argCopy
}

// MinimockRefToIndexDone returns true if the count of the RefToIndex invocations corresponds
// the number of defined expectations
func (m *BitSetMapperMock) MinimockRefToIndexDone() bool {
	for _, e := range m.RefToIndexMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RefToIndexMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRefToIndexCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRefToIndex != nil && mm_atomic.LoadUint64(&m.afterRefToIndexCounter) < 1 {
		return false
	}
	return true
}

// MinimockRefToIndexInspect logs each unmet expectation
func (m *BitSetMapperMock) MinimockRefToIndexInspect() {
	for _, e := range m.RefToIndexMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BitSetMapperMock.RefToIndex with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RefToIndexMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRefToIndexCounter) < 1 {
		if m.RefToIndexMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BitSetMapperMock.RefToIndex")
		} else {
			m.t.Errorf("Expected call to BitSetMapperMock.RefToIndex with params: %#v", *m.RefToIndexMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRefToIndex != nil && mm_atomic.LoadUint64(&m.afterRefToIndexCounter) < 1 {
		m.t.Error("Expected call to BitSetMapperMock.RefToIndex")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *BitSetMapperMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockIndexToRefInspect()

		m.MinimockLengthInspect()

		m.MinimockRefToIndexInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *BitSetMapperMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *BitSetMapperMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockIndexToRefDone() &&
		m.MinimockLengthDone() &&
		m.MinimockRefToIndexDone()
}
