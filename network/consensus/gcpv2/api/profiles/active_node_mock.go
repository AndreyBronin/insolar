package profiles

// Code generated by http://github.com/gojuno/minimock (3.0.0). DO NOT EDIT.

import (
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/insolar/insolar"
	"github.com/insolar/insolar/network/consensus/common/cryptkit"
	"github.com/insolar/insolar/network/consensus/gcpv2/api/member"
)

// ActiveNodeMock implements ActiveNode
type ActiveNodeMock struct {
	t minimock.Tester

	funcGetDeclaredPower          func() (p1 member.Power)
	inspectFuncGetDeclaredPower   func()
	afterGetDeclaredPowerCounter  uint64
	beforeGetDeclaredPowerCounter uint64
	GetDeclaredPowerMock          mActiveNodeMockGetDeclaredPower

	funcGetIndex          func() (i1 member.Index)
	inspectFuncGetIndex   func()
	afterGetIndexCounter  uint64
	beforeGetIndexCounter uint64
	GetIndexMock          mActiveNodeMockGetIndex

	funcGetNodeID          func() (s1 insolar.ShortNodeID)
	inspectFuncGetNodeID   func()
	afterGetNodeIDCounter  uint64
	beforeGetNodeIDCounter uint64
	GetNodeIDMock          mActiveNodeMockGetNodeID

	funcGetOpMode          func() (o1 member.OpMode)
	inspectFuncGetOpMode   func()
	afterGetOpModeCounter  uint64
	beforeGetOpModeCounter uint64
	GetOpModeMock          mActiveNodeMockGetOpMode

	funcGetSignatureVerifier          func() (s1 cryptkit.SignatureVerifier)
	inspectFuncGetSignatureVerifier   func()
	afterGetSignatureVerifierCounter  uint64
	beforeGetSignatureVerifierCounter uint64
	GetSignatureVerifierMock          mActiveNodeMockGetSignatureVerifier

	funcGetStatic          func() (s1 StaticProfile)
	inspectFuncGetStatic   func()
	afterGetStaticCounter  uint64
	beforeGetStaticCounter uint64
	GetStaticMock          mActiveNodeMockGetStatic

	funcIsJoiner          func() (b1 bool)
	inspectFuncIsJoiner   func()
	afterIsJoinerCounter  uint64
	beforeIsJoinerCounter uint64
	IsJoinerMock          mActiveNodeMockIsJoiner
}

// NewActiveNodeMock returns a mock for ActiveNode
func NewActiveNodeMock(t minimock.Tester) *ActiveNodeMock {
	m := &ActiveNodeMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetDeclaredPowerMock = mActiveNodeMockGetDeclaredPower{mock: m}

	m.GetIndexMock = mActiveNodeMockGetIndex{mock: m}

	m.GetNodeIDMock = mActiveNodeMockGetNodeID{mock: m}

	m.GetOpModeMock = mActiveNodeMockGetOpMode{mock: m}

	m.GetSignatureVerifierMock = mActiveNodeMockGetSignatureVerifier{mock: m}

	m.GetStaticMock = mActiveNodeMockGetStatic{mock: m}

	m.IsJoinerMock = mActiveNodeMockIsJoiner{mock: m}

	return m
}

type mActiveNodeMockGetDeclaredPower struct {
	mock               *ActiveNodeMock
	defaultExpectation *ActiveNodeMockGetDeclaredPowerExpectation
	expectations       []*ActiveNodeMockGetDeclaredPowerExpectation
}

// ActiveNodeMockGetDeclaredPowerExpectation specifies expectation struct of the ActiveNode.GetDeclaredPower
type ActiveNodeMockGetDeclaredPowerExpectation struct {
	mock *ActiveNodeMock

	results *ActiveNodeMockGetDeclaredPowerResults
	Counter uint64
}

// ActiveNodeMockGetDeclaredPowerResults contains results of the ActiveNode.GetDeclaredPower
type ActiveNodeMockGetDeclaredPowerResults struct {
	p1 member.Power
}

// Expect sets up expected params for ActiveNode.GetDeclaredPower
func (mmGetDeclaredPower *mActiveNodeMockGetDeclaredPower) Expect() *mActiveNodeMockGetDeclaredPower {
	if mmGetDeclaredPower.mock.funcGetDeclaredPower != nil {
		mmGetDeclaredPower.mock.t.Fatalf("ActiveNodeMock.GetDeclaredPower mock is already set by Set")
	}

	if mmGetDeclaredPower.defaultExpectation == nil {
		mmGetDeclaredPower.defaultExpectation = &ActiveNodeMockGetDeclaredPowerExpectation{}
	}

	return mmGetDeclaredPower
}

// Inspect accepts an inspector function that has same arguments as the ActiveNode.GetDeclaredPower
func (mmGetDeclaredPower *mActiveNodeMockGetDeclaredPower) Inspect(f func()) *mActiveNodeMockGetDeclaredPower {
	if mmGetDeclaredPower.mock.inspectFuncGetDeclaredPower != nil {
		mmGetDeclaredPower.mock.t.Fatalf("Inspect function is already set for ActiveNodeMock.GetDeclaredPower")
	}

	mmGetDeclaredPower.mock.inspectFuncGetDeclaredPower = f

	return mmGetDeclaredPower
}

// Return sets up results that will be returned by ActiveNode.GetDeclaredPower
func (mmGetDeclaredPower *mActiveNodeMockGetDeclaredPower) Return(p1 member.Power) *ActiveNodeMock {
	if mmGetDeclaredPower.mock.funcGetDeclaredPower != nil {
		mmGetDeclaredPower.mock.t.Fatalf("ActiveNodeMock.GetDeclaredPower mock is already set by Set")
	}

	if mmGetDeclaredPower.defaultExpectation == nil {
		mmGetDeclaredPower.defaultExpectation = &ActiveNodeMockGetDeclaredPowerExpectation{mock: mmGetDeclaredPower.mock}
	}
	mmGetDeclaredPower.defaultExpectation.results = &ActiveNodeMockGetDeclaredPowerResults{p1}
	return mmGetDeclaredPower.mock
}

//Set uses given function f to mock the ActiveNode.GetDeclaredPower method
func (mmGetDeclaredPower *mActiveNodeMockGetDeclaredPower) Set(f func() (p1 member.Power)) *ActiveNodeMock {
	if mmGetDeclaredPower.defaultExpectation != nil {
		mmGetDeclaredPower.mock.t.Fatalf("Default expectation is already set for the ActiveNode.GetDeclaredPower method")
	}

	if len(mmGetDeclaredPower.expectations) > 0 {
		mmGetDeclaredPower.mock.t.Fatalf("Some expectations are already set for the ActiveNode.GetDeclaredPower method")
	}

	mmGetDeclaredPower.mock.funcGetDeclaredPower = f
	return mmGetDeclaredPower.mock
}

// GetDeclaredPower implements ActiveNode
func (mmGetDeclaredPower *ActiveNodeMock) GetDeclaredPower() (p1 member.Power) {
	mm_atomic.AddUint64(&mmGetDeclaredPower.beforeGetDeclaredPowerCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDeclaredPower.afterGetDeclaredPowerCounter, 1)

	if mmGetDeclaredPower.inspectFuncGetDeclaredPower != nil {
		mmGetDeclaredPower.inspectFuncGetDeclaredPower()
	}

	if mmGetDeclaredPower.GetDeclaredPowerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDeclaredPower.GetDeclaredPowerMock.defaultExpectation.Counter, 1)

		results := mmGetDeclaredPower.GetDeclaredPowerMock.defaultExpectation.results
		if results == nil {
			mmGetDeclaredPower.t.Fatal("No results are set for the ActiveNodeMock.GetDeclaredPower")
		}
		return (*results).p1
	}
	if mmGetDeclaredPower.funcGetDeclaredPower != nil {
		return mmGetDeclaredPower.funcGetDeclaredPower()
	}
	mmGetDeclaredPower.t.Fatalf("Unexpected call to ActiveNodeMock.GetDeclaredPower.")
	return
}

// GetDeclaredPowerAfterCounter returns a count of finished ActiveNodeMock.GetDeclaredPower invocations
func (mmGetDeclaredPower *ActiveNodeMock) GetDeclaredPowerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDeclaredPower.afterGetDeclaredPowerCounter)
}

// GetDeclaredPowerBeforeCounter returns a count of ActiveNodeMock.GetDeclaredPower invocations
func (mmGetDeclaredPower *ActiveNodeMock) GetDeclaredPowerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDeclaredPower.beforeGetDeclaredPowerCounter)
}

// MinimockGetDeclaredPowerDone returns true if the count of the GetDeclaredPower invocations corresponds
// the number of defined expectations
func (m *ActiveNodeMock) MinimockGetDeclaredPowerDone() bool {
	for _, e := range m.GetDeclaredPowerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDeclaredPowerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDeclaredPowerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDeclaredPower != nil && mm_atomic.LoadUint64(&m.afterGetDeclaredPowerCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDeclaredPowerInspect logs each unmet expectation
func (m *ActiveNodeMock) MinimockGetDeclaredPowerInspect() {
	for _, e := range m.GetDeclaredPowerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveNodeMock.GetDeclaredPower")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDeclaredPowerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDeclaredPowerCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.GetDeclaredPower")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDeclaredPower != nil && mm_atomic.LoadUint64(&m.afterGetDeclaredPowerCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.GetDeclaredPower")
	}
}

type mActiveNodeMockGetIndex struct {
	mock               *ActiveNodeMock
	defaultExpectation *ActiveNodeMockGetIndexExpectation
	expectations       []*ActiveNodeMockGetIndexExpectation
}

// ActiveNodeMockGetIndexExpectation specifies expectation struct of the ActiveNode.GetIndex
type ActiveNodeMockGetIndexExpectation struct {
	mock *ActiveNodeMock

	results *ActiveNodeMockGetIndexResults
	Counter uint64
}

// ActiveNodeMockGetIndexResults contains results of the ActiveNode.GetIndex
type ActiveNodeMockGetIndexResults struct {
	i1 member.Index
}

// Expect sets up expected params for ActiveNode.GetIndex
func (mmGetIndex *mActiveNodeMockGetIndex) Expect() *mActiveNodeMockGetIndex {
	if mmGetIndex.mock.funcGetIndex != nil {
		mmGetIndex.mock.t.Fatalf("ActiveNodeMock.GetIndex mock is already set by Set")
	}

	if mmGetIndex.defaultExpectation == nil {
		mmGetIndex.defaultExpectation = &ActiveNodeMockGetIndexExpectation{}
	}

	return mmGetIndex
}

// Inspect accepts an inspector function that has same arguments as the ActiveNode.GetIndex
func (mmGetIndex *mActiveNodeMockGetIndex) Inspect(f func()) *mActiveNodeMockGetIndex {
	if mmGetIndex.mock.inspectFuncGetIndex != nil {
		mmGetIndex.mock.t.Fatalf("Inspect function is already set for ActiveNodeMock.GetIndex")
	}

	mmGetIndex.mock.inspectFuncGetIndex = f

	return mmGetIndex
}

// Return sets up results that will be returned by ActiveNode.GetIndex
func (mmGetIndex *mActiveNodeMockGetIndex) Return(i1 member.Index) *ActiveNodeMock {
	if mmGetIndex.mock.funcGetIndex != nil {
		mmGetIndex.mock.t.Fatalf("ActiveNodeMock.GetIndex mock is already set by Set")
	}

	if mmGetIndex.defaultExpectation == nil {
		mmGetIndex.defaultExpectation = &ActiveNodeMockGetIndexExpectation{mock: mmGetIndex.mock}
	}
	mmGetIndex.defaultExpectation.results = &ActiveNodeMockGetIndexResults{i1}
	return mmGetIndex.mock
}

//Set uses given function f to mock the ActiveNode.GetIndex method
func (mmGetIndex *mActiveNodeMockGetIndex) Set(f func() (i1 member.Index)) *ActiveNodeMock {
	if mmGetIndex.defaultExpectation != nil {
		mmGetIndex.mock.t.Fatalf("Default expectation is already set for the ActiveNode.GetIndex method")
	}

	if len(mmGetIndex.expectations) > 0 {
		mmGetIndex.mock.t.Fatalf("Some expectations are already set for the ActiveNode.GetIndex method")
	}

	mmGetIndex.mock.funcGetIndex = f
	return mmGetIndex.mock
}

// GetIndex implements ActiveNode
func (mmGetIndex *ActiveNodeMock) GetIndex() (i1 member.Index) {
	mm_atomic.AddUint64(&mmGetIndex.beforeGetIndexCounter, 1)
	defer mm_atomic.AddUint64(&mmGetIndex.afterGetIndexCounter, 1)

	if mmGetIndex.inspectFuncGetIndex != nil {
		mmGetIndex.inspectFuncGetIndex()
	}

	if mmGetIndex.GetIndexMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetIndex.GetIndexMock.defaultExpectation.Counter, 1)

		results := mmGetIndex.GetIndexMock.defaultExpectation.results
		if results == nil {
			mmGetIndex.t.Fatal("No results are set for the ActiveNodeMock.GetIndex")
		}
		return (*results).i1
	}
	if mmGetIndex.funcGetIndex != nil {
		return mmGetIndex.funcGetIndex()
	}
	mmGetIndex.t.Fatalf("Unexpected call to ActiveNodeMock.GetIndex.")
	return
}

// GetIndexAfterCounter returns a count of finished ActiveNodeMock.GetIndex invocations
func (mmGetIndex *ActiveNodeMock) GetIndexAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetIndex.afterGetIndexCounter)
}

// GetIndexBeforeCounter returns a count of ActiveNodeMock.GetIndex invocations
func (mmGetIndex *ActiveNodeMock) GetIndexBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetIndex.beforeGetIndexCounter)
}

// MinimockGetIndexDone returns true if the count of the GetIndex invocations corresponds
// the number of defined expectations
func (m *ActiveNodeMock) MinimockGetIndexDone() bool {
	for _, e := range m.GetIndexMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetIndexMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetIndexCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetIndex != nil && mm_atomic.LoadUint64(&m.afterGetIndexCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetIndexInspect logs each unmet expectation
func (m *ActiveNodeMock) MinimockGetIndexInspect() {
	for _, e := range m.GetIndexMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveNodeMock.GetIndex")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetIndexMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetIndexCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.GetIndex")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetIndex != nil && mm_atomic.LoadUint64(&m.afterGetIndexCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.GetIndex")
	}
}

type mActiveNodeMockGetNodeID struct {
	mock               *ActiveNodeMock
	defaultExpectation *ActiveNodeMockGetNodeIDExpectation
	expectations       []*ActiveNodeMockGetNodeIDExpectation
}

// ActiveNodeMockGetNodeIDExpectation specifies expectation struct of the ActiveNode.GetNodeID
type ActiveNodeMockGetNodeIDExpectation struct {
	mock *ActiveNodeMock

	results *ActiveNodeMockGetNodeIDResults
	Counter uint64
}

// ActiveNodeMockGetNodeIDResults contains results of the ActiveNode.GetNodeID
type ActiveNodeMockGetNodeIDResults struct {
	s1 insolar.ShortNodeID
}

// Expect sets up expected params for ActiveNode.GetNodeID
func (mmGetNodeID *mActiveNodeMockGetNodeID) Expect() *mActiveNodeMockGetNodeID {
	if mmGetNodeID.mock.funcGetNodeID != nil {
		mmGetNodeID.mock.t.Fatalf("ActiveNodeMock.GetNodeID mock is already set by Set")
	}

	if mmGetNodeID.defaultExpectation == nil {
		mmGetNodeID.defaultExpectation = &ActiveNodeMockGetNodeIDExpectation{}
	}

	return mmGetNodeID
}

// Inspect accepts an inspector function that has same arguments as the ActiveNode.GetNodeID
func (mmGetNodeID *mActiveNodeMockGetNodeID) Inspect(f func()) *mActiveNodeMockGetNodeID {
	if mmGetNodeID.mock.inspectFuncGetNodeID != nil {
		mmGetNodeID.mock.t.Fatalf("Inspect function is already set for ActiveNodeMock.GetNodeID")
	}

	mmGetNodeID.mock.inspectFuncGetNodeID = f

	return mmGetNodeID
}

// Return sets up results that will be returned by ActiveNode.GetNodeID
func (mmGetNodeID *mActiveNodeMockGetNodeID) Return(s1 insolar.ShortNodeID) *ActiveNodeMock {
	if mmGetNodeID.mock.funcGetNodeID != nil {
		mmGetNodeID.mock.t.Fatalf("ActiveNodeMock.GetNodeID mock is already set by Set")
	}

	if mmGetNodeID.defaultExpectation == nil {
		mmGetNodeID.defaultExpectation = &ActiveNodeMockGetNodeIDExpectation{mock: mmGetNodeID.mock}
	}
	mmGetNodeID.defaultExpectation.results = &ActiveNodeMockGetNodeIDResults{s1}
	return mmGetNodeID.mock
}

//Set uses given function f to mock the ActiveNode.GetNodeID method
func (mmGetNodeID *mActiveNodeMockGetNodeID) Set(f func() (s1 insolar.ShortNodeID)) *ActiveNodeMock {
	if mmGetNodeID.defaultExpectation != nil {
		mmGetNodeID.mock.t.Fatalf("Default expectation is already set for the ActiveNode.GetNodeID method")
	}

	if len(mmGetNodeID.expectations) > 0 {
		mmGetNodeID.mock.t.Fatalf("Some expectations are already set for the ActiveNode.GetNodeID method")
	}

	mmGetNodeID.mock.funcGetNodeID = f
	return mmGetNodeID.mock
}

// GetNodeID implements ActiveNode
func (mmGetNodeID *ActiveNodeMock) GetNodeID() (s1 insolar.ShortNodeID) {
	mm_atomic.AddUint64(&mmGetNodeID.beforeGetNodeIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNodeID.afterGetNodeIDCounter, 1)

	if mmGetNodeID.inspectFuncGetNodeID != nil {
		mmGetNodeID.inspectFuncGetNodeID()
	}

	if mmGetNodeID.GetNodeIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNodeID.GetNodeIDMock.defaultExpectation.Counter, 1)

		results := mmGetNodeID.GetNodeIDMock.defaultExpectation.results
		if results == nil {
			mmGetNodeID.t.Fatal("No results are set for the ActiveNodeMock.GetNodeID")
		}
		return (*results).s1
	}
	if mmGetNodeID.funcGetNodeID != nil {
		return mmGetNodeID.funcGetNodeID()
	}
	mmGetNodeID.t.Fatalf("Unexpected call to ActiveNodeMock.GetNodeID.")
	return
}

// GetNodeIDAfterCounter returns a count of finished ActiveNodeMock.GetNodeID invocations
func (mmGetNodeID *ActiveNodeMock) GetNodeIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNodeID.afterGetNodeIDCounter)
}

// GetNodeIDBeforeCounter returns a count of ActiveNodeMock.GetNodeID invocations
func (mmGetNodeID *ActiveNodeMock) GetNodeIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNodeID.beforeGetNodeIDCounter)
}

// MinimockGetNodeIDDone returns true if the count of the GetNodeID invocations corresponds
// the number of defined expectations
func (m *ActiveNodeMock) MinimockGetNodeIDDone() bool {
	for _, e := range m.GetNodeIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetNodeIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetNodeIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNodeID != nil && mm_atomic.LoadUint64(&m.afterGetNodeIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetNodeIDInspect logs each unmet expectation
func (m *ActiveNodeMock) MinimockGetNodeIDInspect() {
	for _, e := range m.GetNodeIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveNodeMock.GetNodeID")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetNodeIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetNodeIDCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.GetNodeID")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNodeID != nil && mm_atomic.LoadUint64(&m.afterGetNodeIDCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.GetNodeID")
	}
}

type mActiveNodeMockGetOpMode struct {
	mock               *ActiveNodeMock
	defaultExpectation *ActiveNodeMockGetOpModeExpectation
	expectations       []*ActiveNodeMockGetOpModeExpectation
}

// ActiveNodeMockGetOpModeExpectation specifies expectation struct of the ActiveNode.GetOpMode
type ActiveNodeMockGetOpModeExpectation struct {
	mock *ActiveNodeMock

	results *ActiveNodeMockGetOpModeResults
	Counter uint64
}

// ActiveNodeMockGetOpModeResults contains results of the ActiveNode.GetOpMode
type ActiveNodeMockGetOpModeResults struct {
	o1 member.OpMode
}

// Expect sets up expected params for ActiveNode.GetOpMode
func (mmGetOpMode *mActiveNodeMockGetOpMode) Expect() *mActiveNodeMockGetOpMode {
	if mmGetOpMode.mock.funcGetOpMode != nil {
		mmGetOpMode.mock.t.Fatalf("ActiveNodeMock.GetOpMode mock is already set by Set")
	}

	if mmGetOpMode.defaultExpectation == nil {
		mmGetOpMode.defaultExpectation = &ActiveNodeMockGetOpModeExpectation{}
	}

	return mmGetOpMode
}

// Inspect accepts an inspector function that has same arguments as the ActiveNode.GetOpMode
func (mmGetOpMode *mActiveNodeMockGetOpMode) Inspect(f func()) *mActiveNodeMockGetOpMode {
	if mmGetOpMode.mock.inspectFuncGetOpMode != nil {
		mmGetOpMode.mock.t.Fatalf("Inspect function is already set for ActiveNodeMock.GetOpMode")
	}

	mmGetOpMode.mock.inspectFuncGetOpMode = f

	return mmGetOpMode
}

// Return sets up results that will be returned by ActiveNode.GetOpMode
func (mmGetOpMode *mActiveNodeMockGetOpMode) Return(o1 member.OpMode) *ActiveNodeMock {
	if mmGetOpMode.mock.funcGetOpMode != nil {
		mmGetOpMode.mock.t.Fatalf("ActiveNodeMock.GetOpMode mock is already set by Set")
	}

	if mmGetOpMode.defaultExpectation == nil {
		mmGetOpMode.defaultExpectation = &ActiveNodeMockGetOpModeExpectation{mock: mmGetOpMode.mock}
	}
	mmGetOpMode.defaultExpectation.results = &ActiveNodeMockGetOpModeResults{o1}
	return mmGetOpMode.mock
}

//Set uses given function f to mock the ActiveNode.GetOpMode method
func (mmGetOpMode *mActiveNodeMockGetOpMode) Set(f func() (o1 member.OpMode)) *ActiveNodeMock {
	if mmGetOpMode.defaultExpectation != nil {
		mmGetOpMode.mock.t.Fatalf("Default expectation is already set for the ActiveNode.GetOpMode method")
	}

	if len(mmGetOpMode.expectations) > 0 {
		mmGetOpMode.mock.t.Fatalf("Some expectations are already set for the ActiveNode.GetOpMode method")
	}

	mmGetOpMode.mock.funcGetOpMode = f
	return mmGetOpMode.mock
}

// GetOpMode implements ActiveNode
func (mmGetOpMode *ActiveNodeMock) GetOpMode() (o1 member.OpMode) {
	mm_atomic.AddUint64(&mmGetOpMode.beforeGetOpModeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOpMode.afterGetOpModeCounter, 1)

	if mmGetOpMode.inspectFuncGetOpMode != nil {
		mmGetOpMode.inspectFuncGetOpMode()
	}

	if mmGetOpMode.GetOpModeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOpMode.GetOpModeMock.defaultExpectation.Counter, 1)

		results := mmGetOpMode.GetOpModeMock.defaultExpectation.results
		if results == nil {
			mmGetOpMode.t.Fatal("No results are set for the ActiveNodeMock.GetOpMode")
		}
		return (*results).o1
	}
	if mmGetOpMode.funcGetOpMode != nil {
		return mmGetOpMode.funcGetOpMode()
	}
	mmGetOpMode.t.Fatalf("Unexpected call to ActiveNodeMock.GetOpMode.")
	return
}

// GetOpModeAfterCounter returns a count of finished ActiveNodeMock.GetOpMode invocations
func (mmGetOpMode *ActiveNodeMock) GetOpModeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOpMode.afterGetOpModeCounter)
}

// GetOpModeBeforeCounter returns a count of ActiveNodeMock.GetOpMode invocations
func (mmGetOpMode *ActiveNodeMock) GetOpModeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOpMode.beforeGetOpModeCounter)
}

// MinimockGetOpModeDone returns true if the count of the GetOpMode invocations corresponds
// the number of defined expectations
func (m *ActiveNodeMock) MinimockGetOpModeDone() bool {
	for _, e := range m.GetOpModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOpModeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOpModeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOpMode != nil && mm_atomic.LoadUint64(&m.afterGetOpModeCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetOpModeInspect logs each unmet expectation
func (m *ActiveNodeMock) MinimockGetOpModeInspect() {
	for _, e := range m.GetOpModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveNodeMock.GetOpMode")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOpModeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOpModeCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.GetOpMode")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOpMode != nil && mm_atomic.LoadUint64(&m.afterGetOpModeCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.GetOpMode")
	}
}

type mActiveNodeMockGetSignatureVerifier struct {
	mock               *ActiveNodeMock
	defaultExpectation *ActiveNodeMockGetSignatureVerifierExpectation
	expectations       []*ActiveNodeMockGetSignatureVerifierExpectation
}

// ActiveNodeMockGetSignatureVerifierExpectation specifies expectation struct of the ActiveNode.GetSignatureVerifier
type ActiveNodeMockGetSignatureVerifierExpectation struct {
	mock *ActiveNodeMock

	results *ActiveNodeMockGetSignatureVerifierResults
	Counter uint64
}

// ActiveNodeMockGetSignatureVerifierResults contains results of the ActiveNode.GetSignatureVerifier
type ActiveNodeMockGetSignatureVerifierResults struct {
	s1 cryptkit.SignatureVerifier
}

// Expect sets up expected params for ActiveNode.GetSignatureVerifier
func (mmGetSignatureVerifier *mActiveNodeMockGetSignatureVerifier) Expect() *mActiveNodeMockGetSignatureVerifier {
	if mmGetSignatureVerifier.mock.funcGetSignatureVerifier != nil {
		mmGetSignatureVerifier.mock.t.Fatalf("ActiveNodeMock.GetSignatureVerifier mock is already set by Set")
	}

	if mmGetSignatureVerifier.defaultExpectation == nil {
		mmGetSignatureVerifier.defaultExpectation = &ActiveNodeMockGetSignatureVerifierExpectation{}
	}

	return mmGetSignatureVerifier
}

// Inspect accepts an inspector function that has same arguments as the ActiveNode.GetSignatureVerifier
func (mmGetSignatureVerifier *mActiveNodeMockGetSignatureVerifier) Inspect(f func()) *mActiveNodeMockGetSignatureVerifier {
	if mmGetSignatureVerifier.mock.inspectFuncGetSignatureVerifier != nil {
		mmGetSignatureVerifier.mock.t.Fatalf("Inspect function is already set for ActiveNodeMock.GetSignatureVerifier")
	}

	mmGetSignatureVerifier.mock.inspectFuncGetSignatureVerifier = f

	return mmGetSignatureVerifier
}

// Return sets up results that will be returned by ActiveNode.GetSignatureVerifier
func (mmGetSignatureVerifier *mActiveNodeMockGetSignatureVerifier) Return(s1 cryptkit.SignatureVerifier) *ActiveNodeMock {
	if mmGetSignatureVerifier.mock.funcGetSignatureVerifier != nil {
		mmGetSignatureVerifier.mock.t.Fatalf("ActiveNodeMock.GetSignatureVerifier mock is already set by Set")
	}

	if mmGetSignatureVerifier.defaultExpectation == nil {
		mmGetSignatureVerifier.defaultExpectation = &ActiveNodeMockGetSignatureVerifierExpectation{mock: mmGetSignatureVerifier.mock}
	}
	mmGetSignatureVerifier.defaultExpectation.results = &ActiveNodeMockGetSignatureVerifierResults{s1}
	return mmGetSignatureVerifier.mock
}

//Set uses given function f to mock the ActiveNode.GetSignatureVerifier method
func (mmGetSignatureVerifier *mActiveNodeMockGetSignatureVerifier) Set(f func() (s1 cryptkit.SignatureVerifier)) *ActiveNodeMock {
	if mmGetSignatureVerifier.defaultExpectation != nil {
		mmGetSignatureVerifier.mock.t.Fatalf("Default expectation is already set for the ActiveNode.GetSignatureVerifier method")
	}

	if len(mmGetSignatureVerifier.expectations) > 0 {
		mmGetSignatureVerifier.mock.t.Fatalf("Some expectations are already set for the ActiveNode.GetSignatureVerifier method")
	}

	mmGetSignatureVerifier.mock.funcGetSignatureVerifier = f
	return mmGetSignatureVerifier.mock
}

// GetSignatureVerifier implements ActiveNode
func (mmGetSignatureVerifier *ActiveNodeMock) GetSignatureVerifier() (s1 cryptkit.SignatureVerifier) {
	mm_atomic.AddUint64(&mmGetSignatureVerifier.beforeGetSignatureVerifierCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSignatureVerifier.afterGetSignatureVerifierCounter, 1)

	if mmGetSignatureVerifier.inspectFuncGetSignatureVerifier != nil {
		mmGetSignatureVerifier.inspectFuncGetSignatureVerifier()
	}

	if mmGetSignatureVerifier.GetSignatureVerifierMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSignatureVerifier.GetSignatureVerifierMock.defaultExpectation.Counter, 1)

		results := mmGetSignatureVerifier.GetSignatureVerifierMock.defaultExpectation.results
		if results == nil {
			mmGetSignatureVerifier.t.Fatal("No results are set for the ActiveNodeMock.GetSignatureVerifier")
		}
		return (*results).s1
	}
	if mmGetSignatureVerifier.funcGetSignatureVerifier != nil {
		return mmGetSignatureVerifier.funcGetSignatureVerifier()
	}
	mmGetSignatureVerifier.t.Fatalf("Unexpected call to ActiveNodeMock.GetSignatureVerifier.")
	return
}

// GetSignatureVerifierAfterCounter returns a count of finished ActiveNodeMock.GetSignatureVerifier invocations
func (mmGetSignatureVerifier *ActiveNodeMock) GetSignatureVerifierAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignatureVerifier.afterGetSignatureVerifierCounter)
}

// GetSignatureVerifierBeforeCounter returns a count of ActiveNodeMock.GetSignatureVerifier invocations
func (mmGetSignatureVerifier *ActiveNodeMock) GetSignatureVerifierBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignatureVerifier.beforeGetSignatureVerifierCounter)
}

// MinimockGetSignatureVerifierDone returns true if the count of the GetSignatureVerifier invocations corresponds
// the number of defined expectations
func (m *ActiveNodeMock) MinimockGetSignatureVerifierDone() bool {
	for _, e := range m.GetSignatureVerifierMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureVerifierMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureVerifierCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignatureVerifier != nil && mm_atomic.LoadUint64(&m.afterGetSignatureVerifierCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSignatureVerifierInspect logs each unmet expectation
func (m *ActiveNodeMock) MinimockGetSignatureVerifierInspect() {
	for _, e := range m.GetSignatureVerifierMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveNodeMock.GetSignatureVerifier")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureVerifierMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureVerifierCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.GetSignatureVerifier")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignatureVerifier != nil && mm_atomic.LoadUint64(&m.afterGetSignatureVerifierCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.GetSignatureVerifier")
	}
}

type mActiveNodeMockGetStatic struct {
	mock               *ActiveNodeMock
	defaultExpectation *ActiveNodeMockGetStaticExpectation
	expectations       []*ActiveNodeMockGetStaticExpectation
}

// ActiveNodeMockGetStaticExpectation specifies expectation struct of the ActiveNode.GetStatic
type ActiveNodeMockGetStaticExpectation struct {
	mock *ActiveNodeMock

	results *ActiveNodeMockGetStaticResults
	Counter uint64
}

// ActiveNodeMockGetStaticResults contains results of the ActiveNode.GetStatic
type ActiveNodeMockGetStaticResults struct {
	s1 StaticProfile
}

// Expect sets up expected params for ActiveNode.GetStatic
func (mmGetStatic *mActiveNodeMockGetStatic) Expect() *mActiveNodeMockGetStatic {
	if mmGetStatic.mock.funcGetStatic != nil {
		mmGetStatic.mock.t.Fatalf("ActiveNodeMock.GetStatic mock is already set by Set")
	}

	if mmGetStatic.defaultExpectation == nil {
		mmGetStatic.defaultExpectation = &ActiveNodeMockGetStaticExpectation{}
	}

	return mmGetStatic
}

// Inspect accepts an inspector function that has same arguments as the ActiveNode.GetStatic
func (mmGetStatic *mActiveNodeMockGetStatic) Inspect(f func()) *mActiveNodeMockGetStatic {
	if mmGetStatic.mock.inspectFuncGetStatic != nil {
		mmGetStatic.mock.t.Fatalf("Inspect function is already set for ActiveNodeMock.GetStatic")
	}

	mmGetStatic.mock.inspectFuncGetStatic = f

	return mmGetStatic
}

// Return sets up results that will be returned by ActiveNode.GetStatic
func (mmGetStatic *mActiveNodeMockGetStatic) Return(s1 StaticProfile) *ActiveNodeMock {
	if mmGetStatic.mock.funcGetStatic != nil {
		mmGetStatic.mock.t.Fatalf("ActiveNodeMock.GetStatic mock is already set by Set")
	}

	if mmGetStatic.defaultExpectation == nil {
		mmGetStatic.defaultExpectation = &ActiveNodeMockGetStaticExpectation{mock: mmGetStatic.mock}
	}
	mmGetStatic.defaultExpectation.results = &ActiveNodeMockGetStaticResults{s1}
	return mmGetStatic.mock
}

//Set uses given function f to mock the ActiveNode.GetStatic method
func (mmGetStatic *mActiveNodeMockGetStatic) Set(f func() (s1 StaticProfile)) *ActiveNodeMock {
	if mmGetStatic.defaultExpectation != nil {
		mmGetStatic.mock.t.Fatalf("Default expectation is already set for the ActiveNode.GetStatic method")
	}

	if len(mmGetStatic.expectations) > 0 {
		mmGetStatic.mock.t.Fatalf("Some expectations are already set for the ActiveNode.GetStatic method")
	}

	mmGetStatic.mock.funcGetStatic = f
	return mmGetStatic.mock
}

// GetStatic implements ActiveNode
func (mmGetStatic *ActiveNodeMock) GetStatic() (s1 StaticProfile) {
	mm_atomic.AddUint64(&mmGetStatic.beforeGetStaticCounter, 1)
	defer mm_atomic.AddUint64(&mmGetStatic.afterGetStaticCounter, 1)

	if mmGetStatic.inspectFuncGetStatic != nil {
		mmGetStatic.inspectFuncGetStatic()
	}

	if mmGetStatic.GetStaticMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetStatic.GetStaticMock.defaultExpectation.Counter, 1)

		results := mmGetStatic.GetStaticMock.defaultExpectation.results
		if results == nil {
			mmGetStatic.t.Fatal("No results are set for the ActiveNodeMock.GetStatic")
		}
		return (*results).s1
	}
	if mmGetStatic.funcGetStatic != nil {
		return mmGetStatic.funcGetStatic()
	}
	mmGetStatic.t.Fatalf("Unexpected call to ActiveNodeMock.GetStatic.")
	return
}

// GetStaticAfterCounter returns a count of finished ActiveNodeMock.GetStatic invocations
func (mmGetStatic *ActiveNodeMock) GetStaticAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStatic.afterGetStaticCounter)
}

// GetStaticBeforeCounter returns a count of ActiveNodeMock.GetStatic invocations
func (mmGetStatic *ActiveNodeMock) GetStaticBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStatic.beforeGetStaticCounter)
}

// MinimockGetStaticDone returns true if the count of the GetStatic invocations corresponds
// the number of defined expectations
func (m *ActiveNodeMock) MinimockGetStaticDone() bool {
	for _, e := range m.GetStaticMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetStaticMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetStaticCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStatic != nil && mm_atomic.LoadUint64(&m.afterGetStaticCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetStaticInspect logs each unmet expectation
func (m *ActiveNodeMock) MinimockGetStaticInspect() {
	for _, e := range m.GetStaticMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveNodeMock.GetStatic")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetStaticMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetStaticCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.GetStatic")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStatic != nil && mm_atomic.LoadUint64(&m.afterGetStaticCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.GetStatic")
	}
}

type mActiveNodeMockIsJoiner struct {
	mock               *ActiveNodeMock
	defaultExpectation *ActiveNodeMockIsJoinerExpectation
	expectations       []*ActiveNodeMockIsJoinerExpectation
}

// ActiveNodeMockIsJoinerExpectation specifies expectation struct of the ActiveNode.IsJoiner
type ActiveNodeMockIsJoinerExpectation struct {
	mock *ActiveNodeMock

	results *ActiveNodeMockIsJoinerResults
	Counter uint64
}

// ActiveNodeMockIsJoinerResults contains results of the ActiveNode.IsJoiner
type ActiveNodeMockIsJoinerResults struct {
	b1 bool
}

// Expect sets up expected params for ActiveNode.IsJoiner
func (mmIsJoiner *mActiveNodeMockIsJoiner) Expect() *mActiveNodeMockIsJoiner {
	if mmIsJoiner.mock.funcIsJoiner != nil {
		mmIsJoiner.mock.t.Fatalf("ActiveNodeMock.IsJoiner mock is already set by Set")
	}

	if mmIsJoiner.defaultExpectation == nil {
		mmIsJoiner.defaultExpectation = &ActiveNodeMockIsJoinerExpectation{}
	}

	return mmIsJoiner
}

// Inspect accepts an inspector function that has same arguments as the ActiveNode.IsJoiner
func (mmIsJoiner *mActiveNodeMockIsJoiner) Inspect(f func()) *mActiveNodeMockIsJoiner {
	if mmIsJoiner.mock.inspectFuncIsJoiner != nil {
		mmIsJoiner.mock.t.Fatalf("Inspect function is already set for ActiveNodeMock.IsJoiner")
	}

	mmIsJoiner.mock.inspectFuncIsJoiner = f

	return mmIsJoiner
}

// Return sets up results that will be returned by ActiveNode.IsJoiner
func (mmIsJoiner *mActiveNodeMockIsJoiner) Return(b1 bool) *ActiveNodeMock {
	if mmIsJoiner.mock.funcIsJoiner != nil {
		mmIsJoiner.mock.t.Fatalf("ActiveNodeMock.IsJoiner mock is already set by Set")
	}

	if mmIsJoiner.defaultExpectation == nil {
		mmIsJoiner.defaultExpectation = &ActiveNodeMockIsJoinerExpectation{mock: mmIsJoiner.mock}
	}
	mmIsJoiner.defaultExpectation.results = &ActiveNodeMockIsJoinerResults{b1}
	return mmIsJoiner.mock
}

//Set uses given function f to mock the ActiveNode.IsJoiner method
func (mmIsJoiner *mActiveNodeMockIsJoiner) Set(f func() (b1 bool)) *ActiveNodeMock {
	if mmIsJoiner.defaultExpectation != nil {
		mmIsJoiner.mock.t.Fatalf("Default expectation is already set for the ActiveNode.IsJoiner method")
	}

	if len(mmIsJoiner.expectations) > 0 {
		mmIsJoiner.mock.t.Fatalf("Some expectations are already set for the ActiveNode.IsJoiner method")
	}

	mmIsJoiner.mock.funcIsJoiner = f
	return mmIsJoiner.mock
}

// IsJoiner implements ActiveNode
func (mmIsJoiner *ActiveNodeMock) IsJoiner() (b1 bool) {
	mm_atomic.AddUint64(&mmIsJoiner.beforeIsJoinerCounter, 1)
	defer mm_atomic.AddUint64(&mmIsJoiner.afterIsJoinerCounter, 1)

	if mmIsJoiner.inspectFuncIsJoiner != nil {
		mmIsJoiner.inspectFuncIsJoiner()
	}

	if mmIsJoiner.IsJoinerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsJoiner.IsJoinerMock.defaultExpectation.Counter, 1)

		results := mmIsJoiner.IsJoinerMock.defaultExpectation.results
		if results == nil {
			mmIsJoiner.t.Fatal("No results are set for the ActiveNodeMock.IsJoiner")
		}
		return (*results).b1
	}
	if mmIsJoiner.funcIsJoiner != nil {
		return mmIsJoiner.funcIsJoiner()
	}
	mmIsJoiner.t.Fatalf("Unexpected call to ActiveNodeMock.IsJoiner.")
	return
}

// IsJoinerAfterCounter returns a count of finished ActiveNodeMock.IsJoiner invocations
func (mmIsJoiner *ActiveNodeMock) IsJoinerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsJoiner.afterIsJoinerCounter)
}

// IsJoinerBeforeCounter returns a count of ActiveNodeMock.IsJoiner invocations
func (mmIsJoiner *ActiveNodeMock) IsJoinerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsJoiner.beforeIsJoinerCounter)
}

// MinimockIsJoinerDone returns true if the count of the IsJoiner invocations corresponds
// the number of defined expectations
func (m *ActiveNodeMock) MinimockIsJoinerDone() bool {
	for _, e := range m.IsJoinerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsJoinerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsJoinerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsJoiner != nil && mm_atomic.LoadUint64(&m.afterIsJoinerCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsJoinerInspect logs each unmet expectation
func (m *ActiveNodeMock) MinimockIsJoinerInspect() {
	for _, e := range m.IsJoinerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveNodeMock.IsJoiner")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsJoinerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsJoinerCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.IsJoiner")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsJoiner != nil && mm_atomic.LoadUint64(&m.afterIsJoinerCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.IsJoiner")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ActiveNodeMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetDeclaredPowerInspect()

		m.MinimockGetIndexInspect()

		m.MinimockGetNodeIDInspect()

		m.MinimockGetOpModeInspect()

		m.MinimockGetSignatureVerifierInspect()

		m.MinimockGetStaticInspect()

		m.MinimockIsJoinerInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ActiveNodeMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ActiveNodeMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetDeclaredPowerDone() &&
		m.MinimockGetIndexDone() &&
		m.MinimockGetNodeIDDone() &&
		m.MinimockGetOpModeDone() &&
		m.MinimockGetSignatureVerifierDone() &&
		m.MinimockGetStaticDone() &&
		m.MinimockIsJoinerDone()
}
