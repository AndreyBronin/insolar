package jet

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
)

// TreeManagerMock implements TreeManager
type TreeManagerMock struct {
	t minimock.Tester

	funcFind          func(i1 insolar.ID) (j1 insolar.JetID, b1 bool)
	inspectFuncFind   func(i1 insolar.ID)
	afterFindCounter  uint64
	beforeFindCounter uint64
	FindMock          mTreeManagerMockFind

	funcUpdate          func(j1 insolar.JetID, b1 bool)
	inspectFuncUpdate   func(j1 insolar.JetID, b1 bool)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mTreeManagerMockUpdate
}

// NewTreeManagerMock returns a mock for TreeManager
func NewTreeManagerMock(t minimock.Tester) *TreeManagerMock {
	m := &TreeManagerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.FindMock = mTreeManagerMockFind{mock: m}
	m.FindMock.callArgs = []*TreeManagerMockFindParams{}

	m.UpdateMock = mTreeManagerMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*TreeManagerMockUpdateParams{}

	return m
}

type mTreeManagerMockFind struct {
	mock               *TreeManagerMock
	defaultExpectation *TreeManagerMockFindExpectation
	expectations       []*TreeManagerMockFindExpectation

	callArgs []*TreeManagerMockFindParams
	mutex    sync.RWMutex
}

// TreeManagerMockFindExpectation specifies expectation struct of the TreeManager.Find
type TreeManagerMockFindExpectation struct {
	mock    *TreeManagerMock
	params  *TreeManagerMockFindParams
	results *TreeManagerMockFindResults
	Counter uint64
}

// TreeManagerMockFindParams contains parameters of the TreeManager.Find
type TreeManagerMockFindParams struct {
	i1 insolar.ID
}

// TreeManagerMockFindResults contains results of the TreeManager.Find
type TreeManagerMockFindResults struct {
	j1 insolar.JetID
	b1 bool
}

// Expect sets up expected params for TreeManager.Find
func (mmFind *mTreeManagerMockFind) Expect(i1 insolar.ID) *mTreeManagerMockFind {
	if mmFind.mock.funcFind != nil {
		mmFind.mock.t.Fatalf("TreeManagerMock.Find mock is already set by Set")
	}

	if mmFind.defaultExpectation == nil {
		mmFind.defaultExpectation = &TreeManagerMockFindExpectation{}
	}

	mmFind.defaultExpectation.params = &TreeManagerMockFindParams{i1}
	for _, e := range mmFind.expectations {
		if minimock.Equal(e.params, mmFind.defaultExpectation.params) {
			mmFind.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFind.defaultExpectation.params)
		}
	}

	return mmFind
}

// Inspect accepts an inspector function that has same arguments as the TreeManager.Find
func (mmFind *mTreeManagerMockFind) Inspect(f func(i1 insolar.ID)) *mTreeManagerMockFind {
	if mmFind.mock.inspectFuncFind != nil {
		mmFind.mock.t.Fatalf("Inspect function is already set for TreeManagerMock.Find")
	}

	mmFind.mock.inspectFuncFind = f

	return mmFind
}

// Return sets up results that will be returned by TreeManager.Find
func (mmFind *mTreeManagerMockFind) Return(j1 insolar.JetID, b1 bool) *TreeManagerMock {
	if mmFind.mock.funcFind != nil {
		mmFind.mock.t.Fatalf("TreeManagerMock.Find mock is already set by Set")
	}

	if mmFind.defaultExpectation == nil {
		mmFind.defaultExpectation = &TreeManagerMockFindExpectation{mock: mmFind.mock}
	}
	mmFind.defaultExpectation.results = &TreeManagerMockFindResults{j1, b1}
	return mmFind.mock
}

//Set uses given function f to mock the TreeManager.Find method
func (mmFind *mTreeManagerMockFind) Set(f func(i1 insolar.ID) (j1 insolar.JetID, b1 bool)) *TreeManagerMock {
	if mmFind.defaultExpectation != nil {
		mmFind.mock.t.Fatalf("Default expectation is already set for the TreeManager.Find method")
	}

	if len(mmFind.expectations) > 0 {
		mmFind.mock.t.Fatalf("Some expectations are already set for the TreeManager.Find method")
	}

	mmFind.mock.funcFind = f
	return mmFind.mock
}

// When sets expectation for the TreeManager.Find which will trigger the result defined by the following
// Then helper
func (mmFind *mTreeManagerMockFind) When(i1 insolar.ID) *TreeManagerMockFindExpectation {
	if mmFind.mock.funcFind != nil {
		mmFind.mock.t.Fatalf("TreeManagerMock.Find mock is already set by Set")
	}

	expectation := &TreeManagerMockFindExpectation{
		mock:   mmFind.mock,
		params: &TreeManagerMockFindParams{i1},
	}
	mmFind.expectations = append(mmFind.expectations, expectation)
	return expectation
}

// Then sets up TreeManager.Find return parameters for the expectation previously defined by the When method
func (e *TreeManagerMockFindExpectation) Then(j1 insolar.JetID, b1 bool) *TreeManagerMock {
	e.results = &TreeManagerMockFindResults{j1, b1}
	return e.mock
}

// Find implements TreeManager
func (mmFind *TreeManagerMock) Find(i1 insolar.ID) (j1 insolar.JetID, b1 bool) {
	mm_atomic.AddUint64(&mmFind.beforeFindCounter, 1)
	defer mm_atomic.AddUint64(&mmFind.afterFindCounter, 1)

	if mmFind.inspectFuncFind != nil {
		mmFind.inspectFuncFind(i1)
	}

	params := &TreeManagerMockFindParams{i1}

	// Record call args
	mmFind.FindMock.mutex.Lock()
	mmFind.FindMock.callArgs = append(mmFind.FindMock.callArgs, params)
	mmFind.FindMock.mutex.Unlock()

	for _, e := range mmFind.FindMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.j1, e.results.b1
		}
	}

	if mmFind.FindMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFind.FindMock.defaultExpectation.Counter, 1)
		want := mmFind.FindMock.defaultExpectation.params
		got := TreeManagerMockFindParams{i1}
		if want != nil && !minimock.Equal(*want, got) {
			mmFind.t.Errorf("TreeManagerMock.Find got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmFind.FindMock.defaultExpectation.results
		if results == nil {
			mmFind.t.Fatal("No results are set for the TreeManagerMock.Find")
		}
		return (*results).j1, (*results).b1
	}
	if mmFind.funcFind != nil {
		return mmFind.funcFind(i1)
	}
	mmFind.t.Fatalf("Unexpected call to TreeManagerMock.Find. %v", i1)
	return
}

// FindAfterCounter returns a count of finished TreeManagerMock.Find invocations
func (mmFind *TreeManagerMock) FindAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFind.afterFindCounter)
}

// FindBeforeCounter returns a count of TreeManagerMock.Find invocations
func (mmFind *TreeManagerMock) FindBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFind.beforeFindCounter)
}

// Calls returns a list of arguments used in each call to TreeManagerMock.Find.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFind *mTreeManagerMockFind) Calls() []*TreeManagerMockFindParams {
	mmFind.mutex.RLock()

	argCopy := make([]*TreeManagerMockFindParams, len(mmFind.callArgs))
	copy(argCopy, mmFind.callArgs)

	mmFind.mutex.RUnlock()

	return argCopy
}

// MinimockFindDone returns true if the count of the Find invocations corresponds
// the number of defined expectations
func (m *TreeManagerMock) MinimockFindDone() bool {
	for _, e := range m.FindMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FindMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFindCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFind != nil && mm_atomic.LoadUint64(&m.afterFindCounter) < 1 {
		return false
	}
	return true
}

// MinimockFindInspect logs each unmet expectation
func (m *TreeManagerMock) MinimockFindInspect() {
	for _, e := range m.FindMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TreeManagerMock.Find with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FindMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFindCounter) < 1 {
		if m.FindMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TreeManagerMock.Find")
		} else {
			m.t.Errorf("Expected call to TreeManagerMock.Find with params: %#v", *m.FindMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFind != nil && mm_atomic.LoadUint64(&m.afterFindCounter) < 1 {
		m.t.Error("Expected call to TreeManagerMock.Find")
	}
}

type mTreeManagerMockUpdate struct {
	mock               *TreeManagerMock
	defaultExpectation *TreeManagerMockUpdateExpectation
	expectations       []*TreeManagerMockUpdateExpectation

	callArgs []*TreeManagerMockUpdateParams
	mutex    sync.RWMutex
}

// TreeManagerMockUpdateExpectation specifies expectation struct of the TreeManager.Update
type TreeManagerMockUpdateExpectation struct {
	mock   *TreeManagerMock
	params *TreeManagerMockUpdateParams

	Counter uint64
}

// TreeManagerMockUpdateParams contains parameters of the TreeManager.Update
type TreeManagerMockUpdateParams struct {
	j1 insolar.JetID
	b1 bool
}

// Expect sets up expected params for TreeManager.Update
func (mmUpdate *mTreeManagerMockUpdate) Expect(j1 insolar.JetID, b1 bool) *mTreeManagerMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("TreeManagerMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &TreeManagerMockUpdateExpectation{}
	}

	mmUpdate.defaultExpectation.params = &TreeManagerMockUpdateParams{j1, b1}
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the TreeManager.Update
func (mmUpdate *mTreeManagerMockUpdate) Inspect(f func(j1 insolar.JetID, b1 bool)) *mTreeManagerMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for TreeManagerMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by TreeManager.Update
func (mmUpdate *mTreeManagerMockUpdate) Return() *TreeManagerMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("TreeManagerMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &TreeManagerMockUpdateExpectation{mock: mmUpdate.mock}
	}

	return mmUpdate.mock
}

//Set uses given function f to mock the TreeManager.Update method
func (mmUpdate *mTreeManagerMockUpdate) Set(f func(j1 insolar.JetID, b1 bool)) *TreeManagerMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the TreeManager.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the TreeManager.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	return mmUpdate.mock
}

// Update implements TreeManager
func (mmUpdate *TreeManagerMock) Update(j1 insolar.JetID, b1 bool) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(j1, b1)
	}

	params := &TreeManagerMockUpdateParams{j1, b1}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		want := mmUpdate.UpdateMock.defaultExpectation.params
		got := TreeManagerMockUpdateParams{j1, b1}
		if want != nil && !minimock.Equal(*want, got) {
			mmUpdate.t.Errorf("TreeManagerMock.Update got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmUpdate.funcUpdate != nil {
		mmUpdate.funcUpdate(j1, b1)
		return
	}
	mmUpdate.t.Fatalf("Unexpected call to TreeManagerMock.Update. %v %v", j1, b1)

}

// UpdateAfterCounter returns a count of finished TreeManagerMock.Update invocations
func (mmUpdate *TreeManagerMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of TreeManagerMock.Update invocations
func (mmUpdate *TreeManagerMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to TreeManagerMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mTreeManagerMockUpdate) Calls() []*TreeManagerMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*TreeManagerMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *TreeManagerMock) MinimockUpdateDone() bool {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateInspect logs each unmet expectation
func (m *TreeManagerMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TreeManagerMock.Update with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TreeManagerMock.Update")
		} else {
			m.t.Errorf("Expected call to TreeManagerMock.Update with params: %#v", *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		m.t.Error("Expected call to TreeManagerMock.Update")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TreeManagerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockFindInspect()

		m.MinimockUpdateInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TreeManagerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TreeManagerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockFindDone() &&
		m.MinimockUpdateDone()
}
