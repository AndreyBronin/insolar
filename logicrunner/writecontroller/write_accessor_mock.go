package writecontroller

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
)

// WriteAccessorMock implements WriteAccessor
type WriteAccessorMock struct {
	t minimock.Tester

	funcBegin          func(ctx context.Context, p1 insolar.PulseNumber) (done func(), err error)
	inspectFuncBegin   func(ctx context.Context, p1 insolar.PulseNumber)
	afterBeginCounter  uint64
	beforeBeginCounter uint64
	BeginMock          mWriteAccessorMockBegin

	funcWaitOpened          func(ctx context.Context)
	inspectFuncWaitOpened   func(ctx context.Context)
	afterWaitOpenedCounter  uint64
	beforeWaitOpenedCounter uint64
	WaitOpenedMock          mWriteAccessorMockWaitOpened
}

// NewWriteAccessorMock returns a mock for WriteAccessor
func NewWriteAccessorMock(t minimock.Tester) *WriteAccessorMock {
	m := &WriteAccessorMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BeginMock = mWriteAccessorMockBegin{mock: m}
	m.BeginMock.callArgs = []*WriteAccessorMockBeginParams{}

	m.WaitOpenedMock = mWriteAccessorMockWaitOpened{mock: m}
	m.WaitOpenedMock.callArgs = []*WriteAccessorMockWaitOpenedParams{}

	return m
}

type mWriteAccessorMockBegin struct {
	mock               *WriteAccessorMock
	defaultExpectation *WriteAccessorMockBeginExpectation
	expectations       []*WriteAccessorMockBeginExpectation

	callArgs []*WriteAccessorMockBeginParams
	mutex    sync.RWMutex
}

// WriteAccessorMockBeginExpectation specifies expectation struct of the WriteAccessor.Begin
type WriteAccessorMockBeginExpectation struct {
	mock    *WriteAccessorMock
	params  *WriteAccessorMockBeginParams
	results *WriteAccessorMockBeginResults
	Counter uint64
}

// WriteAccessorMockBeginParams contains parameters of the WriteAccessor.Begin
type WriteAccessorMockBeginParams struct {
	ctx context.Context
	p1  insolar.PulseNumber
}

// WriteAccessorMockBeginResults contains results of the WriteAccessor.Begin
type WriteAccessorMockBeginResults struct {
	done func()
	err  error
}

// Expect sets up expected params for WriteAccessor.Begin
func (mmBegin *mWriteAccessorMockBegin) Expect(ctx context.Context, p1 insolar.PulseNumber) *mWriteAccessorMockBegin {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("WriteAccessorMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &WriteAccessorMockBeginExpectation{}
	}

	mmBegin.defaultExpectation.params = &WriteAccessorMockBeginParams{ctx, p1}
	for _, e := range mmBegin.expectations {
		if minimock.Equal(e.params, mmBegin.defaultExpectation.params) {
			mmBegin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBegin.defaultExpectation.params)
		}
	}

	return mmBegin
}

// Inspect accepts an inspector function that has same arguments as the WriteAccessor.Begin
func (mmBegin *mWriteAccessorMockBegin) Inspect(f func(ctx context.Context, p1 insolar.PulseNumber)) *mWriteAccessorMockBegin {
	if mmBegin.mock.inspectFuncBegin != nil {
		mmBegin.mock.t.Fatalf("Inspect function is already set for WriteAccessorMock.Begin")
	}

	mmBegin.mock.inspectFuncBegin = f

	return mmBegin
}

// Return sets up results that will be returned by WriteAccessor.Begin
func (mmBegin *mWriteAccessorMockBegin) Return(done func(), err error) *WriteAccessorMock {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("WriteAccessorMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &WriteAccessorMockBeginExpectation{mock: mmBegin.mock}
	}
	mmBegin.defaultExpectation.results = &WriteAccessorMockBeginResults{done, err}
	return mmBegin.mock
}

//Set uses given function f to mock the WriteAccessor.Begin method
func (mmBegin *mWriteAccessorMockBegin) Set(f func(ctx context.Context, p1 insolar.PulseNumber) (done func(), err error)) *WriteAccessorMock {
	if mmBegin.defaultExpectation != nil {
		mmBegin.mock.t.Fatalf("Default expectation is already set for the WriteAccessor.Begin method")
	}

	if len(mmBegin.expectations) > 0 {
		mmBegin.mock.t.Fatalf("Some expectations are already set for the WriteAccessor.Begin method")
	}

	mmBegin.mock.funcBegin = f
	return mmBegin.mock
}

// When sets expectation for the WriteAccessor.Begin which will trigger the result defined by the following
// Then helper
func (mmBegin *mWriteAccessorMockBegin) When(ctx context.Context, p1 insolar.PulseNumber) *WriteAccessorMockBeginExpectation {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("WriteAccessorMock.Begin mock is already set by Set")
	}

	expectation := &WriteAccessorMockBeginExpectation{
		mock:   mmBegin.mock,
		params: &WriteAccessorMockBeginParams{ctx, p1},
	}
	mmBegin.expectations = append(mmBegin.expectations, expectation)
	return expectation
}

// Then sets up WriteAccessor.Begin return parameters for the expectation previously defined by the When method
func (e *WriteAccessorMockBeginExpectation) Then(done func(), err error) *WriteAccessorMock {
	e.results = &WriteAccessorMockBeginResults{done, err}
	return e.mock
}

// Begin implements WriteAccessor
func (mmBegin *WriteAccessorMock) Begin(ctx context.Context, p1 insolar.PulseNumber) (done func(), err error) {
	mm_atomic.AddUint64(&mmBegin.beforeBeginCounter, 1)
	defer mm_atomic.AddUint64(&mmBegin.afterBeginCounter, 1)

	if mmBegin.inspectFuncBegin != nil {
		mmBegin.inspectFuncBegin(ctx, p1)
	}

	params := &WriteAccessorMockBeginParams{ctx, p1}

	// Record call args
	mmBegin.BeginMock.mutex.Lock()
	mmBegin.BeginMock.callArgs = append(mmBegin.BeginMock.callArgs, params)
	mmBegin.BeginMock.mutex.Unlock()

	for _, e := range mmBegin.BeginMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.done, e.results.err
		}
	}

	if mmBegin.BeginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBegin.BeginMock.defaultExpectation.Counter, 1)
		want := mmBegin.BeginMock.defaultExpectation.params
		got := WriteAccessorMockBeginParams{ctx, p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmBegin.t.Errorf("WriteAccessorMock.Begin got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmBegin.BeginMock.defaultExpectation.results
		if results == nil {
			mmBegin.t.Fatal("No results are set for the WriteAccessorMock.Begin")
		}
		return (*results).done, (*results).err
	}
	if mmBegin.funcBegin != nil {
		return mmBegin.funcBegin(ctx, p1)
	}
	mmBegin.t.Fatalf("Unexpected call to WriteAccessorMock.Begin. %v %v", ctx, p1)
	return
}

// BeginAfterCounter returns a count of finished WriteAccessorMock.Begin invocations
func (mmBegin *WriteAccessorMock) BeginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBegin.afterBeginCounter)
}

// BeginBeforeCounter returns a count of WriteAccessorMock.Begin invocations
func (mmBegin *WriteAccessorMock) BeginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBegin.beforeBeginCounter)
}

// Calls returns a list of arguments used in each call to WriteAccessorMock.Begin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBegin *mWriteAccessorMockBegin) Calls() []*WriteAccessorMockBeginParams {
	mmBegin.mutex.RLock()

	argCopy := make([]*WriteAccessorMockBeginParams, len(mmBegin.callArgs))
	copy(argCopy, mmBegin.callArgs)

	mmBegin.mutex.RUnlock()

	return argCopy
}

// MinimockBeginDone returns true if the count of the Begin invocations corresponds
// the number of defined expectations
func (m *WriteAccessorMock) MinimockBeginDone() bool {
	for _, e := range m.BeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeginMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBegin != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		return false
	}
	return true
}

// MinimockBeginInspect logs each unmet expectation
func (m *WriteAccessorMock) MinimockBeginInspect() {
	for _, e := range m.BeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to WriteAccessorMock.Begin with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeginMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		if m.BeginMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to WriteAccessorMock.Begin")
		} else {
			m.t.Errorf("Expected call to WriteAccessorMock.Begin with params: %#v", *m.BeginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBegin != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		m.t.Error("Expected call to WriteAccessorMock.Begin")
	}
}

type mWriteAccessorMockWaitOpened struct {
	mock               *WriteAccessorMock
	defaultExpectation *WriteAccessorMockWaitOpenedExpectation
	expectations       []*WriteAccessorMockWaitOpenedExpectation

	callArgs []*WriteAccessorMockWaitOpenedParams
	mutex    sync.RWMutex
}

// WriteAccessorMockWaitOpenedExpectation specifies expectation struct of the WriteAccessor.WaitOpened
type WriteAccessorMockWaitOpenedExpectation struct {
	mock   *WriteAccessorMock
	params *WriteAccessorMockWaitOpenedParams

	Counter uint64
}

// WriteAccessorMockWaitOpenedParams contains parameters of the WriteAccessor.WaitOpened
type WriteAccessorMockWaitOpenedParams struct {
	ctx context.Context
}

// Expect sets up expected params for WriteAccessor.WaitOpened
func (mmWaitOpened *mWriteAccessorMockWaitOpened) Expect(ctx context.Context) *mWriteAccessorMockWaitOpened {
	if mmWaitOpened.mock.funcWaitOpened != nil {
		mmWaitOpened.mock.t.Fatalf("WriteAccessorMock.WaitOpened mock is already set by Set")
	}

	if mmWaitOpened.defaultExpectation == nil {
		mmWaitOpened.defaultExpectation = &WriteAccessorMockWaitOpenedExpectation{}
	}

	mmWaitOpened.defaultExpectation.params = &WriteAccessorMockWaitOpenedParams{ctx}
	for _, e := range mmWaitOpened.expectations {
		if minimock.Equal(e.params, mmWaitOpened.defaultExpectation.params) {
			mmWaitOpened.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWaitOpened.defaultExpectation.params)
		}
	}

	return mmWaitOpened
}

// Inspect accepts an inspector function that has same arguments as the WriteAccessor.WaitOpened
func (mmWaitOpened *mWriteAccessorMockWaitOpened) Inspect(f func(ctx context.Context)) *mWriteAccessorMockWaitOpened {
	if mmWaitOpened.mock.inspectFuncWaitOpened != nil {
		mmWaitOpened.mock.t.Fatalf("Inspect function is already set for WriteAccessorMock.WaitOpened")
	}

	mmWaitOpened.mock.inspectFuncWaitOpened = f

	return mmWaitOpened
}

// Return sets up results that will be returned by WriteAccessor.WaitOpened
func (mmWaitOpened *mWriteAccessorMockWaitOpened) Return() *WriteAccessorMock {
	if mmWaitOpened.mock.funcWaitOpened != nil {
		mmWaitOpened.mock.t.Fatalf("WriteAccessorMock.WaitOpened mock is already set by Set")
	}

	if mmWaitOpened.defaultExpectation == nil {
		mmWaitOpened.defaultExpectation = &WriteAccessorMockWaitOpenedExpectation{mock: mmWaitOpened.mock}
	}

	return mmWaitOpened.mock
}

//Set uses given function f to mock the WriteAccessor.WaitOpened method
func (mmWaitOpened *mWriteAccessorMockWaitOpened) Set(f func(ctx context.Context)) *WriteAccessorMock {
	if mmWaitOpened.defaultExpectation != nil {
		mmWaitOpened.mock.t.Fatalf("Default expectation is already set for the WriteAccessor.WaitOpened method")
	}

	if len(mmWaitOpened.expectations) > 0 {
		mmWaitOpened.mock.t.Fatalf("Some expectations are already set for the WriteAccessor.WaitOpened method")
	}

	mmWaitOpened.mock.funcWaitOpened = f
	return mmWaitOpened.mock
}

// WaitOpened implements WriteAccessor
func (mmWaitOpened *WriteAccessorMock) WaitOpened(ctx context.Context) {
	mm_atomic.AddUint64(&mmWaitOpened.beforeWaitOpenedCounter, 1)
	defer mm_atomic.AddUint64(&mmWaitOpened.afterWaitOpenedCounter, 1)

	if mmWaitOpened.inspectFuncWaitOpened != nil {
		mmWaitOpened.inspectFuncWaitOpened(ctx)
	}

	params := &WriteAccessorMockWaitOpenedParams{ctx}

	// Record call args
	mmWaitOpened.WaitOpenedMock.mutex.Lock()
	mmWaitOpened.WaitOpenedMock.callArgs = append(mmWaitOpened.WaitOpenedMock.callArgs, params)
	mmWaitOpened.WaitOpenedMock.mutex.Unlock()

	for _, e := range mmWaitOpened.WaitOpenedMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWaitOpened.WaitOpenedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWaitOpened.WaitOpenedMock.defaultExpectation.Counter, 1)
		want := mmWaitOpened.WaitOpenedMock.defaultExpectation.params
		got := WriteAccessorMockWaitOpenedParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmWaitOpened.t.Errorf("WriteAccessorMock.WaitOpened got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmWaitOpened.funcWaitOpened != nil {
		mmWaitOpened.funcWaitOpened(ctx)
		return
	}
	mmWaitOpened.t.Fatalf("Unexpected call to WriteAccessorMock.WaitOpened. %v", ctx)

}

// WaitOpenedAfterCounter returns a count of finished WriteAccessorMock.WaitOpened invocations
func (mmWaitOpened *WriteAccessorMock) WaitOpenedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitOpened.afterWaitOpenedCounter)
}

// WaitOpenedBeforeCounter returns a count of WriteAccessorMock.WaitOpened invocations
func (mmWaitOpened *WriteAccessorMock) WaitOpenedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitOpened.beforeWaitOpenedCounter)
}

// Calls returns a list of arguments used in each call to WriteAccessorMock.WaitOpened.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWaitOpened *mWriteAccessorMockWaitOpened) Calls() []*WriteAccessorMockWaitOpenedParams {
	mmWaitOpened.mutex.RLock()

	argCopy := make([]*WriteAccessorMockWaitOpenedParams, len(mmWaitOpened.callArgs))
	copy(argCopy, mmWaitOpened.callArgs)

	mmWaitOpened.mutex.RUnlock()

	return argCopy
}

// MinimockWaitOpenedDone returns true if the count of the WaitOpened invocations corresponds
// the number of defined expectations
func (m *WriteAccessorMock) MinimockWaitOpenedDone() bool {
	for _, e := range m.WaitOpenedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WaitOpenedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWaitOpenedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWaitOpened != nil && mm_atomic.LoadUint64(&m.afterWaitOpenedCounter) < 1 {
		return false
	}
	return true
}

// MinimockWaitOpenedInspect logs each unmet expectation
func (m *WriteAccessorMock) MinimockWaitOpenedInspect() {
	for _, e := range m.WaitOpenedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to WriteAccessorMock.WaitOpened with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WaitOpenedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWaitOpenedCounter) < 1 {
		if m.WaitOpenedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to WriteAccessorMock.WaitOpened")
		} else {
			m.t.Errorf("Expected call to WriteAccessorMock.WaitOpened with params: %#v", *m.WaitOpenedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWaitOpened != nil && mm_atomic.LoadUint64(&m.afterWaitOpenedCounter) < 1 {
		m.t.Error("Expected call to WriteAccessorMock.WaitOpened")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *WriteAccessorMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockBeginInspect()

		m.MinimockWaitOpenedInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *WriteAccessorMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *WriteAccessorMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBeginDone() &&
		m.MinimockWaitOpenedDone()
}
