package logicrunner

// Code generated by http://github.com/gojuno/minimock (3.0.0). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/insolar/insolar"
)

// StateStorageMock implements StateStorage
type StateStorageMock struct {
	t minimock.Tester

	funcDeleteObjectState          func(ref insolar.Reference)
	inspectFuncDeleteObjectState   func(ref insolar.Reference)
	afterDeleteObjectStateCounter  uint64
	beforeDeleteObjectStateCounter uint64
	DeleteObjectStateMock          mStateStorageMockDeleteObjectState

	funcGetExecutionState          func(ref insolar.Reference) (e1 ExecutionBrokerI)
	inspectFuncGetExecutionState   func(ref insolar.Reference)
	afterGetExecutionStateCounter  uint64
	beforeGetExecutionStateCounter uint64
	GetExecutionStateMock          mStateStorageMockGetExecutionState

	funcLock          func()
	inspectFuncLock   func()
	afterLockCounter  uint64
	beforeLockCounter uint64
	LockMock          mStateStorageMockLock

	funcStateMap          func() (mp1 *map[insolar.Reference]*ObjectState)
	inspectFuncStateMap   func()
	afterStateMapCounter  uint64
	beforeStateMapCounter uint64
	StateMapMock          mStateStorageMockStateMap

	funcUnlock          func()
	inspectFuncUnlock   func()
	afterUnlockCounter  uint64
	beforeUnlockCounter uint64
	UnlockMock          mStateStorageMockUnlock

	funcUpsertExecutionState          func(ref insolar.Reference) (e1 ExecutionBrokerI)
	inspectFuncUpsertExecutionState   func(ref insolar.Reference)
	afterUpsertExecutionStateCounter  uint64
	beforeUpsertExecutionStateCounter uint64
	UpsertExecutionStateMock          mStateStorageMockUpsertExecutionState
}

// NewStateStorageMock returns a mock for StateStorage
func NewStateStorageMock(t minimock.Tester) *StateStorageMock {
	m := &StateStorageMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DeleteObjectStateMock = mStateStorageMockDeleteObjectState{mock: m}
	m.DeleteObjectStateMock.callArgs = []*StateStorageMockDeleteObjectStateParams{}

	m.GetExecutionStateMock = mStateStorageMockGetExecutionState{mock: m}
	m.GetExecutionStateMock.callArgs = []*StateStorageMockGetExecutionStateParams{}

	m.LockMock = mStateStorageMockLock{mock: m}

	m.StateMapMock = mStateStorageMockStateMap{mock: m}

	m.UnlockMock = mStateStorageMockUnlock{mock: m}

	m.UpsertExecutionStateMock = mStateStorageMockUpsertExecutionState{mock: m}
	m.UpsertExecutionStateMock.callArgs = []*StateStorageMockUpsertExecutionStateParams{}

	return m
}

type mStateStorageMockDeleteObjectState struct {
	mock               *StateStorageMock
	defaultExpectation *StateStorageMockDeleteObjectStateExpectation
	expectations       []*StateStorageMockDeleteObjectStateExpectation

	callArgs []*StateStorageMockDeleteObjectStateParams
	mutex    sync.RWMutex
}

// StateStorageMockDeleteObjectStateExpectation specifies expectation struct of the StateStorage.DeleteObjectState
type StateStorageMockDeleteObjectStateExpectation struct {
	mock   *StateStorageMock
	params *StateStorageMockDeleteObjectStateParams

	Counter uint64
}

// StateStorageMockDeleteObjectStateParams contains parameters of the StateStorage.DeleteObjectState
type StateStorageMockDeleteObjectStateParams struct {
	ref insolar.Reference
}

// Expect sets up expected params for StateStorage.DeleteObjectState
func (mmDeleteObjectState *mStateStorageMockDeleteObjectState) Expect(ref insolar.Reference) *mStateStorageMockDeleteObjectState {
	if mmDeleteObjectState.mock.funcDeleteObjectState != nil {
		mmDeleteObjectState.mock.t.Fatalf("StateStorageMock.DeleteObjectState mock is already set by Set")
	}

	if mmDeleteObjectState.defaultExpectation == nil {
		mmDeleteObjectState.defaultExpectation = &StateStorageMockDeleteObjectStateExpectation{}
	}

	mmDeleteObjectState.defaultExpectation.params = &StateStorageMockDeleteObjectStateParams{ref}
	for _, e := range mmDeleteObjectState.expectations {
		if minimock.Equal(e.params, mmDeleteObjectState.defaultExpectation.params) {
			mmDeleteObjectState.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteObjectState.defaultExpectation.params)
		}
	}

	return mmDeleteObjectState
}

// Inspect accepts an inspector function that has same arguments as the StateStorage.DeleteObjectState
func (mmDeleteObjectState *mStateStorageMockDeleteObjectState) Inspect(f func(ref insolar.Reference)) *mStateStorageMockDeleteObjectState {
	if mmDeleteObjectState.mock.inspectFuncDeleteObjectState != nil {
		mmDeleteObjectState.mock.t.Fatalf("Inspect function is already set for StateStorageMock.DeleteObjectState")
	}

	mmDeleteObjectState.mock.inspectFuncDeleteObjectState = f

	return mmDeleteObjectState
}

// Return sets up results that will be returned by StateStorage.DeleteObjectState
func (mmDeleteObjectState *mStateStorageMockDeleteObjectState) Return() *StateStorageMock {
	if mmDeleteObjectState.mock.funcDeleteObjectState != nil {
		mmDeleteObjectState.mock.t.Fatalf("StateStorageMock.DeleteObjectState mock is already set by Set")
	}

	if mmDeleteObjectState.defaultExpectation == nil {
		mmDeleteObjectState.defaultExpectation = &StateStorageMockDeleteObjectStateExpectation{mock: mmDeleteObjectState.mock}
	}

	return mmDeleteObjectState.mock
}

//Set uses given function f to mock the StateStorage.DeleteObjectState method
func (mmDeleteObjectState *mStateStorageMockDeleteObjectState) Set(f func(ref insolar.Reference)) *StateStorageMock {
	if mmDeleteObjectState.defaultExpectation != nil {
		mmDeleteObjectState.mock.t.Fatalf("Default expectation is already set for the StateStorage.DeleteObjectState method")
	}

	if len(mmDeleteObjectState.expectations) > 0 {
		mmDeleteObjectState.mock.t.Fatalf("Some expectations are already set for the StateStorage.DeleteObjectState method")
	}

	mmDeleteObjectState.mock.funcDeleteObjectState = f
	return mmDeleteObjectState.mock
}

// DeleteObjectState implements StateStorage
func (mmDeleteObjectState *StateStorageMock) DeleteObjectState(ref insolar.Reference) {
	mm_atomic.AddUint64(&mmDeleteObjectState.beforeDeleteObjectStateCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteObjectState.afterDeleteObjectStateCounter, 1)

	if mmDeleteObjectState.inspectFuncDeleteObjectState != nil {
		mmDeleteObjectState.inspectFuncDeleteObjectState(ref)
	}

	params := &StateStorageMockDeleteObjectStateParams{ref}

	// Record call args
	mmDeleteObjectState.DeleteObjectStateMock.mutex.Lock()
	mmDeleteObjectState.DeleteObjectStateMock.callArgs = append(mmDeleteObjectState.DeleteObjectStateMock.callArgs, params)
	mmDeleteObjectState.DeleteObjectStateMock.mutex.Unlock()

	for _, e := range mmDeleteObjectState.DeleteObjectStateMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDeleteObjectState.DeleteObjectStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteObjectState.DeleteObjectStateMock.defaultExpectation.Counter, 1)
		want := mmDeleteObjectState.DeleteObjectStateMock.defaultExpectation.params
		got := StateStorageMockDeleteObjectStateParams{ref}
		if want != nil && !minimock.Equal(*want, got) {
			mmDeleteObjectState.t.Errorf("StateStorageMock.DeleteObjectState got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmDeleteObjectState.funcDeleteObjectState != nil {
		mmDeleteObjectState.funcDeleteObjectState(ref)
		return
	}
	mmDeleteObjectState.t.Fatalf("Unexpected call to StateStorageMock.DeleteObjectState. %v", ref)

}

// DeleteObjectStateAfterCounter returns a count of finished StateStorageMock.DeleteObjectState invocations
func (mmDeleteObjectState *StateStorageMock) DeleteObjectStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteObjectState.afterDeleteObjectStateCounter)
}

// DeleteObjectStateBeforeCounter returns a count of StateStorageMock.DeleteObjectState invocations
func (mmDeleteObjectState *StateStorageMock) DeleteObjectStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteObjectState.beforeDeleteObjectStateCounter)
}

// Calls returns a list of arguments used in each call to StateStorageMock.DeleteObjectState.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteObjectState *mStateStorageMockDeleteObjectState) Calls() []*StateStorageMockDeleteObjectStateParams {
	mmDeleteObjectState.mutex.RLock()

	argCopy := make([]*StateStorageMockDeleteObjectStateParams, len(mmDeleteObjectState.callArgs))
	copy(argCopy, mmDeleteObjectState.callArgs)

	mmDeleteObjectState.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteObjectStateDone returns true if the count of the DeleteObjectState invocations corresponds
// the number of defined expectations
func (m *StateStorageMock) MinimockDeleteObjectStateDone() bool {
	for _, e := range m.DeleteObjectStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteObjectStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteObjectStateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteObjectState != nil && mm_atomic.LoadUint64(&m.afterDeleteObjectStateCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteObjectStateInspect logs each unmet expectation
func (m *StateStorageMock) MinimockDeleteObjectStateInspect() {
	for _, e := range m.DeleteObjectStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StateStorageMock.DeleteObjectState with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteObjectStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteObjectStateCounter) < 1 {
		if m.DeleteObjectStateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StateStorageMock.DeleteObjectState")
		} else {
			m.t.Errorf("Expected call to StateStorageMock.DeleteObjectState with params: %#v", *m.DeleteObjectStateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteObjectState != nil && mm_atomic.LoadUint64(&m.afterDeleteObjectStateCounter) < 1 {
		m.t.Error("Expected call to StateStorageMock.DeleteObjectState")
	}
}

type mStateStorageMockGetExecutionState struct {
	mock               *StateStorageMock
	defaultExpectation *StateStorageMockGetExecutionStateExpectation
	expectations       []*StateStorageMockGetExecutionStateExpectation

	callArgs []*StateStorageMockGetExecutionStateParams
	mutex    sync.RWMutex
}

// StateStorageMockGetExecutionStateExpectation specifies expectation struct of the StateStorage.GetExecutionState
type StateStorageMockGetExecutionStateExpectation struct {
	mock    *StateStorageMock
	params  *StateStorageMockGetExecutionStateParams
	results *StateStorageMockGetExecutionStateResults
	Counter uint64
}

// StateStorageMockGetExecutionStateParams contains parameters of the StateStorage.GetExecutionState
type StateStorageMockGetExecutionStateParams struct {
	ref insolar.Reference
}

// StateStorageMockGetExecutionStateResults contains results of the StateStorage.GetExecutionState
type StateStorageMockGetExecutionStateResults struct {
	e1 ExecutionBrokerI
}

// Expect sets up expected params for StateStorage.GetExecutionState
func (mmGetExecutionState *mStateStorageMockGetExecutionState) Expect(ref insolar.Reference) *mStateStorageMockGetExecutionState {
	if mmGetExecutionState.mock.funcGetExecutionState != nil {
		mmGetExecutionState.mock.t.Fatalf("StateStorageMock.GetExecutionState mock is already set by Set")
	}

	if mmGetExecutionState.defaultExpectation == nil {
		mmGetExecutionState.defaultExpectation = &StateStorageMockGetExecutionStateExpectation{}
	}

	mmGetExecutionState.defaultExpectation.params = &StateStorageMockGetExecutionStateParams{ref}
	for _, e := range mmGetExecutionState.expectations {
		if minimock.Equal(e.params, mmGetExecutionState.defaultExpectation.params) {
			mmGetExecutionState.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetExecutionState.defaultExpectation.params)
		}
	}

	return mmGetExecutionState
}

// Inspect accepts an inspector function that has same arguments as the StateStorage.GetExecutionState
func (mmGetExecutionState *mStateStorageMockGetExecutionState) Inspect(f func(ref insolar.Reference)) *mStateStorageMockGetExecutionState {
	if mmGetExecutionState.mock.inspectFuncGetExecutionState != nil {
		mmGetExecutionState.mock.t.Fatalf("Inspect function is already set for StateStorageMock.GetExecutionState")
	}

	mmGetExecutionState.mock.inspectFuncGetExecutionState = f

	return mmGetExecutionState
}

// Return sets up results that will be returned by StateStorage.GetExecutionState
func (mmGetExecutionState *mStateStorageMockGetExecutionState) Return(e1 ExecutionBrokerI) *StateStorageMock {
	if mmGetExecutionState.mock.funcGetExecutionState != nil {
		mmGetExecutionState.mock.t.Fatalf("StateStorageMock.GetExecutionState mock is already set by Set")
	}

	if mmGetExecutionState.defaultExpectation == nil {
		mmGetExecutionState.defaultExpectation = &StateStorageMockGetExecutionStateExpectation{mock: mmGetExecutionState.mock}
	}
	mmGetExecutionState.defaultExpectation.results = &StateStorageMockGetExecutionStateResults{e1}
	return mmGetExecutionState.mock
}

//Set uses given function f to mock the StateStorage.GetExecutionState method
func (mmGetExecutionState *mStateStorageMockGetExecutionState) Set(f func(ref insolar.Reference) (e1 ExecutionBrokerI)) *StateStorageMock {
	if mmGetExecutionState.defaultExpectation != nil {
		mmGetExecutionState.mock.t.Fatalf("Default expectation is already set for the StateStorage.GetExecutionState method")
	}

	if len(mmGetExecutionState.expectations) > 0 {
		mmGetExecutionState.mock.t.Fatalf("Some expectations are already set for the StateStorage.GetExecutionState method")
	}

	mmGetExecutionState.mock.funcGetExecutionState = f
	return mmGetExecutionState.mock
}

// When sets expectation for the StateStorage.GetExecutionState which will trigger the result defined by the following
// Then helper
func (mmGetExecutionState *mStateStorageMockGetExecutionState) When(ref insolar.Reference) *StateStorageMockGetExecutionStateExpectation {
	if mmGetExecutionState.mock.funcGetExecutionState != nil {
		mmGetExecutionState.mock.t.Fatalf("StateStorageMock.GetExecutionState mock is already set by Set")
	}

	expectation := &StateStorageMockGetExecutionStateExpectation{
		mock:   mmGetExecutionState.mock,
		params: &StateStorageMockGetExecutionStateParams{ref},
	}
	mmGetExecutionState.expectations = append(mmGetExecutionState.expectations, expectation)
	return expectation
}

// Then sets up StateStorage.GetExecutionState return parameters for the expectation previously defined by the When method
func (e *StateStorageMockGetExecutionStateExpectation) Then(e1 ExecutionBrokerI) *StateStorageMock {
	e.results = &StateStorageMockGetExecutionStateResults{e1}
	return e.mock
}

// GetExecutionState implements StateStorage
func (mmGetExecutionState *StateStorageMock) GetExecutionState(ref insolar.Reference) (e1 ExecutionBrokerI) {
	mm_atomic.AddUint64(&mmGetExecutionState.beforeGetExecutionStateCounter, 1)
	defer mm_atomic.AddUint64(&mmGetExecutionState.afterGetExecutionStateCounter, 1)

	if mmGetExecutionState.inspectFuncGetExecutionState != nil {
		mmGetExecutionState.inspectFuncGetExecutionState(ref)
	}

	params := &StateStorageMockGetExecutionStateParams{ref}

	// Record call args
	mmGetExecutionState.GetExecutionStateMock.mutex.Lock()
	mmGetExecutionState.GetExecutionStateMock.callArgs = append(mmGetExecutionState.GetExecutionStateMock.callArgs, params)
	mmGetExecutionState.GetExecutionStateMock.mutex.Unlock()

	for _, e := range mmGetExecutionState.GetExecutionStateMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.e1
		}
	}

	if mmGetExecutionState.GetExecutionStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetExecutionState.GetExecutionStateMock.defaultExpectation.Counter, 1)
		want := mmGetExecutionState.GetExecutionStateMock.defaultExpectation.params
		got := StateStorageMockGetExecutionStateParams{ref}
		if want != nil && !minimock.Equal(*want, got) {
			mmGetExecutionState.t.Errorf("StateStorageMock.GetExecutionState got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGetExecutionState.GetExecutionStateMock.defaultExpectation.results
		if results == nil {
			mmGetExecutionState.t.Fatal("No results are set for the StateStorageMock.GetExecutionState")
		}
		return (*results).e1
	}
	if mmGetExecutionState.funcGetExecutionState != nil {
		return mmGetExecutionState.funcGetExecutionState(ref)
	}
	mmGetExecutionState.t.Fatalf("Unexpected call to StateStorageMock.GetExecutionState. %v", ref)
	return
}

// GetExecutionStateAfterCounter returns a count of finished StateStorageMock.GetExecutionState invocations
func (mmGetExecutionState *StateStorageMock) GetExecutionStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetExecutionState.afterGetExecutionStateCounter)
}

// GetExecutionStateBeforeCounter returns a count of StateStorageMock.GetExecutionState invocations
func (mmGetExecutionState *StateStorageMock) GetExecutionStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetExecutionState.beforeGetExecutionStateCounter)
}

// Calls returns a list of arguments used in each call to StateStorageMock.GetExecutionState.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetExecutionState *mStateStorageMockGetExecutionState) Calls() []*StateStorageMockGetExecutionStateParams {
	mmGetExecutionState.mutex.RLock()

	argCopy := make([]*StateStorageMockGetExecutionStateParams, len(mmGetExecutionState.callArgs))
	copy(argCopy, mmGetExecutionState.callArgs)

	mmGetExecutionState.mutex.RUnlock()

	return argCopy
}

// MinimockGetExecutionStateDone returns true if the count of the GetExecutionState invocations corresponds
// the number of defined expectations
func (m *StateStorageMock) MinimockGetExecutionStateDone() bool {
	for _, e := range m.GetExecutionStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetExecutionStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetExecutionStateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetExecutionState != nil && mm_atomic.LoadUint64(&m.afterGetExecutionStateCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetExecutionStateInspect logs each unmet expectation
func (m *StateStorageMock) MinimockGetExecutionStateInspect() {
	for _, e := range m.GetExecutionStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StateStorageMock.GetExecutionState with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetExecutionStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetExecutionStateCounter) < 1 {
		if m.GetExecutionStateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StateStorageMock.GetExecutionState")
		} else {
			m.t.Errorf("Expected call to StateStorageMock.GetExecutionState with params: %#v", *m.GetExecutionStateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetExecutionState != nil && mm_atomic.LoadUint64(&m.afterGetExecutionStateCounter) < 1 {
		m.t.Error("Expected call to StateStorageMock.GetExecutionState")
	}
}

type mStateStorageMockLock struct {
	mock               *StateStorageMock
	defaultExpectation *StateStorageMockLockExpectation
	expectations       []*StateStorageMockLockExpectation
}

// StateStorageMockLockExpectation specifies expectation struct of the StateStorage.Lock
type StateStorageMockLockExpectation struct {
	mock *StateStorageMock

	Counter uint64
}

// Expect sets up expected params for StateStorage.Lock
func (mmLock *mStateStorageMockLock) Expect() *mStateStorageMockLock {
	if mmLock.mock.funcLock != nil {
		mmLock.mock.t.Fatalf("StateStorageMock.Lock mock is already set by Set")
	}

	if mmLock.defaultExpectation == nil {
		mmLock.defaultExpectation = &StateStorageMockLockExpectation{}
	}

	return mmLock
}

// Inspect accepts an inspector function that has same arguments as the StateStorage.Lock
func (mmLock *mStateStorageMockLock) Inspect(f func()) *mStateStorageMockLock {
	if mmLock.mock.inspectFuncLock != nil {
		mmLock.mock.t.Fatalf("Inspect function is already set for StateStorageMock.Lock")
	}

	mmLock.mock.inspectFuncLock = f

	return mmLock
}

// Return sets up results that will be returned by StateStorage.Lock
func (mmLock *mStateStorageMockLock) Return() *StateStorageMock {
	if mmLock.mock.funcLock != nil {
		mmLock.mock.t.Fatalf("StateStorageMock.Lock mock is already set by Set")
	}

	if mmLock.defaultExpectation == nil {
		mmLock.defaultExpectation = &StateStorageMockLockExpectation{mock: mmLock.mock}
	}

	return mmLock.mock
}

//Set uses given function f to mock the StateStorage.Lock method
func (mmLock *mStateStorageMockLock) Set(f func()) *StateStorageMock {
	if mmLock.defaultExpectation != nil {
		mmLock.mock.t.Fatalf("Default expectation is already set for the StateStorage.Lock method")
	}

	if len(mmLock.expectations) > 0 {
		mmLock.mock.t.Fatalf("Some expectations are already set for the StateStorage.Lock method")
	}

	mmLock.mock.funcLock = f
	return mmLock.mock
}

// Lock implements StateStorage
func (mmLock *StateStorageMock) Lock() {
	mm_atomic.AddUint64(&mmLock.beforeLockCounter, 1)
	defer mm_atomic.AddUint64(&mmLock.afterLockCounter, 1)

	if mmLock.inspectFuncLock != nil {
		mmLock.inspectFuncLock()
	}

	if mmLock.LockMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLock.LockMock.defaultExpectation.Counter, 1)

		return

	}
	if mmLock.funcLock != nil {
		mmLock.funcLock()
		return
	}
	mmLock.t.Fatalf("Unexpected call to StateStorageMock.Lock.")

}

// LockAfterCounter returns a count of finished StateStorageMock.Lock invocations
func (mmLock *StateStorageMock) LockAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLock.afterLockCounter)
}

// LockBeforeCounter returns a count of StateStorageMock.Lock invocations
func (mmLock *StateStorageMock) LockBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLock.beforeLockCounter)
}

// MinimockLockDone returns true if the count of the Lock invocations corresponds
// the number of defined expectations
func (m *StateStorageMock) MinimockLockDone() bool {
	for _, e := range m.LockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLockCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLock != nil && mm_atomic.LoadUint64(&m.afterLockCounter) < 1 {
		return false
	}
	return true
}

// MinimockLockInspect logs each unmet expectation
func (m *StateStorageMock) MinimockLockInspect() {
	for _, e := range m.LockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StateStorageMock.Lock")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLockCounter) < 1 {
		m.t.Error("Expected call to StateStorageMock.Lock")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLock != nil && mm_atomic.LoadUint64(&m.afterLockCounter) < 1 {
		m.t.Error("Expected call to StateStorageMock.Lock")
	}
}

type mStateStorageMockStateMap struct {
	mock               *StateStorageMock
	defaultExpectation *StateStorageMockStateMapExpectation
	expectations       []*StateStorageMockStateMapExpectation
}

// StateStorageMockStateMapExpectation specifies expectation struct of the StateStorage.StateMap
type StateStorageMockStateMapExpectation struct {
	mock *StateStorageMock

	results *StateStorageMockStateMapResults
	Counter uint64
}

// StateStorageMockStateMapResults contains results of the StateStorage.StateMap
type StateStorageMockStateMapResults struct {
	mp1 *map[insolar.Reference]*ObjectState
}

// Expect sets up expected params for StateStorage.StateMap
func (mmStateMap *mStateStorageMockStateMap) Expect() *mStateStorageMockStateMap {
	if mmStateMap.mock.funcStateMap != nil {
		mmStateMap.mock.t.Fatalf("StateStorageMock.StateMap mock is already set by Set")
	}

	if mmStateMap.defaultExpectation == nil {
		mmStateMap.defaultExpectation = &StateStorageMockStateMapExpectation{}
	}

	return mmStateMap
}

// Inspect accepts an inspector function that has same arguments as the StateStorage.StateMap
func (mmStateMap *mStateStorageMockStateMap) Inspect(f func()) *mStateStorageMockStateMap {
	if mmStateMap.mock.inspectFuncStateMap != nil {
		mmStateMap.mock.t.Fatalf("Inspect function is already set for StateStorageMock.StateMap")
	}

	mmStateMap.mock.inspectFuncStateMap = f

	return mmStateMap
}

// Return sets up results that will be returned by StateStorage.StateMap
func (mmStateMap *mStateStorageMockStateMap) Return(mp1 *map[insolar.Reference]*ObjectState) *StateStorageMock {
	if mmStateMap.mock.funcStateMap != nil {
		mmStateMap.mock.t.Fatalf("StateStorageMock.StateMap mock is already set by Set")
	}

	if mmStateMap.defaultExpectation == nil {
		mmStateMap.defaultExpectation = &StateStorageMockStateMapExpectation{mock: mmStateMap.mock}
	}
	mmStateMap.defaultExpectation.results = &StateStorageMockStateMapResults{mp1}
	return mmStateMap.mock
}

//Set uses given function f to mock the StateStorage.StateMap method
func (mmStateMap *mStateStorageMockStateMap) Set(f func() (mp1 *map[insolar.Reference]*ObjectState)) *StateStorageMock {
	if mmStateMap.defaultExpectation != nil {
		mmStateMap.mock.t.Fatalf("Default expectation is already set for the StateStorage.StateMap method")
	}

	if len(mmStateMap.expectations) > 0 {
		mmStateMap.mock.t.Fatalf("Some expectations are already set for the StateStorage.StateMap method")
	}

	mmStateMap.mock.funcStateMap = f
	return mmStateMap.mock
}

// StateMap implements StateStorage
func (mmStateMap *StateStorageMock) StateMap() (mp1 *map[insolar.Reference]*ObjectState) {
	mm_atomic.AddUint64(&mmStateMap.beforeStateMapCounter, 1)
	defer mm_atomic.AddUint64(&mmStateMap.afterStateMapCounter, 1)

	if mmStateMap.inspectFuncStateMap != nil {
		mmStateMap.inspectFuncStateMap()
	}

	if mmStateMap.StateMapMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStateMap.StateMapMock.defaultExpectation.Counter, 1)

		results := mmStateMap.StateMapMock.defaultExpectation.results
		if results == nil {
			mmStateMap.t.Fatal("No results are set for the StateStorageMock.StateMap")
		}
		return (*results).mp1
	}
	if mmStateMap.funcStateMap != nil {
		return mmStateMap.funcStateMap()
	}
	mmStateMap.t.Fatalf("Unexpected call to StateStorageMock.StateMap.")
	return
}

// StateMapAfterCounter returns a count of finished StateStorageMock.StateMap invocations
func (mmStateMap *StateStorageMock) StateMapAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStateMap.afterStateMapCounter)
}

// StateMapBeforeCounter returns a count of StateStorageMock.StateMap invocations
func (mmStateMap *StateStorageMock) StateMapBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStateMap.beforeStateMapCounter)
}

// MinimockStateMapDone returns true if the count of the StateMap invocations corresponds
// the number of defined expectations
func (m *StateStorageMock) MinimockStateMapDone() bool {
	for _, e := range m.StateMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StateMapMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStateMapCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStateMap != nil && mm_atomic.LoadUint64(&m.afterStateMapCounter) < 1 {
		return false
	}
	return true
}

// MinimockStateMapInspect logs each unmet expectation
func (m *StateStorageMock) MinimockStateMapInspect() {
	for _, e := range m.StateMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StateStorageMock.StateMap")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StateMapMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStateMapCounter) < 1 {
		m.t.Error("Expected call to StateStorageMock.StateMap")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStateMap != nil && mm_atomic.LoadUint64(&m.afterStateMapCounter) < 1 {
		m.t.Error("Expected call to StateStorageMock.StateMap")
	}
}

type mStateStorageMockUnlock struct {
	mock               *StateStorageMock
	defaultExpectation *StateStorageMockUnlockExpectation
	expectations       []*StateStorageMockUnlockExpectation
}

// StateStorageMockUnlockExpectation specifies expectation struct of the StateStorage.Unlock
type StateStorageMockUnlockExpectation struct {
	mock *StateStorageMock

	Counter uint64
}

// Expect sets up expected params for StateStorage.Unlock
func (mmUnlock *mStateStorageMockUnlock) Expect() *mStateStorageMockUnlock {
	if mmUnlock.mock.funcUnlock != nil {
		mmUnlock.mock.t.Fatalf("StateStorageMock.Unlock mock is already set by Set")
	}

	if mmUnlock.defaultExpectation == nil {
		mmUnlock.defaultExpectation = &StateStorageMockUnlockExpectation{}
	}

	return mmUnlock
}

// Inspect accepts an inspector function that has same arguments as the StateStorage.Unlock
func (mmUnlock *mStateStorageMockUnlock) Inspect(f func()) *mStateStorageMockUnlock {
	if mmUnlock.mock.inspectFuncUnlock != nil {
		mmUnlock.mock.t.Fatalf("Inspect function is already set for StateStorageMock.Unlock")
	}

	mmUnlock.mock.inspectFuncUnlock = f

	return mmUnlock
}

// Return sets up results that will be returned by StateStorage.Unlock
func (mmUnlock *mStateStorageMockUnlock) Return() *StateStorageMock {
	if mmUnlock.mock.funcUnlock != nil {
		mmUnlock.mock.t.Fatalf("StateStorageMock.Unlock mock is already set by Set")
	}

	if mmUnlock.defaultExpectation == nil {
		mmUnlock.defaultExpectation = &StateStorageMockUnlockExpectation{mock: mmUnlock.mock}
	}

	return mmUnlock.mock
}

//Set uses given function f to mock the StateStorage.Unlock method
func (mmUnlock *mStateStorageMockUnlock) Set(f func()) *StateStorageMock {
	if mmUnlock.defaultExpectation != nil {
		mmUnlock.mock.t.Fatalf("Default expectation is already set for the StateStorage.Unlock method")
	}

	if len(mmUnlock.expectations) > 0 {
		mmUnlock.mock.t.Fatalf("Some expectations are already set for the StateStorage.Unlock method")
	}

	mmUnlock.mock.funcUnlock = f
	return mmUnlock.mock
}

// Unlock implements StateStorage
func (mmUnlock *StateStorageMock) Unlock() {
	mm_atomic.AddUint64(&mmUnlock.beforeUnlockCounter, 1)
	defer mm_atomic.AddUint64(&mmUnlock.afterUnlockCounter, 1)

	if mmUnlock.inspectFuncUnlock != nil {
		mmUnlock.inspectFuncUnlock()
	}

	if mmUnlock.UnlockMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnlock.UnlockMock.defaultExpectation.Counter, 1)

		return

	}
	if mmUnlock.funcUnlock != nil {
		mmUnlock.funcUnlock()
		return
	}
	mmUnlock.t.Fatalf("Unexpected call to StateStorageMock.Unlock.")

}

// UnlockAfterCounter returns a count of finished StateStorageMock.Unlock invocations
func (mmUnlock *StateStorageMock) UnlockAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnlock.afterUnlockCounter)
}

// UnlockBeforeCounter returns a count of StateStorageMock.Unlock invocations
func (mmUnlock *StateStorageMock) UnlockBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnlock.beforeUnlockCounter)
}

// MinimockUnlockDone returns true if the count of the Unlock invocations corresponds
// the number of defined expectations
func (m *StateStorageMock) MinimockUnlockDone() bool {
	for _, e := range m.UnlockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnlockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnlockCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnlock != nil && mm_atomic.LoadUint64(&m.afterUnlockCounter) < 1 {
		return false
	}
	return true
}

// MinimockUnlockInspect logs each unmet expectation
func (m *StateStorageMock) MinimockUnlockInspect() {
	for _, e := range m.UnlockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StateStorageMock.Unlock")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnlockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnlockCounter) < 1 {
		m.t.Error("Expected call to StateStorageMock.Unlock")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnlock != nil && mm_atomic.LoadUint64(&m.afterUnlockCounter) < 1 {
		m.t.Error("Expected call to StateStorageMock.Unlock")
	}
}

type mStateStorageMockUpsertExecutionState struct {
	mock               *StateStorageMock
	defaultExpectation *StateStorageMockUpsertExecutionStateExpectation
	expectations       []*StateStorageMockUpsertExecutionStateExpectation

	callArgs []*StateStorageMockUpsertExecutionStateParams
	mutex    sync.RWMutex
}

// StateStorageMockUpsertExecutionStateExpectation specifies expectation struct of the StateStorage.UpsertExecutionState
type StateStorageMockUpsertExecutionStateExpectation struct {
	mock    *StateStorageMock
	params  *StateStorageMockUpsertExecutionStateParams
	results *StateStorageMockUpsertExecutionStateResults
	Counter uint64
}

// StateStorageMockUpsertExecutionStateParams contains parameters of the StateStorage.UpsertExecutionState
type StateStorageMockUpsertExecutionStateParams struct {
	ref insolar.Reference
}

// StateStorageMockUpsertExecutionStateResults contains results of the StateStorage.UpsertExecutionState
type StateStorageMockUpsertExecutionStateResults struct {
	e1 ExecutionBrokerI
}

// Expect sets up expected params for StateStorage.UpsertExecutionState
func (mmUpsertExecutionState *mStateStorageMockUpsertExecutionState) Expect(ref insolar.Reference) *mStateStorageMockUpsertExecutionState {
	if mmUpsertExecutionState.mock.funcUpsertExecutionState != nil {
		mmUpsertExecutionState.mock.t.Fatalf("StateStorageMock.UpsertExecutionState mock is already set by Set")
	}

	if mmUpsertExecutionState.defaultExpectation == nil {
		mmUpsertExecutionState.defaultExpectation = &StateStorageMockUpsertExecutionStateExpectation{}
	}

	mmUpsertExecutionState.defaultExpectation.params = &StateStorageMockUpsertExecutionStateParams{ref}
	for _, e := range mmUpsertExecutionState.expectations {
		if minimock.Equal(e.params, mmUpsertExecutionState.defaultExpectation.params) {
			mmUpsertExecutionState.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertExecutionState.defaultExpectation.params)
		}
	}

	return mmUpsertExecutionState
}

// Inspect accepts an inspector function that has same arguments as the StateStorage.UpsertExecutionState
func (mmUpsertExecutionState *mStateStorageMockUpsertExecutionState) Inspect(f func(ref insolar.Reference)) *mStateStorageMockUpsertExecutionState {
	if mmUpsertExecutionState.mock.inspectFuncUpsertExecutionState != nil {
		mmUpsertExecutionState.mock.t.Fatalf("Inspect function is already set for StateStorageMock.UpsertExecutionState")
	}

	mmUpsertExecutionState.mock.inspectFuncUpsertExecutionState = f

	return mmUpsertExecutionState
}

// Return sets up results that will be returned by StateStorage.UpsertExecutionState
func (mmUpsertExecutionState *mStateStorageMockUpsertExecutionState) Return(e1 ExecutionBrokerI) *StateStorageMock {
	if mmUpsertExecutionState.mock.funcUpsertExecutionState != nil {
		mmUpsertExecutionState.mock.t.Fatalf("StateStorageMock.UpsertExecutionState mock is already set by Set")
	}

	if mmUpsertExecutionState.defaultExpectation == nil {
		mmUpsertExecutionState.defaultExpectation = &StateStorageMockUpsertExecutionStateExpectation{mock: mmUpsertExecutionState.mock}
	}
	mmUpsertExecutionState.defaultExpectation.results = &StateStorageMockUpsertExecutionStateResults{e1}
	return mmUpsertExecutionState.mock
}

//Set uses given function f to mock the StateStorage.UpsertExecutionState method
func (mmUpsertExecutionState *mStateStorageMockUpsertExecutionState) Set(f func(ref insolar.Reference) (e1 ExecutionBrokerI)) *StateStorageMock {
	if mmUpsertExecutionState.defaultExpectation != nil {
		mmUpsertExecutionState.mock.t.Fatalf("Default expectation is already set for the StateStorage.UpsertExecutionState method")
	}

	if len(mmUpsertExecutionState.expectations) > 0 {
		mmUpsertExecutionState.mock.t.Fatalf("Some expectations are already set for the StateStorage.UpsertExecutionState method")
	}

	mmUpsertExecutionState.mock.funcUpsertExecutionState = f
	return mmUpsertExecutionState.mock
}

// When sets expectation for the StateStorage.UpsertExecutionState which will trigger the result defined by the following
// Then helper
func (mmUpsertExecutionState *mStateStorageMockUpsertExecutionState) When(ref insolar.Reference) *StateStorageMockUpsertExecutionStateExpectation {
	if mmUpsertExecutionState.mock.funcUpsertExecutionState != nil {
		mmUpsertExecutionState.mock.t.Fatalf("StateStorageMock.UpsertExecutionState mock is already set by Set")
	}

	expectation := &StateStorageMockUpsertExecutionStateExpectation{
		mock:   mmUpsertExecutionState.mock,
		params: &StateStorageMockUpsertExecutionStateParams{ref},
	}
	mmUpsertExecutionState.expectations = append(mmUpsertExecutionState.expectations, expectation)
	return expectation
}

// Then sets up StateStorage.UpsertExecutionState return parameters for the expectation previously defined by the When method
func (e *StateStorageMockUpsertExecutionStateExpectation) Then(e1 ExecutionBrokerI) *StateStorageMock {
	e.results = &StateStorageMockUpsertExecutionStateResults{e1}
	return e.mock
}

// UpsertExecutionState implements StateStorage
func (mmUpsertExecutionState *StateStorageMock) UpsertExecutionState(ref insolar.Reference) (e1 ExecutionBrokerI) {
	mm_atomic.AddUint64(&mmUpsertExecutionState.beforeUpsertExecutionStateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertExecutionState.afterUpsertExecutionStateCounter, 1)

	if mmUpsertExecutionState.inspectFuncUpsertExecutionState != nil {
		mmUpsertExecutionState.inspectFuncUpsertExecutionState(ref)
	}

	params := &StateStorageMockUpsertExecutionStateParams{ref}

	// Record call args
	mmUpsertExecutionState.UpsertExecutionStateMock.mutex.Lock()
	mmUpsertExecutionState.UpsertExecutionStateMock.callArgs = append(mmUpsertExecutionState.UpsertExecutionStateMock.callArgs, params)
	mmUpsertExecutionState.UpsertExecutionStateMock.mutex.Unlock()

	for _, e := range mmUpsertExecutionState.UpsertExecutionStateMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.e1
		}
	}

	if mmUpsertExecutionState.UpsertExecutionStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertExecutionState.UpsertExecutionStateMock.defaultExpectation.Counter, 1)
		want := mmUpsertExecutionState.UpsertExecutionStateMock.defaultExpectation.params
		got := StateStorageMockUpsertExecutionStateParams{ref}
		if want != nil && !minimock.Equal(*want, got) {
			mmUpsertExecutionState.t.Errorf("StateStorageMock.UpsertExecutionState got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmUpsertExecutionState.UpsertExecutionStateMock.defaultExpectation.results
		if results == nil {
			mmUpsertExecutionState.t.Fatal("No results are set for the StateStorageMock.UpsertExecutionState")
		}
		return (*results).e1
	}
	if mmUpsertExecutionState.funcUpsertExecutionState != nil {
		return mmUpsertExecutionState.funcUpsertExecutionState(ref)
	}
	mmUpsertExecutionState.t.Fatalf("Unexpected call to StateStorageMock.UpsertExecutionState. %v", ref)
	return
}

// UpsertExecutionStateAfterCounter returns a count of finished StateStorageMock.UpsertExecutionState invocations
func (mmUpsertExecutionState *StateStorageMock) UpsertExecutionStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertExecutionState.afterUpsertExecutionStateCounter)
}

// UpsertExecutionStateBeforeCounter returns a count of StateStorageMock.UpsertExecutionState invocations
func (mmUpsertExecutionState *StateStorageMock) UpsertExecutionStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertExecutionState.beforeUpsertExecutionStateCounter)
}

// Calls returns a list of arguments used in each call to StateStorageMock.UpsertExecutionState.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertExecutionState *mStateStorageMockUpsertExecutionState) Calls() []*StateStorageMockUpsertExecutionStateParams {
	mmUpsertExecutionState.mutex.RLock()

	argCopy := make([]*StateStorageMockUpsertExecutionStateParams, len(mmUpsertExecutionState.callArgs))
	copy(argCopy, mmUpsertExecutionState.callArgs)

	mmUpsertExecutionState.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertExecutionStateDone returns true if the count of the UpsertExecutionState invocations corresponds
// the number of defined expectations
func (m *StateStorageMock) MinimockUpsertExecutionStateDone() bool {
	for _, e := range m.UpsertExecutionStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertExecutionStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpsertExecutionStateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertExecutionState != nil && mm_atomic.LoadUint64(&m.afterUpsertExecutionStateCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpsertExecutionStateInspect logs each unmet expectation
func (m *StateStorageMock) MinimockUpsertExecutionStateInspect() {
	for _, e := range m.UpsertExecutionStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StateStorageMock.UpsertExecutionState with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertExecutionStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpsertExecutionStateCounter) < 1 {
		if m.UpsertExecutionStateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StateStorageMock.UpsertExecutionState")
		} else {
			m.t.Errorf("Expected call to StateStorageMock.UpsertExecutionState with params: %#v", *m.UpsertExecutionStateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertExecutionState != nil && mm_atomic.LoadUint64(&m.afterUpsertExecutionStateCounter) < 1 {
		m.t.Error("Expected call to StateStorageMock.UpsertExecutionState")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StateStorageMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockDeleteObjectStateInspect()

		m.MinimockGetExecutionStateInspect()

		m.MinimockLockInspect()

		m.MinimockStateMapInspect()

		m.MinimockUnlockInspect()

		m.MinimockUpsertExecutionStateInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StateStorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StateStorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDeleteObjectStateDone() &&
		m.MinimockGetExecutionStateDone() &&
		m.MinimockLockDone() &&
		m.MinimockStateMapDone() &&
		m.MinimockUnlockDone() &&
		m.MinimockUpsertExecutionStateDone()
}
