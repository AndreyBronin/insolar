package executor

// Code generated by http://github.com/gojuno/minimock (3.0.0). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/insolar/insolar"
)

// JetKeeperMock implements JetKeeper
type JetKeeperMock struct {
	t minimock.Tester

	funcAddDropConfirmation          func(ctx context.Context, pn insolar.PulseNumber, jet insolar.JetID, split bool) (err error)
	inspectFuncAddDropConfirmation   func(ctx context.Context, pn insolar.PulseNumber, jet insolar.JetID, split bool)
	afterAddDropConfirmationCounter  uint64
	beforeAddDropConfirmationCounter uint64
	AddDropConfirmationMock          mJetKeeperMockAddDropConfirmation

	funcAddHotConfirmation          func(ctx context.Context, pn insolar.PulseNumber, jet insolar.JetID, split bool) (err error)
	inspectFuncAddHotConfirmation   func(ctx context.Context, pn insolar.PulseNumber, jet insolar.JetID, split bool)
	afterAddHotConfirmationCounter  uint64
	beforeAddHotConfirmationCounter uint64
	AddHotConfirmationMock          mJetKeeperMockAddHotConfirmation

	funcTopSyncPulse          func() (p1 insolar.PulseNumber)
	inspectFuncTopSyncPulse   func()
	afterTopSyncPulseCounter  uint64
	beforeTopSyncPulseCounter uint64
	TopSyncPulseMock          mJetKeeperMockTopSyncPulse
}

// NewJetKeeperMock returns a mock for JetKeeper
func NewJetKeeperMock(t minimock.Tester) *JetKeeperMock {
	m := &JetKeeperMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddDropConfirmationMock = mJetKeeperMockAddDropConfirmation{mock: m}
	m.AddDropConfirmationMock.callArgs = []*JetKeeperMockAddDropConfirmationParams{}

	m.AddHotConfirmationMock = mJetKeeperMockAddHotConfirmation{mock: m}
	m.AddHotConfirmationMock.callArgs = []*JetKeeperMockAddHotConfirmationParams{}

	m.TopSyncPulseMock = mJetKeeperMockTopSyncPulse{mock: m}

	return m
}

type mJetKeeperMockAddDropConfirmation struct {
	mock               *JetKeeperMock
	defaultExpectation *JetKeeperMockAddDropConfirmationExpectation
	expectations       []*JetKeeperMockAddDropConfirmationExpectation

	callArgs []*JetKeeperMockAddDropConfirmationParams
	mutex    sync.RWMutex
}

// JetKeeperMockAddDropConfirmationExpectation specifies expectation struct of the JetKeeper.AddDropConfirmation
type JetKeeperMockAddDropConfirmationExpectation struct {
	mock    *JetKeeperMock
	params  *JetKeeperMockAddDropConfirmationParams
	results *JetKeeperMockAddDropConfirmationResults
	Counter uint64
}

// JetKeeperMockAddDropConfirmationParams contains parameters of the JetKeeper.AddDropConfirmation
type JetKeeperMockAddDropConfirmationParams struct {
	ctx   context.Context
	pn    insolar.PulseNumber
	jet   insolar.JetID
	split bool
}

// JetKeeperMockAddDropConfirmationResults contains results of the JetKeeper.AddDropConfirmation
type JetKeeperMockAddDropConfirmationResults struct {
	err error
}

// Expect sets up expected params for JetKeeper.AddDropConfirmation
func (mmAddDropConfirmation *mJetKeeperMockAddDropConfirmation) Expect(ctx context.Context, pn insolar.PulseNumber, jet insolar.JetID, split bool) *mJetKeeperMockAddDropConfirmation {
	if mmAddDropConfirmation.mock.funcAddDropConfirmation != nil {
		mmAddDropConfirmation.mock.t.Fatalf("JetKeeperMock.AddDropConfirmation mock is already set by Set")
	}

	if mmAddDropConfirmation.defaultExpectation == nil {
		mmAddDropConfirmation.defaultExpectation = &JetKeeperMockAddDropConfirmationExpectation{}
	}

	mmAddDropConfirmation.defaultExpectation.params = &JetKeeperMockAddDropConfirmationParams{ctx, pn, jet, split}
	for _, e := range mmAddDropConfirmation.expectations {
		if minimock.Equal(e.params, mmAddDropConfirmation.defaultExpectation.params) {
			mmAddDropConfirmation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddDropConfirmation.defaultExpectation.params)
		}
	}

	return mmAddDropConfirmation
}

// Inspect accepts an inspector function that has same arguments as the JetKeeper.AddDropConfirmation
func (mmAddDropConfirmation *mJetKeeperMockAddDropConfirmation) Inspect(f func(ctx context.Context, pn insolar.PulseNumber, jet insolar.JetID, split bool)) *mJetKeeperMockAddDropConfirmation {
	if mmAddDropConfirmation.mock.inspectFuncAddDropConfirmation != nil {
		mmAddDropConfirmation.mock.t.Fatalf("Inspect function is already set for JetKeeperMock.AddDropConfirmation")
	}

	mmAddDropConfirmation.mock.inspectFuncAddDropConfirmation = f

	return mmAddDropConfirmation
}

// Return sets up results that will be returned by JetKeeper.AddDropConfirmation
func (mmAddDropConfirmation *mJetKeeperMockAddDropConfirmation) Return(err error) *JetKeeperMock {
	if mmAddDropConfirmation.mock.funcAddDropConfirmation != nil {
		mmAddDropConfirmation.mock.t.Fatalf("JetKeeperMock.AddDropConfirmation mock is already set by Set")
	}

	if mmAddDropConfirmation.defaultExpectation == nil {
		mmAddDropConfirmation.defaultExpectation = &JetKeeperMockAddDropConfirmationExpectation{mock: mmAddDropConfirmation.mock}
	}
	mmAddDropConfirmation.defaultExpectation.results = &JetKeeperMockAddDropConfirmationResults{err}
	return mmAddDropConfirmation.mock
}

//Set uses given function f to mock the JetKeeper.AddDropConfirmation method
func (mmAddDropConfirmation *mJetKeeperMockAddDropConfirmation) Set(f func(ctx context.Context, pn insolar.PulseNumber, jet insolar.JetID, split bool) (err error)) *JetKeeperMock {
	if mmAddDropConfirmation.defaultExpectation != nil {
		mmAddDropConfirmation.mock.t.Fatalf("Default expectation is already set for the JetKeeper.AddDropConfirmation method")
	}

	if len(mmAddDropConfirmation.expectations) > 0 {
		mmAddDropConfirmation.mock.t.Fatalf("Some expectations are already set for the JetKeeper.AddDropConfirmation method")
	}

	mmAddDropConfirmation.mock.funcAddDropConfirmation = f
	return mmAddDropConfirmation.mock
}

// When sets expectation for the JetKeeper.AddDropConfirmation which will trigger the result defined by the following
// Then helper
func (mmAddDropConfirmation *mJetKeeperMockAddDropConfirmation) When(ctx context.Context, pn insolar.PulseNumber, jet insolar.JetID, split bool) *JetKeeperMockAddDropConfirmationExpectation {
	if mmAddDropConfirmation.mock.funcAddDropConfirmation != nil {
		mmAddDropConfirmation.mock.t.Fatalf("JetKeeperMock.AddDropConfirmation mock is already set by Set")
	}

	expectation := &JetKeeperMockAddDropConfirmationExpectation{
		mock:   mmAddDropConfirmation.mock,
		params: &JetKeeperMockAddDropConfirmationParams{ctx, pn, jet, split},
	}
	mmAddDropConfirmation.expectations = append(mmAddDropConfirmation.expectations, expectation)
	return expectation
}

// Then sets up JetKeeper.AddDropConfirmation return parameters for the expectation previously defined by the When method
func (e *JetKeeperMockAddDropConfirmationExpectation) Then(err error) *JetKeeperMock {
	e.results = &JetKeeperMockAddDropConfirmationResults{err}
	return e.mock
}

// AddDropConfirmation implements JetKeeper
func (mmAddDropConfirmation *JetKeeperMock) AddDropConfirmation(ctx context.Context, pn insolar.PulseNumber, jet insolar.JetID, split bool) (err error) {
	mm_atomic.AddUint64(&mmAddDropConfirmation.beforeAddDropConfirmationCounter, 1)
	defer mm_atomic.AddUint64(&mmAddDropConfirmation.afterAddDropConfirmationCounter, 1)

	if mmAddDropConfirmation.inspectFuncAddDropConfirmation != nil {
		mmAddDropConfirmation.inspectFuncAddDropConfirmation(ctx, pn, jet, split)
	}

	params := &JetKeeperMockAddDropConfirmationParams{ctx, pn, jet, split}

	// Record call args
	mmAddDropConfirmation.AddDropConfirmationMock.mutex.Lock()
	mmAddDropConfirmation.AddDropConfirmationMock.callArgs = append(mmAddDropConfirmation.AddDropConfirmationMock.callArgs, params)
	mmAddDropConfirmation.AddDropConfirmationMock.mutex.Unlock()

	for _, e := range mmAddDropConfirmation.AddDropConfirmationMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddDropConfirmation.AddDropConfirmationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddDropConfirmation.AddDropConfirmationMock.defaultExpectation.Counter, 1)
		want := mmAddDropConfirmation.AddDropConfirmationMock.defaultExpectation.params
		got := JetKeeperMockAddDropConfirmationParams{ctx, pn, jet, split}
		if want != nil && !minimock.Equal(*want, got) {
			mmAddDropConfirmation.t.Errorf("JetKeeperMock.AddDropConfirmation got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmAddDropConfirmation.AddDropConfirmationMock.defaultExpectation.results
		if results == nil {
			mmAddDropConfirmation.t.Fatal("No results are set for the JetKeeperMock.AddDropConfirmation")
		}
		return (*results).err
	}
	if mmAddDropConfirmation.funcAddDropConfirmation != nil {
		return mmAddDropConfirmation.funcAddDropConfirmation(ctx, pn, jet, split)
	}
	mmAddDropConfirmation.t.Fatalf("Unexpected call to JetKeeperMock.AddDropConfirmation. %v %v %v %v", ctx, pn, jet, split)
	return
}

// AddDropConfirmationAfterCounter returns a count of finished JetKeeperMock.AddDropConfirmation invocations
func (mmAddDropConfirmation *JetKeeperMock) AddDropConfirmationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddDropConfirmation.afterAddDropConfirmationCounter)
}

// AddDropConfirmationBeforeCounter returns a count of JetKeeperMock.AddDropConfirmation invocations
func (mmAddDropConfirmation *JetKeeperMock) AddDropConfirmationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddDropConfirmation.beforeAddDropConfirmationCounter)
}

// Calls returns a list of arguments used in each call to JetKeeperMock.AddDropConfirmation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddDropConfirmation *mJetKeeperMockAddDropConfirmation) Calls() []*JetKeeperMockAddDropConfirmationParams {
	mmAddDropConfirmation.mutex.RLock()

	argCopy := make([]*JetKeeperMockAddDropConfirmationParams, len(mmAddDropConfirmation.callArgs))
	copy(argCopy, mmAddDropConfirmation.callArgs)

	mmAddDropConfirmation.mutex.RUnlock()

	return argCopy
}

// MinimockAddDropConfirmationDone returns true if the count of the AddDropConfirmation invocations corresponds
// the number of defined expectations
func (m *JetKeeperMock) MinimockAddDropConfirmationDone() bool {
	for _, e := range m.AddDropConfirmationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddDropConfirmationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddDropConfirmationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddDropConfirmation != nil && mm_atomic.LoadUint64(&m.afterAddDropConfirmationCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddDropConfirmationInspect logs each unmet expectation
func (m *JetKeeperMock) MinimockAddDropConfirmationInspect() {
	for _, e := range m.AddDropConfirmationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to JetKeeperMock.AddDropConfirmation with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddDropConfirmationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddDropConfirmationCounter) < 1 {
		if m.AddDropConfirmationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to JetKeeperMock.AddDropConfirmation")
		} else {
			m.t.Errorf("Expected call to JetKeeperMock.AddDropConfirmation with params: %#v", *m.AddDropConfirmationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddDropConfirmation != nil && mm_atomic.LoadUint64(&m.afterAddDropConfirmationCounter) < 1 {
		m.t.Error("Expected call to JetKeeperMock.AddDropConfirmation")
	}
}

type mJetKeeperMockAddHotConfirmation struct {
	mock               *JetKeeperMock
	defaultExpectation *JetKeeperMockAddHotConfirmationExpectation
	expectations       []*JetKeeperMockAddHotConfirmationExpectation

	callArgs []*JetKeeperMockAddHotConfirmationParams
	mutex    sync.RWMutex
}

// JetKeeperMockAddHotConfirmationExpectation specifies expectation struct of the JetKeeper.AddHotConfirmation
type JetKeeperMockAddHotConfirmationExpectation struct {
	mock    *JetKeeperMock
	params  *JetKeeperMockAddHotConfirmationParams
	results *JetKeeperMockAddHotConfirmationResults
	Counter uint64
}

// JetKeeperMockAddHotConfirmationParams contains parameters of the JetKeeper.AddHotConfirmation
type JetKeeperMockAddHotConfirmationParams struct {
	ctx   context.Context
	pn    insolar.PulseNumber
	jet   insolar.JetID
	split bool
}

// JetKeeperMockAddHotConfirmationResults contains results of the JetKeeper.AddHotConfirmation
type JetKeeperMockAddHotConfirmationResults struct {
	err error
}

// Expect sets up expected params for JetKeeper.AddHotConfirmation
func (mmAddHotConfirmation *mJetKeeperMockAddHotConfirmation) Expect(ctx context.Context, pn insolar.PulseNumber, jet insolar.JetID, split bool) *mJetKeeperMockAddHotConfirmation {
	if mmAddHotConfirmation.mock.funcAddHotConfirmation != nil {
		mmAddHotConfirmation.mock.t.Fatalf("JetKeeperMock.AddHotConfirmation mock is already set by Set")
	}

	if mmAddHotConfirmation.defaultExpectation == nil {
		mmAddHotConfirmation.defaultExpectation = &JetKeeperMockAddHotConfirmationExpectation{}
	}

	mmAddHotConfirmation.defaultExpectation.params = &JetKeeperMockAddHotConfirmationParams{ctx, pn, jet, split}
	for _, e := range mmAddHotConfirmation.expectations {
		if minimock.Equal(e.params, mmAddHotConfirmation.defaultExpectation.params) {
			mmAddHotConfirmation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddHotConfirmation.defaultExpectation.params)
		}
	}

	return mmAddHotConfirmation
}

// Inspect accepts an inspector function that has same arguments as the JetKeeper.AddHotConfirmation
func (mmAddHotConfirmation *mJetKeeperMockAddHotConfirmation) Inspect(f func(ctx context.Context, pn insolar.PulseNumber, jet insolar.JetID, split bool)) *mJetKeeperMockAddHotConfirmation {
	if mmAddHotConfirmation.mock.inspectFuncAddHotConfirmation != nil {
		mmAddHotConfirmation.mock.t.Fatalf("Inspect function is already set for JetKeeperMock.AddHotConfirmation")
	}

	mmAddHotConfirmation.mock.inspectFuncAddHotConfirmation = f

	return mmAddHotConfirmation
}

// Return sets up results that will be returned by JetKeeper.AddHotConfirmation
func (mmAddHotConfirmation *mJetKeeperMockAddHotConfirmation) Return(err error) *JetKeeperMock {
	if mmAddHotConfirmation.mock.funcAddHotConfirmation != nil {
		mmAddHotConfirmation.mock.t.Fatalf("JetKeeperMock.AddHotConfirmation mock is already set by Set")
	}

	if mmAddHotConfirmation.defaultExpectation == nil {
		mmAddHotConfirmation.defaultExpectation = &JetKeeperMockAddHotConfirmationExpectation{mock: mmAddHotConfirmation.mock}
	}
	mmAddHotConfirmation.defaultExpectation.results = &JetKeeperMockAddHotConfirmationResults{err}
	return mmAddHotConfirmation.mock
}

//Set uses given function f to mock the JetKeeper.AddHotConfirmation method
func (mmAddHotConfirmation *mJetKeeperMockAddHotConfirmation) Set(f func(ctx context.Context, pn insolar.PulseNumber, jet insolar.JetID, split bool) (err error)) *JetKeeperMock {
	if mmAddHotConfirmation.defaultExpectation != nil {
		mmAddHotConfirmation.mock.t.Fatalf("Default expectation is already set for the JetKeeper.AddHotConfirmation method")
	}

	if len(mmAddHotConfirmation.expectations) > 0 {
		mmAddHotConfirmation.mock.t.Fatalf("Some expectations are already set for the JetKeeper.AddHotConfirmation method")
	}

	mmAddHotConfirmation.mock.funcAddHotConfirmation = f
	return mmAddHotConfirmation.mock
}

// When sets expectation for the JetKeeper.AddHotConfirmation which will trigger the result defined by the following
// Then helper
func (mmAddHotConfirmation *mJetKeeperMockAddHotConfirmation) When(ctx context.Context, pn insolar.PulseNumber, jet insolar.JetID, split bool) *JetKeeperMockAddHotConfirmationExpectation {
	if mmAddHotConfirmation.mock.funcAddHotConfirmation != nil {
		mmAddHotConfirmation.mock.t.Fatalf("JetKeeperMock.AddHotConfirmation mock is already set by Set")
	}

	expectation := &JetKeeperMockAddHotConfirmationExpectation{
		mock:   mmAddHotConfirmation.mock,
		params: &JetKeeperMockAddHotConfirmationParams{ctx, pn, jet, split},
	}
	mmAddHotConfirmation.expectations = append(mmAddHotConfirmation.expectations, expectation)
	return expectation
}

// Then sets up JetKeeper.AddHotConfirmation return parameters for the expectation previously defined by the When method
func (e *JetKeeperMockAddHotConfirmationExpectation) Then(err error) *JetKeeperMock {
	e.results = &JetKeeperMockAddHotConfirmationResults{err}
	return e.mock
}

// AddHotConfirmation implements JetKeeper
func (mmAddHotConfirmation *JetKeeperMock) AddHotConfirmation(ctx context.Context, pn insolar.PulseNumber, jet insolar.JetID, split bool) (err error) {
	mm_atomic.AddUint64(&mmAddHotConfirmation.beforeAddHotConfirmationCounter, 1)
	defer mm_atomic.AddUint64(&mmAddHotConfirmation.afterAddHotConfirmationCounter, 1)

	if mmAddHotConfirmation.inspectFuncAddHotConfirmation != nil {
		mmAddHotConfirmation.inspectFuncAddHotConfirmation(ctx, pn, jet, split)
	}

	params := &JetKeeperMockAddHotConfirmationParams{ctx, pn, jet, split}

	// Record call args
	mmAddHotConfirmation.AddHotConfirmationMock.mutex.Lock()
	mmAddHotConfirmation.AddHotConfirmationMock.callArgs = append(mmAddHotConfirmation.AddHotConfirmationMock.callArgs, params)
	mmAddHotConfirmation.AddHotConfirmationMock.mutex.Unlock()

	for _, e := range mmAddHotConfirmation.AddHotConfirmationMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddHotConfirmation.AddHotConfirmationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddHotConfirmation.AddHotConfirmationMock.defaultExpectation.Counter, 1)
		want := mmAddHotConfirmation.AddHotConfirmationMock.defaultExpectation.params
		got := JetKeeperMockAddHotConfirmationParams{ctx, pn, jet, split}
		if want != nil && !minimock.Equal(*want, got) {
			mmAddHotConfirmation.t.Errorf("JetKeeperMock.AddHotConfirmation got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmAddHotConfirmation.AddHotConfirmationMock.defaultExpectation.results
		if results == nil {
			mmAddHotConfirmation.t.Fatal("No results are set for the JetKeeperMock.AddHotConfirmation")
		}
		return (*results).err
	}
	if mmAddHotConfirmation.funcAddHotConfirmation != nil {
		return mmAddHotConfirmation.funcAddHotConfirmation(ctx, pn, jet, split)
	}
	mmAddHotConfirmation.t.Fatalf("Unexpected call to JetKeeperMock.AddHotConfirmation. %v %v %v %v", ctx, pn, jet, split)
	return
}

// AddHotConfirmationAfterCounter returns a count of finished JetKeeperMock.AddHotConfirmation invocations
func (mmAddHotConfirmation *JetKeeperMock) AddHotConfirmationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddHotConfirmation.afterAddHotConfirmationCounter)
}

// AddHotConfirmationBeforeCounter returns a count of JetKeeperMock.AddHotConfirmation invocations
func (mmAddHotConfirmation *JetKeeperMock) AddHotConfirmationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddHotConfirmation.beforeAddHotConfirmationCounter)
}

// Calls returns a list of arguments used in each call to JetKeeperMock.AddHotConfirmation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddHotConfirmation *mJetKeeperMockAddHotConfirmation) Calls() []*JetKeeperMockAddHotConfirmationParams {
	mmAddHotConfirmation.mutex.RLock()

	argCopy := make([]*JetKeeperMockAddHotConfirmationParams, len(mmAddHotConfirmation.callArgs))
	copy(argCopy, mmAddHotConfirmation.callArgs)

	mmAddHotConfirmation.mutex.RUnlock()

	return argCopy
}

// MinimockAddHotConfirmationDone returns true if the count of the AddHotConfirmation invocations corresponds
// the number of defined expectations
func (m *JetKeeperMock) MinimockAddHotConfirmationDone() bool {
	for _, e := range m.AddHotConfirmationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddHotConfirmationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddHotConfirmationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddHotConfirmation != nil && mm_atomic.LoadUint64(&m.afterAddHotConfirmationCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddHotConfirmationInspect logs each unmet expectation
func (m *JetKeeperMock) MinimockAddHotConfirmationInspect() {
	for _, e := range m.AddHotConfirmationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to JetKeeperMock.AddHotConfirmation with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddHotConfirmationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddHotConfirmationCounter) < 1 {
		if m.AddHotConfirmationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to JetKeeperMock.AddHotConfirmation")
		} else {
			m.t.Errorf("Expected call to JetKeeperMock.AddHotConfirmation with params: %#v", *m.AddHotConfirmationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddHotConfirmation != nil && mm_atomic.LoadUint64(&m.afterAddHotConfirmationCounter) < 1 {
		m.t.Error("Expected call to JetKeeperMock.AddHotConfirmation")
	}
}

type mJetKeeperMockTopSyncPulse struct {
	mock               *JetKeeperMock
	defaultExpectation *JetKeeperMockTopSyncPulseExpectation
	expectations       []*JetKeeperMockTopSyncPulseExpectation
}

// JetKeeperMockTopSyncPulseExpectation specifies expectation struct of the JetKeeper.TopSyncPulse
type JetKeeperMockTopSyncPulseExpectation struct {
	mock *JetKeeperMock

	results *JetKeeperMockTopSyncPulseResults
	Counter uint64
}

// JetKeeperMockTopSyncPulseResults contains results of the JetKeeper.TopSyncPulse
type JetKeeperMockTopSyncPulseResults struct {
	p1 insolar.PulseNumber
}

// Expect sets up expected params for JetKeeper.TopSyncPulse
func (mmTopSyncPulse *mJetKeeperMockTopSyncPulse) Expect() *mJetKeeperMockTopSyncPulse {
	if mmTopSyncPulse.mock.funcTopSyncPulse != nil {
		mmTopSyncPulse.mock.t.Fatalf("JetKeeperMock.TopSyncPulse mock is already set by Set")
	}

	if mmTopSyncPulse.defaultExpectation == nil {
		mmTopSyncPulse.defaultExpectation = &JetKeeperMockTopSyncPulseExpectation{}
	}

	return mmTopSyncPulse
}

// Inspect accepts an inspector function that has same arguments as the JetKeeper.TopSyncPulse
func (mmTopSyncPulse *mJetKeeperMockTopSyncPulse) Inspect(f func()) *mJetKeeperMockTopSyncPulse {
	if mmTopSyncPulse.mock.inspectFuncTopSyncPulse != nil {
		mmTopSyncPulse.mock.t.Fatalf("Inspect function is already set for JetKeeperMock.TopSyncPulse")
	}

	mmTopSyncPulse.mock.inspectFuncTopSyncPulse = f

	return mmTopSyncPulse
}

// Return sets up results that will be returned by JetKeeper.TopSyncPulse
func (mmTopSyncPulse *mJetKeeperMockTopSyncPulse) Return(p1 insolar.PulseNumber) *JetKeeperMock {
	if mmTopSyncPulse.mock.funcTopSyncPulse != nil {
		mmTopSyncPulse.mock.t.Fatalf("JetKeeperMock.TopSyncPulse mock is already set by Set")
	}

	if mmTopSyncPulse.defaultExpectation == nil {
		mmTopSyncPulse.defaultExpectation = &JetKeeperMockTopSyncPulseExpectation{mock: mmTopSyncPulse.mock}
	}
	mmTopSyncPulse.defaultExpectation.results = &JetKeeperMockTopSyncPulseResults{p1}
	return mmTopSyncPulse.mock
}

//Set uses given function f to mock the JetKeeper.TopSyncPulse method
func (mmTopSyncPulse *mJetKeeperMockTopSyncPulse) Set(f func() (p1 insolar.PulseNumber)) *JetKeeperMock {
	if mmTopSyncPulse.defaultExpectation != nil {
		mmTopSyncPulse.mock.t.Fatalf("Default expectation is already set for the JetKeeper.TopSyncPulse method")
	}

	if len(mmTopSyncPulse.expectations) > 0 {
		mmTopSyncPulse.mock.t.Fatalf("Some expectations are already set for the JetKeeper.TopSyncPulse method")
	}

	mmTopSyncPulse.mock.funcTopSyncPulse = f
	return mmTopSyncPulse.mock
}

// TopSyncPulse implements JetKeeper
func (mmTopSyncPulse *JetKeeperMock) TopSyncPulse() (p1 insolar.PulseNumber) {
	mm_atomic.AddUint64(&mmTopSyncPulse.beforeTopSyncPulseCounter, 1)
	defer mm_atomic.AddUint64(&mmTopSyncPulse.afterTopSyncPulseCounter, 1)

	if mmTopSyncPulse.inspectFuncTopSyncPulse != nil {
		mmTopSyncPulse.inspectFuncTopSyncPulse()
	}

	if mmTopSyncPulse.TopSyncPulseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTopSyncPulse.TopSyncPulseMock.defaultExpectation.Counter, 1)

		results := mmTopSyncPulse.TopSyncPulseMock.defaultExpectation.results
		if results == nil {
			mmTopSyncPulse.t.Fatal("No results are set for the JetKeeperMock.TopSyncPulse")
		}
		return (*results).p1
	}
	if mmTopSyncPulse.funcTopSyncPulse != nil {
		return mmTopSyncPulse.funcTopSyncPulse()
	}
	mmTopSyncPulse.t.Fatalf("Unexpected call to JetKeeperMock.TopSyncPulse.")
	return
}

// TopSyncPulseAfterCounter returns a count of finished JetKeeperMock.TopSyncPulse invocations
func (mmTopSyncPulse *JetKeeperMock) TopSyncPulseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTopSyncPulse.afterTopSyncPulseCounter)
}

// TopSyncPulseBeforeCounter returns a count of JetKeeperMock.TopSyncPulse invocations
func (mmTopSyncPulse *JetKeeperMock) TopSyncPulseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTopSyncPulse.beforeTopSyncPulseCounter)
}

// MinimockTopSyncPulseDone returns true if the count of the TopSyncPulse invocations corresponds
// the number of defined expectations
func (m *JetKeeperMock) MinimockTopSyncPulseDone() bool {
	for _, e := range m.TopSyncPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TopSyncPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTopSyncPulseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTopSyncPulse != nil && mm_atomic.LoadUint64(&m.afterTopSyncPulseCounter) < 1 {
		return false
	}
	return true
}

// MinimockTopSyncPulseInspect logs each unmet expectation
func (m *JetKeeperMock) MinimockTopSyncPulseInspect() {
	for _, e := range m.TopSyncPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to JetKeeperMock.TopSyncPulse")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TopSyncPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTopSyncPulseCounter) < 1 {
		m.t.Error("Expected call to JetKeeperMock.TopSyncPulse")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTopSyncPulse != nil && mm_atomic.LoadUint64(&m.afterTopSyncPulseCounter) < 1 {
		m.t.Error("Expected call to JetKeeperMock.TopSyncPulse")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *JetKeeperMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddDropConfirmationInspect()

		m.MinimockAddHotConfirmationInspect()

		m.MinimockTopSyncPulseInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *JetKeeperMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *JetKeeperMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddDropConfirmationDone() &&
		m.MinimockAddHotConfirmationDone() &&
		m.MinimockTopSyncPulseDone()
}
