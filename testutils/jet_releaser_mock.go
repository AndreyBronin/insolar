package testutils

// Code generated by http://github.com/gojuno/minimock (3.0.0). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/insolar/insolar"
)

// JetReleaserMock implements hot.JetReleaser
type JetReleaserMock struct {
	t minimock.Tester

	funcThrowTimeout          func(ctx context.Context, pulse insolar.PulseNumber)
	inspectFuncThrowTimeout   func(ctx context.Context, pulse insolar.PulseNumber)
	afterThrowTimeoutCounter  uint64
	beforeThrowTimeoutCounter uint64
	ThrowTimeoutMock          mJetReleaserMockThrowTimeout

	funcUnlock          func(ctx context.Context, jetID insolar.ID) (err error)
	inspectFuncUnlock   func(ctx context.Context, jetID insolar.ID)
	afterUnlockCounter  uint64
	beforeUnlockCounter uint64
	UnlockMock          mJetReleaserMockUnlock
}

// NewJetReleaserMock returns a mock for hot.JetReleaser
func NewJetReleaserMock(t minimock.Tester) *JetReleaserMock {
	m := &JetReleaserMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ThrowTimeoutMock = mJetReleaserMockThrowTimeout{mock: m}
	m.ThrowTimeoutMock.callArgs = []*JetReleaserMockThrowTimeoutParams{}

	m.UnlockMock = mJetReleaserMockUnlock{mock: m}
	m.UnlockMock.callArgs = []*JetReleaserMockUnlockParams{}

	return m
}

type mJetReleaserMockThrowTimeout struct {
	mock               *JetReleaserMock
	defaultExpectation *JetReleaserMockThrowTimeoutExpectation
	expectations       []*JetReleaserMockThrowTimeoutExpectation

	callArgs []*JetReleaserMockThrowTimeoutParams
	mutex    sync.RWMutex
}

// JetReleaserMockThrowTimeoutExpectation specifies expectation struct of the JetReleaser.ThrowTimeout
type JetReleaserMockThrowTimeoutExpectation struct {
	mock   *JetReleaserMock
	params *JetReleaserMockThrowTimeoutParams

	Counter uint64
}

// JetReleaserMockThrowTimeoutParams contains parameters of the JetReleaser.ThrowTimeout
type JetReleaserMockThrowTimeoutParams struct {
	ctx   context.Context
	pulse insolar.PulseNumber
}

// Expect sets up expected params for JetReleaser.ThrowTimeout
func (mmThrowTimeout *mJetReleaserMockThrowTimeout) Expect(ctx context.Context, pulse insolar.PulseNumber) *mJetReleaserMockThrowTimeout {
	if mmThrowTimeout.mock.funcThrowTimeout != nil {
		mmThrowTimeout.mock.t.Fatalf("JetReleaserMock.ThrowTimeout mock is already set by Set")
	}

	if mmThrowTimeout.defaultExpectation == nil {
		mmThrowTimeout.defaultExpectation = &JetReleaserMockThrowTimeoutExpectation{}
	}

	mmThrowTimeout.defaultExpectation.params = &JetReleaserMockThrowTimeoutParams{ctx, pulse}
	for _, e := range mmThrowTimeout.expectations {
		if minimock.Equal(e.params, mmThrowTimeout.defaultExpectation.params) {
			mmThrowTimeout.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmThrowTimeout.defaultExpectation.params)
		}
	}

	return mmThrowTimeout
}

// Inspect accepts an inspector function that has same arguments as the JetReleaser.ThrowTimeout
func (mmThrowTimeout *mJetReleaserMockThrowTimeout) Inspect(f func(ctx context.Context, pulse insolar.PulseNumber)) *mJetReleaserMockThrowTimeout {
	if mmThrowTimeout.mock.inspectFuncThrowTimeout != nil {
		mmThrowTimeout.mock.t.Fatalf("Inspect function is already set for JetReleaserMock.ThrowTimeout")
	}

	mmThrowTimeout.mock.inspectFuncThrowTimeout = f

	return mmThrowTimeout
}

// Return sets up results that will be returned by JetReleaser.ThrowTimeout
func (mmThrowTimeout *mJetReleaserMockThrowTimeout) Return() *JetReleaserMock {
	if mmThrowTimeout.mock.funcThrowTimeout != nil {
		mmThrowTimeout.mock.t.Fatalf("JetReleaserMock.ThrowTimeout mock is already set by Set")
	}

	if mmThrowTimeout.defaultExpectation == nil {
		mmThrowTimeout.defaultExpectation = &JetReleaserMockThrowTimeoutExpectation{mock: mmThrowTimeout.mock}
	}

	return mmThrowTimeout.mock
}

//Set uses given function f to mock the JetReleaser.ThrowTimeout method
func (mmThrowTimeout *mJetReleaserMockThrowTimeout) Set(f func(ctx context.Context, pulse insolar.PulseNumber)) *JetReleaserMock {
	if mmThrowTimeout.defaultExpectation != nil {
		mmThrowTimeout.mock.t.Fatalf("Default expectation is already set for the JetReleaser.ThrowTimeout method")
	}

	if len(mmThrowTimeout.expectations) > 0 {
		mmThrowTimeout.mock.t.Fatalf("Some expectations are already set for the JetReleaser.ThrowTimeout method")
	}

	mmThrowTimeout.mock.funcThrowTimeout = f
	return mmThrowTimeout.mock
}

// ThrowTimeout implements hot.JetReleaser
func (mmThrowTimeout *JetReleaserMock) ThrowTimeout(ctx context.Context, pulse insolar.PulseNumber) {
	mm_atomic.AddUint64(&mmThrowTimeout.beforeThrowTimeoutCounter, 1)
	defer mm_atomic.AddUint64(&mmThrowTimeout.afterThrowTimeoutCounter, 1)

	if mmThrowTimeout.inspectFuncThrowTimeout != nil {
		mmThrowTimeout.inspectFuncThrowTimeout(ctx, pulse)
	}

	params := &JetReleaserMockThrowTimeoutParams{ctx, pulse}

	// Record call args
	mmThrowTimeout.ThrowTimeoutMock.mutex.Lock()
	mmThrowTimeout.ThrowTimeoutMock.callArgs = append(mmThrowTimeout.ThrowTimeoutMock.callArgs, params)
	mmThrowTimeout.ThrowTimeoutMock.mutex.Unlock()

	for _, e := range mmThrowTimeout.ThrowTimeoutMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmThrowTimeout.ThrowTimeoutMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmThrowTimeout.ThrowTimeoutMock.defaultExpectation.Counter, 1)
		want := mmThrowTimeout.ThrowTimeoutMock.defaultExpectation.params
		got := JetReleaserMockThrowTimeoutParams{ctx, pulse}
		if want != nil && !minimock.Equal(*want, got) {
			mmThrowTimeout.t.Errorf("JetReleaserMock.ThrowTimeout got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmThrowTimeout.funcThrowTimeout != nil {
		mmThrowTimeout.funcThrowTimeout(ctx, pulse)
		return
	}
	mmThrowTimeout.t.Fatalf("Unexpected call to JetReleaserMock.ThrowTimeout. %v %v", ctx, pulse)

}

// ThrowTimeoutAfterCounter returns a count of finished JetReleaserMock.ThrowTimeout invocations
func (mmThrowTimeout *JetReleaserMock) ThrowTimeoutAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmThrowTimeout.afterThrowTimeoutCounter)
}

// ThrowTimeoutBeforeCounter returns a count of JetReleaserMock.ThrowTimeout invocations
func (mmThrowTimeout *JetReleaserMock) ThrowTimeoutBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmThrowTimeout.beforeThrowTimeoutCounter)
}

// Calls returns a list of arguments used in each call to JetReleaserMock.ThrowTimeout.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmThrowTimeout *mJetReleaserMockThrowTimeout) Calls() []*JetReleaserMockThrowTimeoutParams {
	mmThrowTimeout.mutex.RLock()

	argCopy := make([]*JetReleaserMockThrowTimeoutParams, len(mmThrowTimeout.callArgs))
	copy(argCopy, mmThrowTimeout.callArgs)

	mmThrowTimeout.mutex.RUnlock()

	return argCopy
}

// MinimockThrowTimeoutDone returns true if the count of the ThrowTimeout invocations corresponds
// the number of defined expectations
func (m *JetReleaserMock) MinimockThrowTimeoutDone() bool {
	for _, e := range m.ThrowTimeoutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ThrowTimeoutMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterThrowTimeoutCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcThrowTimeout != nil && mm_atomic.LoadUint64(&m.afterThrowTimeoutCounter) < 1 {
		return false
	}
	return true
}

// MinimockThrowTimeoutInspect logs each unmet expectation
func (m *JetReleaserMock) MinimockThrowTimeoutInspect() {
	for _, e := range m.ThrowTimeoutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to JetReleaserMock.ThrowTimeout with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ThrowTimeoutMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterThrowTimeoutCounter) < 1 {
		if m.ThrowTimeoutMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to JetReleaserMock.ThrowTimeout")
		} else {
			m.t.Errorf("Expected call to JetReleaserMock.ThrowTimeout with params: %#v", *m.ThrowTimeoutMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcThrowTimeout != nil && mm_atomic.LoadUint64(&m.afterThrowTimeoutCounter) < 1 {
		m.t.Error("Expected call to JetReleaserMock.ThrowTimeout")
	}
}

type mJetReleaserMockUnlock struct {
	mock               *JetReleaserMock
	defaultExpectation *JetReleaserMockUnlockExpectation
	expectations       []*JetReleaserMockUnlockExpectation

	callArgs []*JetReleaserMockUnlockParams
	mutex    sync.RWMutex
}

// JetReleaserMockUnlockExpectation specifies expectation struct of the JetReleaser.Unlock
type JetReleaserMockUnlockExpectation struct {
	mock    *JetReleaserMock
	params  *JetReleaserMockUnlockParams
	results *JetReleaserMockUnlockResults
	Counter uint64
}

// JetReleaserMockUnlockParams contains parameters of the JetReleaser.Unlock
type JetReleaserMockUnlockParams struct {
	ctx   context.Context
	jetID insolar.ID
}

// JetReleaserMockUnlockResults contains results of the JetReleaser.Unlock
type JetReleaserMockUnlockResults struct {
	err error
}

// Expect sets up expected params for JetReleaser.Unlock
func (mmUnlock *mJetReleaserMockUnlock) Expect(ctx context.Context, jetID insolar.ID) *mJetReleaserMockUnlock {
	if mmUnlock.mock.funcUnlock != nil {
		mmUnlock.mock.t.Fatalf("JetReleaserMock.Unlock mock is already set by Set")
	}

	if mmUnlock.defaultExpectation == nil {
		mmUnlock.defaultExpectation = &JetReleaserMockUnlockExpectation{}
	}

	mmUnlock.defaultExpectation.params = &JetReleaserMockUnlockParams{ctx, jetID}
	for _, e := range mmUnlock.expectations {
		if minimock.Equal(e.params, mmUnlock.defaultExpectation.params) {
			mmUnlock.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUnlock.defaultExpectation.params)
		}
	}

	return mmUnlock
}

// Inspect accepts an inspector function that has same arguments as the JetReleaser.Unlock
func (mmUnlock *mJetReleaserMockUnlock) Inspect(f func(ctx context.Context, jetID insolar.ID)) *mJetReleaserMockUnlock {
	if mmUnlock.mock.inspectFuncUnlock != nil {
		mmUnlock.mock.t.Fatalf("Inspect function is already set for JetReleaserMock.Unlock")
	}

	mmUnlock.mock.inspectFuncUnlock = f

	return mmUnlock
}

// Return sets up results that will be returned by JetReleaser.Unlock
func (mmUnlock *mJetReleaserMockUnlock) Return(err error) *JetReleaserMock {
	if mmUnlock.mock.funcUnlock != nil {
		mmUnlock.mock.t.Fatalf("JetReleaserMock.Unlock mock is already set by Set")
	}

	if mmUnlock.defaultExpectation == nil {
		mmUnlock.defaultExpectation = &JetReleaserMockUnlockExpectation{mock: mmUnlock.mock}
	}
	mmUnlock.defaultExpectation.results = &JetReleaserMockUnlockResults{err}
	return mmUnlock.mock
}

//Set uses given function f to mock the JetReleaser.Unlock method
func (mmUnlock *mJetReleaserMockUnlock) Set(f func(ctx context.Context, jetID insolar.ID) (err error)) *JetReleaserMock {
	if mmUnlock.defaultExpectation != nil {
		mmUnlock.mock.t.Fatalf("Default expectation is already set for the JetReleaser.Unlock method")
	}

	if len(mmUnlock.expectations) > 0 {
		mmUnlock.mock.t.Fatalf("Some expectations are already set for the JetReleaser.Unlock method")
	}

	mmUnlock.mock.funcUnlock = f
	return mmUnlock.mock
}

// When sets expectation for the JetReleaser.Unlock which will trigger the result defined by the following
// Then helper
func (mmUnlock *mJetReleaserMockUnlock) When(ctx context.Context, jetID insolar.ID) *JetReleaserMockUnlockExpectation {
	if mmUnlock.mock.funcUnlock != nil {
		mmUnlock.mock.t.Fatalf("JetReleaserMock.Unlock mock is already set by Set")
	}

	expectation := &JetReleaserMockUnlockExpectation{
		mock:   mmUnlock.mock,
		params: &JetReleaserMockUnlockParams{ctx, jetID},
	}
	mmUnlock.expectations = append(mmUnlock.expectations, expectation)
	return expectation
}

// Then sets up JetReleaser.Unlock return parameters for the expectation previously defined by the When method
func (e *JetReleaserMockUnlockExpectation) Then(err error) *JetReleaserMock {
	e.results = &JetReleaserMockUnlockResults{err}
	return e.mock
}

// Unlock implements hot.JetReleaser
func (mmUnlock *JetReleaserMock) Unlock(ctx context.Context, jetID insolar.ID) (err error) {
	mm_atomic.AddUint64(&mmUnlock.beforeUnlockCounter, 1)
	defer mm_atomic.AddUint64(&mmUnlock.afterUnlockCounter, 1)

	if mmUnlock.inspectFuncUnlock != nil {
		mmUnlock.inspectFuncUnlock(ctx, jetID)
	}

	params := &JetReleaserMockUnlockParams{ctx, jetID}

	// Record call args
	mmUnlock.UnlockMock.mutex.Lock()
	mmUnlock.UnlockMock.callArgs = append(mmUnlock.UnlockMock.callArgs, params)
	mmUnlock.UnlockMock.mutex.Unlock()

	for _, e := range mmUnlock.UnlockMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUnlock.UnlockMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnlock.UnlockMock.defaultExpectation.Counter, 1)
		want := mmUnlock.UnlockMock.defaultExpectation.params
		got := JetReleaserMockUnlockParams{ctx, jetID}
		if want != nil && !minimock.Equal(*want, got) {
			mmUnlock.t.Errorf("JetReleaserMock.Unlock got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmUnlock.UnlockMock.defaultExpectation.results
		if results == nil {
			mmUnlock.t.Fatal("No results are set for the JetReleaserMock.Unlock")
		}
		return (*results).err
	}
	if mmUnlock.funcUnlock != nil {
		return mmUnlock.funcUnlock(ctx, jetID)
	}
	mmUnlock.t.Fatalf("Unexpected call to JetReleaserMock.Unlock. %v %v", ctx, jetID)
	return
}

// UnlockAfterCounter returns a count of finished JetReleaserMock.Unlock invocations
func (mmUnlock *JetReleaserMock) UnlockAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnlock.afterUnlockCounter)
}

// UnlockBeforeCounter returns a count of JetReleaserMock.Unlock invocations
func (mmUnlock *JetReleaserMock) UnlockBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnlock.beforeUnlockCounter)
}

// Calls returns a list of arguments used in each call to JetReleaserMock.Unlock.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUnlock *mJetReleaserMockUnlock) Calls() []*JetReleaserMockUnlockParams {
	mmUnlock.mutex.RLock()

	argCopy := make([]*JetReleaserMockUnlockParams, len(mmUnlock.callArgs))
	copy(argCopy, mmUnlock.callArgs)

	mmUnlock.mutex.RUnlock()

	return argCopy
}

// MinimockUnlockDone returns true if the count of the Unlock invocations corresponds
// the number of defined expectations
func (m *JetReleaserMock) MinimockUnlockDone() bool {
	for _, e := range m.UnlockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnlockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnlockCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnlock != nil && mm_atomic.LoadUint64(&m.afterUnlockCounter) < 1 {
		return false
	}
	return true
}

// MinimockUnlockInspect logs each unmet expectation
func (m *JetReleaserMock) MinimockUnlockInspect() {
	for _, e := range m.UnlockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to JetReleaserMock.Unlock with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnlockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnlockCounter) < 1 {
		if m.UnlockMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to JetReleaserMock.Unlock")
		} else {
			m.t.Errorf("Expected call to JetReleaserMock.Unlock with params: %#v", *m.UnlockMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnlock != nil && mm_atomic.LoadUint64(&m.afterUnlockCounter) < 1 {
		m.t.Error("Expected call to JetReleaserMock.Unlock")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *JetReleaserMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockThrowTimeoutInspect()

		m.MinimockUnlockInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *JetReleaserMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *JetReleaserMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockThrowTimeoutDone() &&
		m.MinimockUnlockDone()
}
