package testutils

// Code generated by http://github.com/gojuno/minimock (3.0.0). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_insolar "github.com/insolar/insolar/insolar"
)

// ContractRequesterMock implements insolar.ContractRequester
type ContractRequesterMock struct {
	t minimock.Tester

	funcCall          func(ctx context.Context, msg mm_insolar.Message) (r1 mm_insolar.Reply, err error)
	inspectFuncCall   func(ctx context.Context, msg mm_insolar.Message)
	afterCallCounter  uint64
	beforeCallCounter uint64
	CallMock          mContractRequesterMockCall

	funcCallConstructor          func(ctx context.Context, msg mm_insolar.Message) (ref *mm_insolar.Reference, ctorErr string, err error)
	inspectFuncCallConstructor   func(ctx context.Context, msg mm_insolar.Message)
	afterCallConstructorCounter  uint64
	beforeCallConstructorCounter uint64
	CallConstructorMock          mContractRequesterMockCallConstructor

	funcCallMethod          func(ctx context.Context, msg mm_insolar.Message) (r1 mm_insolar.Reply, err error)
	inspectFuncCallMethod   func(ctx context.Context, msg mm_insolar.Message)
	afterCallMethodCounter  uint64
	beforeCallMethodCounter uint64
	CallMethodMock          mContractRequesterMockCallMethod

	funcSendRequest          func(ctx context.Context, ref *mm_insolar.Reference, method string, argsIn []interface{}) (r1 mm_insolar.Reply, err error)
	inspectFuncSendRequest   func(ctx context.Context, ref *mm_insolar.Reference, method string, argsIn []interface{})
	afterSendRequestCounter  uint64
	beforeSendRequestCounter uint64
	SendRequestMock          mContractRequesterMockSendRequest

	funcSendRequestWithPulse          func(ctx context.Context, ref *mm_insolar.Reference, method string, argsIn []interface{}, pulse mm_insolar.PulseNumber) (r1 mm_insolar.Reply, err error)
	inspectFuncSendRequestWithPulse   func(ctx context.Context, ref *mm_insolar.Reference, method string, argsIn []interface{}, pulse mm_insolar.PulseNumber)
	afterSendRequestWithPulseCounter  uint64
	beforeSendRequestWithPulseCounter uint64
	SendRequestWithPulseMock          mContractRequesterMockSendRequestWithPulse
}

// NewContractRequesterMock returns a mock for insolar.ContractRequester
func NewContractRequesterMock(t minimock.Tester) *ContractRequesterMock {
	m := &ContractRequesterMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CallMock = mContractRequesterMockCall{mock: m}
	m.CallMock.callArgs = []*ContractRequesterMockCallParams{}

	m.CallConstructorMock = mContractRequesterMockCallConstructor{mock: m}
	m.CallConstructorMock.callArgs = []*ContractRequesterMockCallConstructorParams{}

	m.CallMethodMock = mContractRequesterMockCallMethod{mock: m}
	m.CallMethodMock.callArgs = []*ContractRequesterMockCallMethodParams{}

	m.SendRequestMock = mContractRequesterMockSendRequest{mock: m}
	m.SendRequestMock.callArgs = []*ContractRequesterMockSendRequestParams{}

	m.SendRequestWithPulseMock = mContractRequesterMockSendRequestWithPulse{mock: m}
	m.SendRequestWithPulseMock.callArgs = []*ContractRequesterMockSendRequestWithPulseParams{}

	return m
}

type mContractRequesterMockCall struct {
	mock               *ContractRequesterMock
	defaultExpectation *ContractRequesterMockCallExpectation
	expectations       []*ContractRequesterMockCallExpectation

	callArgs []*ContractRequesterMockCallParams
	mutex    sync.RWMutex
}

// ContractRequesterMockCallExpectation specifies expectation struct of the ContractRequester.Call
type ContractRequesterMockCallExpectation struct {
	mock    *ContractRequesterMock
	params  *ContractRequesterMockCallParams
	results *ContractRequesterMockCallResults
	Counter uint64
}

// ContractRequesterMockCallParams contains parameters of the ContractRequester.Call
type ContractRequesterMockCallParams struct {
	ctx context.Context
	msg mm_insolar.Message
}

// ContractRequesterMockCallResults contains results of the ContractRequester.Call
type ContractRequesterMockCallResults struct {
	r1  mm_insolar.Reply
	err error
}

// Expect sets up expected params for ContractRequester.Call
func (mmCall *mContractRequesterMockCall) Expect(ctx context.Context, msg mm_insolar.Message) *mContractRequesterMockCall {
	if mmCall.mock.funcCall != nil {
		mmCall.mock.t.Fatalf("ContractRequesterMock.Call mock is already set by Set")
	}

	if mmCall.defaultExpectation == nil {
		mmCall.defaultExpectation = &ContractRequesterMockCallExpectation{}
	}

	mmCall.defaultExpectation.params = &ContractRequesterMockCallParams{ctx, msg}
	for _, e := range mmCall.expectations {
		if minimock.Equal(e.params, mmCall.defaultExpectation.params) {
			mmCall.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCall.defaultExpectation.params)
		}
	}

	return mmCall
}

// Inspect accepts an inspector function that has same arguments as the ContractRequester.Call
func (mmCall *mContractRequesterMockCall) Inspect(f func(ctx context.Context, msg mm_insolar.Message)) *mContractRequesterMockCall {
	if mmCall.mock.inspectFuncCall != nil {
		mmCall.mock.t.Fatalf("Inspect function is already set for ContractRequesterMock.Call")
	}

	mmCall.mock.inspectFuncCall = f

	return mmCall
}

// Return sets up results that will be returned by ContractRequester.Call
func (mmCall *mContractRequesterMockCall) Return(r1 mm_insolar.Reply, err error) *ContractRequesterMock {
	if mmCall.mock.funcCall != nil {
		mmCall.mock.t.Fatalf("ContractRequesterMock.Call mock is already set by Set")
	}

	if mmCall.defaultExpectation == nil {
		mmCall.defaultExpectation = &ContractRequesterMockCallExpectation{mock: mmCall.mock}
	}
	mmCall.defaultExpectation.results = &ContractRequesterMockCallResults{r1, err}
	return mmCall.mock
}

//Set uses given function f to mock the ContractRequester.Call method
func (mmCall *mContractRequesterMockCall) Set(f func(ctx context.Context, msg mm_insolar.Message) (r1 mm_insolar.Reply, err error)) *ContractRequesterMock {
	if mmCall.defaultExpectation != nil {
		mmCall.mock.t.Fatalf("Default expectation is already set for the ContractRequester.Call method")
	}

	if len(mmCall.expectations) > 0 {
		mmCall.mock.t.Fatalf("Some expectations are already set for the ContractRequester.Call method")
	}

	mmCall.mock.funcCall = f
	return mmCall.mock
}

// When sets expectation for the ContractRequester.Call which will trigger the result defined by the following
// Then helper
func (mmCall *mContractRequesterMockCall) When(ctx context.Context, msg mm_insolar.Message) *ContractRequesterMockCallExpectation {
	if mmCall.mock.funcCall != nil {
		mmCall.mock.t.Fatalf("ContractRequesterMock.Call mock is already set by Set")
	}

	expectation := &ContractRequesterMockCallExpectation{
		mock:   mmCall.mock,
		params: &ContractRequesterMockCallParams{ctx, msg},
	}
	mmCall.expectations = append(mmCall.expectations, expectation)
	return expectation
}

// Then sets up ContractRequester.Call return parameters for the expectation previously defined by the When method
func (e *ContractRequesterMockCallExpectation) Then(r1 mm_insolar.Reply, err error) *ContractRequesterMock {
	e.results = &ContractRequesterMockCallResults{r1, err}
	return e.mock
}

// Call implements insolar.ContractRequester
func (mmCall *ContractRequesterMock) Call(ctx context.Context, msg mm_insolar.Message) (r1 mm_insolar.Reply, err error) {
	mm_atomic.AddUint64(&mmCall.beforeCallCounter, 1)
	defer mm_atomic.AddUint64(&mmCall.afterCallCounter, 1)

	if mmCall.inspectFuncCall != nil {
		mmCall.inspectFuncCall(ctx, msg)
	}

	params := &ContractRequesterMockCallParams{ctx, msg}

	// Record call args
	mmCall.CallMock.mutex.Lock()
	mmCall.CallMock.callArgs = append(mmCall.CallMock.callArgs, params)
	mmCall.CallMock.mutex.Unlock()

	for _, e := range mmCall.CallMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmCall.CallMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCall.CallMock.defaultExpectation.Counter, 1)
		want := mmCall.CallMock.defaultExpectation.params
		got := ContractRequesterMockCallParams{ctx, msg}
		if want != nil && !minimock.Equal(*want, got) {
			mmCall.t.Errorf("ContractRequesterMock.Call got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmCall.CallMock.defaultExpectation.results
		if results == nil {
			mmCall.t.Fatal("No results are set for the ContractRequesterMock.Call")
		}
		return (*results).r1, (*results).err
	}
	if mmCall.funcCall != nil {
		return mmCall.funcCall(ctx, msg)
	}
	mmCall.t.Fatalf("Unexpected call to ContractRequesterMock.Call. %v %v", ctx, msg)
	return
}

// CallAfterCounter returns a count of finished ContractRequesterMock.Call invocations
func (mmCall *ContractRequesterMock) CallAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCall.afterCallCounter)
}

// CallBeforeCounter returns a count of ContractRequesterMock.Call invocations
func (mmCall *ContractRequesterMock) CallBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCall.beforeCallCounter)
}

// Calls returns a list of arguments used in each call to ContractRequesterMock.Call.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCall *mContractRequesterMockCall) Calls() []*ContractRequesterMockCallParams {
	mmCall.mutex.RLock()

	argCopy := make([]*ContractRequesterMockCallParams, len(mmCall.callArgs))
	copy(argCopy, mmCall.callArgs)

	mmCall.mutex.RUnlock()

	return argCopy
}

// MinimockCallDone returns true if the count of the Call invocations corresponds
// the number of defined expectations
func (m *ContractRequesterMock) MinimockCallDone() bool {
	for _, e := range m.CallMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CallMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCallCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCall != nil && mm_atomic.LoadUint64(&m.afterCallCounter) < 1 {
		return false
	}
	return true
}

// MinimockCallInspect logs each unmet expectation
func (m *ContractRequesterMock) MinimockCallInspect() {
	for _, e := range m.CallMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContractRequesterMock.Call with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CallMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCallCounter) < 1 {
		if m.CallMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ContractRequesterMock.Call")
		} else {
			m.t.Errorf("Expected call to ContractRequesterMock.Call with params: %#v", *m.CallMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCall != nil && mm_atomic.LoadUint64(&m.afterCallCounter) < 1 {
		m.t.Error("Expected call to ContractRequesterMock.Call")
	}
}

type mContractRequesterMockCallConstructor struct {
	mock               *ContractRequesterMock
	defaultExpectation *ContractRequesterMockCallConstructorExpectation
	expectations       []*ContractRequesterMockCallConstructorExpectation

	callArgs []*ContractRequesterMockCallConstructorParams
	mutex    sync.RWMutex
}

// ContractRequesterMockCallConstructorExpectation specifies expectation struct of the ContractRequester.CallConstructor
type ContractRequesterMockCallConstructorExpectation struct {
	mock    *ContractRequesterMock
	params  *ContractRequesterMockCallConstructorParams
	results *ContractRequesterMockCallConstructorResults
	Counter uint64
}

// ContractRequesterMockCallConstructorParams contains parameters of the ContractRequester.CallConstructor
type ContractRequesterMockCallConstructorParams struct {
	ctx context.Context
	msg mm_insolar.Message
}

// ContractRequesterMockCallConstructorResults contains results of the ContractRequester.CallConstructor
type ContractRequesterMockCallConstructorResults struct {
	ref     *mm_insolar.Reference
	ctorErr string
	err     error
}

// Expect sets up expected params for ContractRequester.CallConstructor
func (mmCallConstructor *mContractRequesterMockCallConstructor) Expect(ctx context.Context, msg mm_insolar.Message) *mContractRequesterMockCallConstructor {
	if mmCallConstructor.mock.funcCallConstructor != nil {
		mmCallConstructor.mock.t.Fatalf("ContractRequesterMock.CallConstructor mock is already set by Set")
	}

	if mmCallConstructor.defaultExpectation == nil {
		mmCallConstructor.defaultExpectation = &ContractRequesterMockCallConstructorExpectation{}
	}

	mmCallConstructor.defaultExpectation.params = &ContractRequesterMockCallConstructorParams{ctx, msg}
	for _, e := range mmCallConstructor.expectations {
		if minimock.Equal(e.params, mmCallConstructor.defaultExpectation.params) {
			mmCallConstructor.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCallConstructor.defaultExpectation.params)
		}
	}

	return mmCallConstructor
}

// Inspect accepts an inspector function that has same arguments as the ContractRequester.CallConstructor
func (mmCallConstructor *mContractRequesterMockCallConstructor) Inspect(f func(ctx context.Context, msg mm_insolar.Message)) *mContractRequesterMockCallConstructor {
	if mmCallConstructor.mock.inspectFuncCallConstructor != nil {
		mmCallConstructor.mock.t.Fatalf("Inspect function is already set for ContractRequesterMock.CallConstructor")
	}

	mmCallConstructor.mock.inspectFuncCallConstructor = f

	return mmCallConstructor
}

// Return sets up results that will be returned by ContractRequester.CallConstructor
func (mmCallConstructor *mContractRequesterMockCallConstructor) Return(ref *mm_insolar.Reference, ctorErr string, err error) *ContractRequesterMock {
	if mmCallConstructor.mock.funcCallConstructor != nil {
		mmCallConstructor.mock.t.Fatalf("ContractRequesterMock.CallConstructor mock is already set by Set")
	}

	if mmCallConstructor.defaultExpectation == nil {
		mmCallConstructor.defaultExpectation = &ContractRequesterMockCallConstructorExpectation{mock: mmCallConstructor.mock}
	}
	mmCallConstructor.defaultExpectation.results = &ContractRequesterMockCallConstructorResults{ref, ctorErr, err}
	return mmCallConstructor.mock
}

//Set uses given function f to mock the ContractRequester.CallConstructor method
func (mmCallConstructor *mContractRequesterMockCallConstructor) Set(f func(ctx context.Context, msg mm_insolar.Message) (ref *mm_insolar.Reference, ctorErr string, err error)) *ContractRequesterMock {
	if mmCallConstructor.defaultExpectation != nil {
		mmCallConstructor.mock.t.Fatalf("Default expectation is already set for the ContractRequester.CallConstructor method")
	}

	if len(mmCallConstructor.expectations) > 0 {
		mmCallConstructor.mock.t.Fatalf("Some expectations are already set for the ContractRequester.CallConstructor method")
	}

	mmCallConstructor.mock.funcCallConstructor = f
	return mmCallConstructor.mock
}

// When sets expectation for the ContractRequester.CallConstructor which will trigger the result defined by the following
// Then helper
func (mmCallConstructor *mContractRequesterMockCallConstructor) When(ctx context.Context, msg mm_insolar.Message) *ContractRequesterMockCallConstructorExpectation {
	if mmCallConstructor.mock.funcCallConstructor != nil {
		mmCallConstructor.mock.t.Fatalf("ContractRequesterMock.CallConstructor mock is already set by Set")
	}

	expectation := &ContractRequesterMockCallConstructorExpectation{
		mock:   mmCallConstructor.mock,
		params: &ContractRequesterMockCallConstructorParams{ctx, msg},
	}
	mmCallConstructor.expectations = append(mmCallConstructor.expectations, expectation)
	return expectation
}

// Then sets up ContractRequester.CallConstructor return parameters for the expectation previously defined by the When method
func (e *ContractRequesterMockCallConstructorExpectation) Then(ref *mm_insolar.Reference, ctorErr string, err error) *ContractRequesterMock {
	e.results = &ContractRequesterMockCallConstructorResults{ref, ctorErr, err}
	return e.mock
}

// CallConstructor implements insolar.ContractRequester
func (mmCallConstructor *ContractRequesterMock) CallConstructor(ctx context.Context, msg mm_insolar.Message) (ref *mm_insolar.Reference, ctorErr string, err error) {
	mm_atomic.AddUint64(&mmCallConstructor.beforeCallConstructorCounter, 1)
	defer mm_atomic.AddUint64(&mmCallConstructor.afterCallConstructorCounter, 1)

	if mmCallConstructor.inspectFuncCallConstructor != nil {
		mmCallConstructor.inspectFuncCallConstructor(ctx, msg)
	}

	params := &ContractRequesterMockCallConstructorParams{ctx, msg}

	// Record call args
	mmCallConstructor.CallConstructorMock.mutex.Lock()
	mmCallConstructor.CallConstructorMock.callArgs = append(mmCallConstructor.CallConstructorMock.callArgs, params)
	mmCallConstructor.CallConstructorMock.mutex.Unlock()

	for _, e := range mmCallConstructor.CallConstructorMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ref, e.results.ctorErr, e.results.err
		}
	}

	if mmCallConstructor.CallConstructorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCallConstructor.CallConstructorMock.defaultExpectation.Counter, 1)
		want := mmCallConstructor.CallConstructorMock.defaultExpectation.params
		got := ContractRequesterMockCallConstructorParams{ctx, msg}
		if want != nil && !minimock.Equal(*want, got) {
			mmCallConstructor.t.Errorf("ContractRequesterMock.CallConstructor got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmCallConstructor.CallConstructorMock.defaultExpectation.results
		if results == nil {
			mmCallConstructor.t.Fatal("No results are set for the ContractRequesterMock.CallConstructor")
		}
		return (*results).ref, (*results).ctorErr, (*results).err
	}
	if mmCallConstructor.funcCallConstructor != nil {
		return mmCallConstructor.funcCallConstructor(ctx, msg)
	}
	mmCallConstructor.t.Fatalf("Unexpected call to ContractRequesterMock.CallConstructor. %v %v", ctx, msg)
	return
}

// CallConstructorAfterCounter returns a count of finished ContractRequesterMock.CallConstructor invocations
func (mmCallConstructor *ContractRequesterMock) CallConstructorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCallConstructor.afterCallConstructorCounter)
}

// CallConstructorBeforeCounter returns a count of ContractRequesterMock.CallConstructor invocations
func (mmCallConstructor *ContractRequesterMock) CallConstructorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCallConstructor.beforeCallConstructorCounter)
}

// Calls returns a list of arguments used in each call to ContractRequesterMock.CallConstructor.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCallConstructor *mContractRequesterMockCallConstructor) Calls() []*ContractRequesterMockCallConstructorParams {
	mmCallConstructor.mutex.RLock()

	argCopy := make([]*ContractRequesterMockCallConstructorParams, len(mmCallConstructor.callArgs))
	copy(argCopy, mmCallConstructor.callArgs)

	mmCallConstructor.mutex.RUnlock()

	return argCopy
}

// MinimockCallConstructorDone returns true if the count of the CallConstructor invocations corresponds
// the number of defined expectations
func (m *ContractRequesterMock) MinimockCallConstructorDone() bool {
	for _, e := range m.CallConstructorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CallConstructorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCallConstructorCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCallConstructor != nil && mm_atomic.LoadUint64(&m.afterCallConstructorCounter) < 1 {
		return false
	}
	return true
}

// MinimockCallConstructorInspect logs each unmet expectation
func (m *ContractRequesterMock) MinimockCallConstructorInspect() {
	for _, e := range m.CallConstructorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContractRequesterMock.CallConstructor with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CallConstructorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCallConstructorCounter) < 1 {
		if m.CallConstructorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ContractRequesterMock.CallConstructor")
		} else {
			m.t.Errorf("Expected call to ContractRequesterMock.CallConstructor with params: %#v", *m.CallConstructorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCallConstructor != nil && mm_atomic.LoadUint64(&m.afterCallConstructorCounter) < 1 {
		m.t.Error("Expected call to ContractRequesterMock.CallConstructor")
	}
}

type mContractRequesterMockCallMethod struct {
	mock               *ContractRequesterMock
	defaultExpectation *ContractRequesterMockCallMethodExpectation
	expectations       []*ContractRequesterMockCallMethodExpectation

	callArgs []*ContractRequesterMockCallMethodParams
	mutex    sync.RWMutex
}

// ContractRequesterMockCallMethodExpectation specifies expectation struct of the ContractRequester.CallMethod
type ContractRequesterMockCallMethodExpectation struct {
	mock    *ContractRequesterMock
	params  *ContractRequesterMockCallMethodParams
	results *ContractRequesterMockCallMethodResults
	Counter uint64
}

// ContractRequesterMockCallMethodParams contains parameters of the ContractRequester.CallMethod
type ContractRequesterMockCallMethodParams struct {
	ctx context.Context
	msg mm_insolar.Message
}

// ContractRequesterMockCallMethodResults contains results of the ContractRequester.CallMethod
type ContractRequesterMockCallMethodResults struct {
	r1  mm_insolar.Reply
	err error
}

// Expect sets up expected params for ContractRequester.CallMethod
func (mmCallMethod *mContractRequesterMockCallMethod) Expect(ctx context.Context, msg mm_insolar.Message) *mContractRequesterMockCallMethod {
	if mmCallMethod.mock.funcCallMethod != nil {
		mmCallMethod.mock.t.Fatalf("ContractRequesterMock.CallMethod mock is already set by Set")
	}

	if mmCallMethod.defaultExpectation == nil {
		mmCallMethod.defaultExpectation = &ContractRequesterMockCallMethodExpectation{}
	}

	mmCallMethod.defaultExpectation.params = &ContractRequesterMockCallMethodParams{ctx, msg}
	for _, e := range mmCallMethod.expectations {
		if minimock.Equal(e.params, mmCallMethod.defaultExpectation.params) {
			mmCallMethod.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCallMethod.defaultExpectation.params)
		}
	}

	return mmCallMethod
}

// Inspect accepts an inspector function that has same arguments as the ContractRequester.CallMethod
func (mmCallMethod *mContractRequesterMockCallMethod) Inspect(f func(ctx context.Context, msg mm_insolar.Message)) *mContractRequesterMockCallMethod {
	if mmCallMethod.mock.inspectFuncCallMethod != nil {
		mmCallMethod.mock.t.Fatalf("Inspect function is already set for ContractRequesterMock.CallMethod")
	}

	mmCallMethod.mock.inspectFuncCallMethod = f

	return mmCallMethod
}

// Return sets up results that will be returned by ContractRequester.CallMethod
func (mmCallMethod *mContractRequesterMockCallMethod) Return(r1 mm_insolar.Reply, err error) *ContractRequesterMock {
	if mmCallMethod.mock.funcCallMethod != nil {
		mmCallMethod.mock.t.Fatalf("ContractRequesterMock.CallMethod mock is already set by Set")
	}

	if mmCallMethod.defaultExpectation == nil {
		mmCallMethod.defaultExpectation = &ContractRequesterMockCallMethodExpectation{mock: mmCallMethod.mock}
	}
	mmCallMethod.defaultExpectation.results = &ContractRequesterMockCallMethodResults{r1, err}
	return mmCallMethod.mock
}

//Set uses given function f to mock the ContractRequester.CallMethod method
func (mmCallMethod *mContractRequesterMockCallMethod) Set(f func(ctx context.Context, msg mm_insolar.Message) (r1 mm_insolar.Reply, err error)) *ContractRequesterMock {
	if mmCallMethod.defaultExpectation != nil {
		mmCallMethod.mock.t.Fatalf("Default expectation is already set for the ContractRequester.CallMethod method")
	}

	if len(mmCallMethod.expectations) > 0 {
		mmCallMethod.mock.t.Fatalf("Some expectations are already set for the ContractRequester.CallMethod method")
	}

	mmCallMethod.mock.funcCallMethod = f
	return mmCallMethod.mock
}

// When sets expectation for the ContractRequester.CallMethod which will trigger the result defined by the following
// Then helper
func (mmCallMethod *mContractRequesterMockCallMethod) When(ctx context.Context, msg mm_insolar.Message) *ContractRequesterMockCallMethodExpectation {
	if mmCallMethod.mock.funcCallMethod != nil {
		mmCallMethod.mock.t.Fatalf("ContractRequesterMock.CallMethod mock is already set by Set")
	}

	expectation := &ContractRequesterMockCallMethodExpectation{
		mock:   mmCallMethod.mock,
		params: &ContractRequesterMockCallMethodParams{ctx, msg},
	}
	mmCallMethod.expectations = append(mmCallMethod.expectations, expectation)
	return expectation
}

// Then sets up ContractRequester.CallMethod return parameters for the expectation previously defined by the When method
func (e *ContractRequesterMockCallMethodExpectation) Then(r1 mm_insolar.Reply, err error) *ContractRequesterMock {
	e.results = &ContractRequesterMockCallMethodResults{r1, err}
	return e.mock
}

// CallMethod implements insolar.ContractRequester
func (mmCallMethod *ContractRequesterMock) CallMethod(ctx context.Context, msg mm_insolar.Message) (r1 mm_insolar.Reply, err error) {
	mm_atomic.AddUint64(&mmCallMethod.beforeCallMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmCallMethod.afterCallMethodCounter, 1)

	if mmCallMethod.inspectFuncCallMethod != nil {
		mmCallMethod.inspectFuncCallMethod(ctx, msg)
	}

	params := &ContractRequesterMockCallMethodParams{ctx, msg}

	// Record call args
	mmCallMethod.CallMethodMock.mutex.Lock()
	mmCallMethod.CallMethodMock.callArgs = append(mmCallMethod.CallMethodMock.callArgs, params)
	mmCallMethod.CallMethodMock.mutex.Unlock()

	for _, e := range mmCallMethod.CallMethodMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmCallMethod.CallMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCallMethod.CallMethodMock.defaultExpectation.Counter, 1)
		want := mmCallMethod.CallMethodMock.defaultExpectation.params
		got := ContractRequesterMockCallMethodParams{ctx, msg}
		if want != nil && !minimock.Equal(*want, got) {
			mmCallMethod.t.Errorf("ContractRequesterMock.CallMethod got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmCallMethod.CallMethodMock.defaultExpectation.results
		if results == nil {
			mmCallMethod.t.Fatal("No results are set for the ContractRequesterMock.CallMethod")
		}
		return (*results).r1, (*results).err
	}
	if mmCallMethod.funcCallMethod != nil {
		return mmCallMethod.funcCallMethod(ctx, msg)
	}
	mmCallMethod.t.Fatalf("Unexpected call to ContractRequesterMock.CallMethod. %v %v", ctx, msg)
	return
}

// CallMethodAfterCounter returns a count of finished ContractRequesterMock.CallMethod invocations
func (mmCallMethod *ContractRequesterMock) CallMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCallMethod.afterCallMethodCounter)
}

// CallMethodBeforeCounter returns a count of ContractRequesterMock.CallMethod invocations
func (mmCallMethod *ContractRequesterMock) CallMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCallMethod.beforeCallMethodCounter)
}

// Calls returns a list of arguments used in each call to ContractRequesterMock.CallMethod.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCallMethod *mContractRequesterMockCallMethod) Calls() []*ContractRequesterMockCallMethodParams {
	mmCallMethod.mutex.RLock()

	argCopy := make([]*ContractRequesterMockCallMethodParams, len(mmCallMethod.callArgs))
	copy(argCopy, mmCallMethod.callArgs)

	mmCallMethod.mutex.RUnlock()

	return argCopy
}

// MinimockCallMethodDone returns true if the count of the CallMethod invocations corresponds
// the number of defined expectations
func (m *ContractRequesterMock) MinimockCallMethodDone() bool {
	for _, e := range m.CallMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CallMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCallMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCallMethod != nil && mm_atomic.LoadUint64(&m.afterCallMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockCallMethodInspect logs each unmet expectation
func (m *ContractRequesterMock) MinimockCallMethodInspect() {
	for _, e := range m.CallMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContractRequesterMock.CallMethod with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CallMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCallMethodCounter) < 1 {
		if m.CallMethodMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ContractRequesterMock.CallMethod")
		} else {
			m.t.Errorf("Expected call to ContractRequesterMock.CallMethod with params: %#v", *m.CallMethodMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCallMethod != nil && mm_atomic.LoadUint64(&m.afterCallMethodCounter) < 1 {
		m.t.Error("Expected call to ContractRequesterMock.CallMethod")
	}
}

type mContractRequesterMockSendRequest struct {
	mock               *ContractRequesterMock
	defaultExpectation *ContractRequesterMockSendRequestExpectation
	expectations       []*ContractRequesterMockSendRequestExpectation

	callArgs []*ContractRequesterMockSendRequestParams
	mutex    sync.RWMutex
}

// ContractRequesterMockSendRequestExpectation specifies expectation struct of the ContractRequester.SendRequest
type ContractRequesterMockSendRequestExpectation struct {
	mock    *ContractRequesterMock
	params  *ContractRequesterMockSendRequestParams
	results *ContractRequesterMockSendRequestResults
	Counter uint64
}

// ContractRequesterMockSendRequestParams contains parameters of the ContractRequester.SendRequest
type ContractRequesterMockSendRequestParams struct {
	ctx    context.Context
	ref    *mm_insolar.Reference
	method string
	argsIn []interface{}
}

// ContractRequesterMockSendRequestResults contains results of the ContractRequester.SendRequest
type ContractRequesterMockSendRequestResults struct {
	r1  mm_insolar.Reply
	err error
}

// Expect sets up expected params for ContractRequester.SendRequest
func (mmSendRequest *mContractRequesterMockSendRequest) Expect(ctx context.Context, ref *mm_insolar.Reference, method string, argsIn []interface{}) *mContractRequesterMockSendRequest {
	if mmSendRequest.mock.funcSendRequest != nil {
		mmSendRequest.mock.t.Fatalf("ContractRequesterMock.SendRequest mock is already set by Set")
	}

	if mmSendRequest.defaultExpectation == nil {
		mmSendRequest.defaultExpectation = &ContractRequesterMockSendRequestExpectation{}
	}

	mmSendRequest.defaultExpectation.params = &ContractRequesterMockSendRequestParams{ctx, ref, method, argsIn}
	for _, e := range mmSendRequest.expectations {
		if minimock.Equal(e.params, mmSendRequest.defaultExpectation.params) {
			mmSendRequest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendRequest.defaultExpectation.params)
		}
	}

	return mmSendRequest
}

// Inspect accepts an inspector function that has same arguments as the ContractRequester.SendRequest
func (mmSendRequest *mContractRequesterMockSendRequest) Inspect(f func(ctx context.Context, ref *mm_insolar.Reference, method string, argsIn []interface{})) *mContractRequesterMockSendRequest {
	if mmSendRequest.mock.inspectFuncSendRequest != nil {
		mmSendRequest.mock.t.Fatalf("Inspect function is already set for ContractRequesterMock.SendRequest")
	}

	mmSendRequest.mock.inspectFuncSendRequest = f

	return mmSendRequest
}

// Return sets up results that will be returned by ContractRequester.SendRequest
func (mmSendRequest *mContractRequesterMockSendRequest) Return(r1 mm_insolar.Reply, err error) *ContractRequesterMock {
	if mmSendRequest.mock.funcSendRequest != nil {
		mmSendRequest.mock.t.Fatalf("ContractRequesterMock.SendRequest mock is already set by Set")
	}

	if mmSendRequest.defaultExpectation == nil {
		mmSendRequest.defaultExpectation = &ContractRequesterMockSendRequestExpectation{mock: mmSendRequest.mock}
	}
	mmSendRequest.defaultExpectation.results = &ContractRequesterMockSendRequestResults{r1, err}
	return mmSendRequest.mock
}

//Set uses given function f to mock the ContractRequester.SendRequest method
func (mmSendRequest *mContractRequesterMockSendRequest) Set(f func(ctx context.Context, ref *mm_insolar.Reference, method string, argsIn []interface{}) (r1 mm_insolar.Reply, err error)) *ContractRequesterMock {
	if mmSendRequest.defaultExpectation != nil {
		mmSendRequest.mock.t.Fatalf("Default expectation is already set for the ContractRequester.SendRequest method")
	}

	if len(mmSendRequest.expectations) > 0 {
		mmSendRequest.mock.t.Fatalf("Some expectations are already set for the ContractRequester.SendRequest method")
	}

	mmSendRequest.mock.funcSendRequest = f
	return mmSendRequest.mock
}

// When sets expectation for the ContractRequester.SendRequest which will trigger the result defined by the following
// Then helper
func (mmSendRequest *mContractRequesterMockSendRequest) When(ctx context.Context, ref *mm_insolar.Reference, method string, argsIn []interface{}) *ContractRequesterMockSendRequestExpectation {
	if mmSendRequest.mock.funcSendRequest != nil {
		mmSendRequest.mock.t.Fatalf("ContractRequesterMock.SendRequest mock is already set by Set")
	}

	expectation := &ContractRequesterMockSendRequestExpectation{
		mock:   mmSendRequest.mock,
		params: &ContractRequesterMockSendRequestParams{ctx, ref, method, argsIn},
	}
	mmSendRequest.expectations = append(mmSendRequest.expectations, expectation)
	return expectation
}

// Then sets up ContractRequester.SendRequest return parameters for the expectation previously defined by the When method
func (e *ContractRequesterMockSendRequestExpectation) Then(r1 mm_insolar.Reply, err error) *ContractRequesterMock {
	e.results = &ContractRequesterMockSendRequestResults{r1, err}
	return e.mock
}

// SendRequest implements insolar.ContractRequester
func (mmSendRequest *ContractRequesterMock) SendRequest(ctx context.Context, ref *mm_insolar.Reference, method string, argsIn []interface{}) (r1 mm_insolar.Reply, err error) {
	mm_atomic.AddUint64(&mmSendRequest.beforeSendRequestCounter, 1)
	defer mm_atomic.AddUint64(&mmSendRequest.afterSendRequestCounter, 1)

	if mmSendRequest.inspectFuncSendRequest != nil {
		mmSendRequest.inspectFuncSendRequest(ctx, ref, method, argsIn)
	}

	params := &ContractRequesterMockSendRequestParams{ctx, ref, method, argsIn}

	// Record call args
	mmSendRequest.SendRequestMock.mutex.Lock()
	mmSendRequest.SendRequestMock.callArgs = append(mmSendRequest.SendRequestMock.callArgs, params)
	mmSendRequest.SendRequestMock.mutex.Unlock()

	for _, e := range mmSendRequest.SendRequestMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmSendRequest.SendRequestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendRequest.SendRequestMock.defaultExpectation.Counter, 1)
		want := mmSendRequest.SendRequestMock.defaultExpectation.params
		got := ContractRequesterMockSendRequestParams{ctx, ref, method, argsIn}
		if want != nil && !minimock.Equal(*want, got) {
			mmSendRequest.t.Errorf("ContractRequesterMock.SendRequest got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmSendRequest.SendRequestMock.defaultExpectation.results
		if results == nil {
			mmSendRequest.t.Fatal("No results are set for the ContractRequesterMock.SendRequest")
		}
		return (*results).r1, (*results).err
	}
	if mmSendRequest.funcSendRequest != nil {
		return mmSendRequest.funcSendRequest(ctx, ref, method, argsIn)
	}
	mmSendRequest.t.Fatalf("Unexpected call to ContractRequesterMock.SendRequest. %v %v %v %v", ctx, ref, method, argsIn)
	return
}

// SendRequestAfterCounter returns a count of finished ContractRequesterMock.SendRequest invocations
func (mmSendRequest *ContractRequesterMock) SendRequestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendRequest.afterSendRequestCounter)
}

// SendRequestBeforeCounter returns a count of ContractRequesterMock.SendRequest invocations
func (mmSendRequest *ContractRequesterMock) SendRequestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendRequest.beforeSendRequestCounter)
}

// Calls returns a list of arguments used in each call to ContractRequesterMock.SendRequest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendRequest *mContractRequesterMockSendRequest) Calls() []*ContractRequesterMockSendRequestParams {
	mmSendRequest.mutex.RLock()

	argCopy := make([]*ContractRequesterMockSendRequestParams, len(mmSendRequest.callArgs))
	copy(argCopy, mmSendRequest.callArgs)

	mmSendRequest.mutex.RUnlock()

	return argCopy
}

// MinimockSendRequestDone returns true if the count of the SendRequest invocations corresponds
// the number of defined expectations
func (m *ContractRequesterMock) MinimockSendRequestDone() bool {
	for _, e := range m.SendRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendRequestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendRequest != nil && mm_atomic.LoadUint64(&m.afterSendRequestCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendRequestInspect logs each unmet expectation
func (m *ContractRequesterMock) MinimockSendRequestInspect() {
	for _, e := range m.SendRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContractRequesterMock.SendRequest with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendRequestCounter) < 1 {
		if m.SendRequestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ContractRequesterMock.SendRequest")
		} else {
			m.t.Errorf("Expected call to ContractRequesterMock.SendRequest with params: %#v", *m.SendRequestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendRequest != nil && mm_atomic.LoadUint64(&m.afterSendRequestCounter) < 1 {
		m.t.Error("Expected call to ContractRequesterMock.SendRequest")
	}
}

type mContractRequesterMockSendRequestWithPulse struct {
	mock               *ContractRequesterMock
	defaultExpectation *ContractRequesterMockSendRequestWithPulseExpectation
	expectations       []*ContractRequesterMockSendRequestWithPulseExpectation

	callArgs []*ContractRequesterMockSendRequestWithPulseParams
	mutex    sync.RWMutex
}

// ContractRequesterMockSendRequestWithPulseExpectation specifies expectation struct of the ContractRequester.SendRequestWithPulse
type ContractRequesterMockSendRequestWithPulseExpectation struct {
	mock    *ContractRequesterMock
	params  *ContractRequesterMockSendRequestWithPulseParams
	results *ContractRequesterMockSendRequestWithPulseResults
	Counter uint64
}

// ContractRequesterMockSendRequestWithPulseParams contains parameters of the ContractRequester.SendRequestWithPulse
type ContractRequesterMockSendRequestWithPulseParams struct {
	ctx    context.Context
	ref    *mm_insolar.Reference
	method string
	argsIn []interface{}
	pulse  mm_insolar.PulseNumber
}

// ContractRequesterMockSendRequestWithPulseResults contains results of the ContractRequester.SendRequestWithPulse
type ContractRequesterMockSendRequestWithPulseResults struct {
	r1  mm_insolar.Reply
	err error
}

// Expect sets up expected params for ContractRequester.SendRequestWithPulse
func (mmSendRequestWithPulse *mContractRequesterMockSendRequestWithPulse) Expect(ctx context.Context, ref *mm_insolar.Reference, method string, argsIn []interface{}, pulse mm_insolar.PulseNumber) *mContractRequesterMockSendRequestWithPulse {
	if mmSendRequestWithPulse.mock.funcSendRequestWithPulse != nil {
		mmSendRequestWithPulse.mock.t.Fatalf("ContractRequesterMock.SendRequestWithPulse mock is already set by Set")
	}

	if mmSendRequestWithPulse.defaultExpectation == nil {
		mmSendRequestWithPulse.defaultExpectation = &ContractRequesterMockSendRequestWithPulseExpectation{}
	}

	mmSendRequestWithPulse.defaultExpectation.params = &ContractRequesterMockSendRequestWithPulseParams{ctx, ref, method, argsIn, pulse}
	for _, e := range mmSendRequestWithPulse.expectations {
		if minimock.Equal(e.params, mmSendRequestWithPulse.defaultExpectation.params) {
			mmSendRequestWithPulse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendRequestWithPulse.defaultExpectation.params)
		}
	}

	return mmSendRequestWithPulse
}

// Inspect accepts an inspector function that has same arguments as the ContractRequester.SendRequestWithPulse
func (mmSendRequestWithPulse *mContractRequesterMockSendRequestWithPulse) Inspect(f func(ctx context.Context, ref *mm_insolar.Reference, method string, argsIn []interface{}, pulse mm_insolar.PulseNumber)) *mContractRequesterMockSendRequestWithPulse {
	if mmSendRequestWithPulse.mock.inspectFuncSendRequestWithPulse != nil {
		mmSendRequestWithPulse.mock.t.Fatalf("Inspect function is already set for ContractRequesterMock.SendRequestWithPulse")
	}

	mmSendRequestWithPulse.mock.inspectFuncSendRequestWithPulse = f

	return mmSendRequestWithPulse
}

// Return sets up results that will be returned by ContractRequester.SendRequestWithPulse
func (mmSendRequestWithPulse *mContractRequesterMockSendRequestWithPulse) Return(r1 mm_insolar.Reply, err error) *ContractRequesterMock {
	if mmSendRequestWithPulse.mock.funcSendRequestWithPulse != nil {
		mmSendRequestWithPulse.mock.t.Fatalf("ContractRequesterMock.SendRequestWithPulse mock is already set by Set")
	}

	if mmSendRequestWithPulse.defaultExpectation == nil {
		mmSendRequestWithPulse.defaultExpectation = &ContractRequesterMockSendRequestWithPulseExpectation{mock: mmSendRequestWithPulse.mock}
	}
	mmSendRequestWithPulse.defaultExpectation.results = &ContractRequesterMockSendRequestWithPulseResults{r1, err}
	return mmSendRequestWithPulse.mock
}

//Set uses given function f to mock the ContractRequester.SendRequestWithPulse method
func (mmSendRequestWithPulse *mContractRequesterMockSendRequestWithPulse) Set(f func(ctx context.Context, ref *mm_insolar.Reference, method string, argsIn []interface{}, pulse mm_insolar.PulseNumber) (r1 mm_insolar.Reply, err error)) *ContractRequesterMock {
	if mmSendRequestWithPulse.defaultExpectation != nil {
		mmSendRequestWithPulse.mock.t.Fatalf("Default expectation is already set for the ContractRequester.SendRequestWithPulse method")
	}

	if len(mmSendRequestWithPulse.expectations) > 0 {
		mmSendRequestWithPulse.mock.t.Fatalf("Some expectations are already set for the ContractRequester.SendRequestWithPulse method")
	}

	mmSendRequestWithPulse.mock.funcSendRequestWithPulse = f
	return mmSendRequestWithPulse.mock
}

// When sets expectation for the ContractRequester.SendRequestWithPulse which will trigger the result defined by the following
// Then helper
func (mmSendRequestWithPulse *mContractRequesterMockSendRequestWithPulse) When(ctx context.Context, ref *mm_insolar.Reference, method string, argsIn []interface{}, pulse mm_insolar.PulseNumber) *ContractRequesterMockSendRequestWithPulseExpectation {
	if mmSendRequestWithPulse.mock.funcSendRequestWithPulse != nil {
		mmSendRequestWithPulse.mock.t.Fatalf("ContractRequesterMock.SendRequestWithPulse mock is already set by Set")
	}

	expectation := &ContractRequesterMockSendRequestWithPulseExpectation{
		mock:   mmSendRequestWithPulse.mock,
		params: &ContractRequesterMockSendRequestWithPulseParams{ctx, ref, method, argsIn, pulse},
	}
	mmSendRequestWithPulse.expectations = append(mmSendRequestWithPulse.expectations, expectation)
	return expectation
}

// Then sets up ContractRequester.SendRequestWithPulse return parameters for the expectation previously defined by the When method
func (e *ContractRequesterMockSendRequestWithPulseExpectation) Then(r1 mm_insolar.Reply, err error) *ContractRequesterMock {
	e.results = &ContractRequesterMockSendRequestWithPulseResults{r1, err}
	return e.mock
}

// SendRequestWithPulse implements insolar.ContractRequester
func (mmSendRequestWithPulse *ContractRequesterMock) SendRequestWithPulse(ctx context.Context, ref *mm_insolar.Reference, method string, argsIn []interface{}, pulse mm_insolar.PulseNumber) (r1 mm_insolar.Reply, err error) {
	mm_atomic.AddUint64(&mmSendRequestWithPulse.beforeSendRequestWithPulseCounter, 1)
	defer mm_atomic.AddUint64(&mmSendRequestWithPulse.afterSendRequestWithPulseCounter, 1)

	if mmSendRequestWithPulse.inspectFuncSendRequestWithPulse != nil {
		mmSendRequestWithPulse.inspectFuncSendRequestWithPulse(ctx, ref, method, argsIn, pulse)
	}

	params := &ContractRequesterMockSendRequestWithPulseParams{ctx, ref, method, argsIn, pulse}

	// Record call args
	mmSendRequestWithPulse.SendRequestWithPulseMock.mutex.Lock()
	mmSendRequestWithPulse.SendRequestWithPulseMock.callArgs = append(mmSendRequestWithPulse.SendRequestWithPulseMock.callArgs, params)
	mmSendRequestWithPulse.SendRequestWithPulseMock.mutex.Unlock()

	for _, e := range mmSendRequestWithPulse.SendRequestWithPulseMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmSendRequestWithPulse.SendRequestWithPulseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendRequestWithPulse.SendRequestWithPulseMock.defaultExpectation.Counter, 1)
		want := mmSendRequestWithPulse.SendRequestWithPulseMock.defaultExpectation.params
		got := ContractRequesterMockSendRequestWithPulseParams{ctx, ref, method, argsIn, pulse}
		if want != nil && !minimock.Equal(*want, got) {
			mmSendRequestWithPulse.t.Errorf("ContractRequesterMock.SendRequestWithPulse got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmSendRequestWithPulse.SendRequestWithPulseMock.defaultExpectation.results
		if results == nil {
			mmSendRequestWithPulse.t.Fatal("No results are set for the ContractRequesterMock.SendRequestWithPulse")
		}
		return (*results).r1, (*results).err
	}
	if mmSendRequestWithPulse.funcSendRequestWithPulse != nil {
		return mmSendRequestWithPulse.funcSendRequestWithPulse(ctx, ref, method, argsIn, pulse)
	}
	mmSendRequestWithPulse.t.Fatalf("Unexpected call to ContractRequesterMock.SendRequestWithPulse. %v %v %v %v %v", ctx, ref, method, argsIn, pulse)
	return
}

// SendRequestWithPulseAfterCounter returns a count of finished ContractRequesterMock.SendRequestWithPulse invocations
func (mmSendRequestWithPulse *ContractRequesterMock) SendRequestWithPulseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendRequestWithPulse.afterSendRequestWithPulseCounter)
}

// SendRequestWithPulseBeforeCounter returns a count of ContractRequesterMock.SendRequestWithPulse invocations
func (mmSendRequestWithPulse *ContractRequesterMock) SendRequestWithPulseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendRequestWithPulse.beforeSendRequestWithPulseCounter)
}

// Calls returns a list of arguments used in each call to ContractRequesterMock.SendRequestWithPulse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendRequestWithPulse *mContractRequesterMockSendRequestWithPulse) Calls() []*ContractRequesterMockSendRequestWithPulseParams {
	mmSendRequestWithPulse.mutex.RLock()

	argCopy := make([]*ContractRequesterMockSendRequestWithPulseParams, len(mmSendRequestWithPulse.callArgs))
	copy(argCopy, mmSendRequestWithPulse.callArgs)

	mmSendRequestWithPulse.mutex.RUnlock()

	return argCopy
}

// MinimockSendRequestWithPulseDone returns true if the count of the SendRequestWithPulse invocations corresponds
// the number of defined expectations
func (m *ContractRequesterMock) MinimockSendRequestWithPulseDone() bool {
	for _, e := range m.SendRequestWithPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendRequestWithPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendRequestWithPulseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendRequestWithPulse != nil && mm_atomic.LoadUint64(&m.afterSendRequestWithPulseCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendRequestWithPulseInspect logs each unmet expectation
func (m *ContractRequesterMock) MinimockSendRequestWithPulseInspect() {
	for _, e := range m.SendRequestWithPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContractRequesterMock.SendRequestWithPulse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendRequestWithPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendRequestWithPulseCounter) < 1 {
		if m.SendRequestWithPulseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ContractRequesterMock.SendRequestWithPulse")
		} else {
			m.t.Errorf("Expected call to ContractRequesterMock.SendRequestWithPulse with params: %#v", *m.SendRequestWithPulseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendRequestWithPulse != nil && mm_atomic.LoadUint64(&m.afterSendRequestWithPulseCounter) < 1 {
		m.t.Error("Expected call to ContractRequesterMock.SendRequestWithPulse")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ContractRequesterMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCallInspect()

		m.MinimockCallConstructorInspect()

		m.MinimockCallMethodInspect()

		m.MinimockSendRequestInspect()

		m.MinimockSendRequestWithPulseInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ContractRequesterMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ContractRequesterMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCallDone() &&
		m.MinimockCallConstructorDone() &&
		m.MinimockCallMethodDone() &&
		m.MinimockSendRequestDone() &&
		m.MinimockSendRequestWithPulseDone()
}
