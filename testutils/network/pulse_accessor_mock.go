package network

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
)

// PulseAccessorMock implements storage.PulseAccessor
type PulseAccessorMock struct {
	t minimock.Tester

	funcForPulseNumber          func(ctx context.Context, p1 insolar.PulseNumber) (p2 insolar.PulseNumber, err error)
	inspectFuncForPulseNumber   func(ctx context.Context, p1 insolar.PulseNumber)
	afterForPulseNumberCounter  uint64
	beforeForPulseNumberCounter uint64
	ForPulseNumberMock          mPulseAccessorMockForPulseNumber

	funcLatest          func(ctx context.Context) (p1 insolar.Pulse, err error)
	inspectFuncLatest   func(ctx context.Context)
	afterLatestCounter  uint64
	beforeLatestCounter uint64
	LatestMock          mPulseAccessorMockLatest
}

// NewPulseAccessorMock returns a mock for storage.PulseAccessor
func NewPulseAccessorMock(t minimock.Tester) *PulseAccessorMock {
	m := &PulseAccessorMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ForPulseNumberMock = mPulseAccessorMockForPulseNumber{mock: m}
	m.ForPulseNumberMock.callArgs = []*PulseAccessorMockForPulseNumberParams{}

	m.LatestMock = mPulseAccessorMockLatest{mock: m}
	m.LatestMock.callArgs = []*PulseAccessorMockLatestParams{}

	return m
}

type mPulseAccessorMockForPulseNumber struct {
	mock               *PulseAccessorMock
	defaultExpectation *PulseAccessorMockForPulseNumberExpectation
	expectations       []*PulseAccessorMockForPulseNumberExpectation

	callArgs []*PulseAccessorMockForPulseNumberParams
	mutex    sync.RWMutex
}

// PulseAccessorMockForPulseNumberExpectation specifies expectation struct of the PulseAccessor.ForPulseNumber
type PulseAccessorMockForPulseNumberExpectation struct {
	mock    *PulseAccessorMock
	params  *PulseAccessorMockForPulseNumberParams
	results *PulseAccessorMockForPulseNumberResults
	Counter uint64
}

// PulseAccessorMockForPulseNumberParams contains parameters of the PulseAccessor.ForPulseNumber
type PulseAccessorMockForPulseNumberParams struct {
	ctx context.Context
	p1  insolar.PulseNumber
}

// PulseAccessorMockForPulseNumberResults contains results of the PulseAccessor.ForPulseNumber
type PulseAccessorMockForPulseNumberResults struct {
	p2  insolar.PulseNumber
	err error
}

// Expect sets up expected params for PulseAccessor.ForPulseNumber
func (mmForPulseNumber *mPulseAccessorMockForPulseNumber) Expect(ctx context.Context, p1 insolar.PulseNumber) *mPulseAccessorMockForPulseNumber {
	if mmForPulseNumber.mock.funcForPulseNumber != nil {
		mmForPulseNumber.mock.t.Fatalf("PulseAccessorMock.ForPulseNumber mock is already set by Set")
	}

	if mmForPulseNumber.defaultExpectation == nil {
		mmForPulseNumber.defaultExpectation = &PulseAccessorMockForPulseNumberExpectation{}
	}

	mmForPulseNumber.defaultExpectation.params = &PulseAccessorMockForPulseNumberParams{ctx, p1}
	for _, e := range mmForPulseNumber.expectations {
		if minimock.Equal(e.params, mmForPulseNumber.defaultExpectation.params) {
			mmForPulseNumber.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmForPulseNumber.defaultExpectation.params)
		}
	}

	return mmForPulseNumber
}

// Inspect accepts an inspector function that has same arguments as the PulseAccessor.ForPulseNumber
func (mmForPulseNumber *mPulseAccessorMockForPulseNumber) Inspect(f func(ctx context.Context, p1 insolar.PulseNumber)) *mPulseAccessorMockForPulseNumber {
	if mmForPulseNumber.mock.inspectFuncForPulseNumber != nil {
		mmForPulseNumber.mock.t.Fatalf("Inspect function is already set for PulseAccessorMock.ForPulseNumber")
	}

	mmForPulseNumber.mock.inspectFuncForPulseNumber = f

	return mmForPulseNumber
}

// Return sets up results that will be returned by PulseAccessor.ForPulseNumber
func (mmForPulseNumber *mPulseAccessorMockForPulseNumber) Return(p2 insolar.PulseNumber, err error) *PulseAccessorMock {
	if mmForPulseNumber.mock.funcForPulseNumber != nil {
		mmForPulseNumber.mock.t.Fatalf("PulseAccessorMock.ForPulseNumber mock is already set by Set")
	}

	if mmForPulseNumber.defaultExpectation == nil {
		mmForPulseNumber.defaultExpectation = &PulseAccessorMockForPulseNumberExpectation{mock: mmForPulseNumber.mock}
	}
	mmForPulseNumber.defaultExpectation.results = &PulseAccessorMockForPulseNumberResults{p2, err}
	return mmForPulseNumber.mock
}

//Set uses given function f to mock the PulseAccessor.ForPulseNumber method
func (mmForPulseNumber *mPulseAccessorMockForPulseNumber) Set(f func(ctx context.Context, p1 insolar.PulseNumber) (p2 insolar.PulseNumber, err error)) *PulseAccessorMock {
	if mmForPulseNumber.defaultExpectation != nil {
		mmForPulseNumber.mock.t.Fatalf("Default expectation is already set for the PulseAccessor.ForPulseNumber method")
	}

	if len(mmForPulseNumber.expectations) > 0 {
		mmForPulseNumber.mock.t.Fatalf("Some expectations are already set for the PulseAccessor.ForPulseNumber method")
	}

	mmForPulseNumber.mock.funcForPulseNumber = f
	return mmForPulseNumber.mock
}

// When sets expectation for the PulseAccessor.ForPulseNumber which will trigger the result defined by the following
// Then helper
func (mmForPulseNumber *mPulseAccessorMockForPulseNumber) When(ctx context.Context, p1 insolar.PulseNumber) *PulseAccessorMockForPulseNumberExpectation {
	if mmForPulseNumber.mock.funcForPulseNumber != nil {
		mmForPulseNumber.mock.t.Fatalf("PulseAccessorMock.ForPulseNumber mock is already set by Set")
	}

	expectation := &PulseAccessorMockForPulseNumberExpectation{
		mock:   mmForPulseNumber.mock,
		params: &PulseAccessorMockForPulseNumberParams{ctx, p1},
	}
	mmForPulseNumber.expectations = append(mmForPulseNumber.expectations, expectation)
	return expectation
}

// Then sets up PulseAccessor.ForPulseNumber return parameters for the expectation previously defined by the When method
func (e *PulseAccessorMockForPulseNumberExpectation) Then(p2 insolar.PulseNumber, err error) *PulseAccessorMock {
	e.results = &PulseAccessorMockForPulseNumberResults{p2, err}
	return e.mock
}

// ForPulseNumber implements storage.PulseAccessor
func (mmForPulseNumber *PulseAccessorMock) ForPulseNumber(ctx context.Context, p1 insolar.PulseNumber) (p2 insolar.PulseNumber, err error) {
	mm_atomic.AddUint64(&mmForPulseNumber.beforeForPulseNumberCounter, 1)
	defer mm_atomic.AddUint64(&mmForPulseNumber.afterForPulseNumberCounter, 1)

	if mmForPulseNumber.inspectFuncForPulseNumber != nil {
		mmForPulseNumber.inspectFuncForPulseNumber(ctx, p1)
	}

	params := &PulseAccessorMockForPulseNumberParams{ctx, p1}

	// Record call args
	mmForPulseNumber.ForPulseNumberMock.mutex.Lock()
	mmForPulseNumber.ForPulseNumberMock.callArgs = append(mmForPulseNumber.ForPulseNumberMock.callArgs, params)
	mmForPulseNumber.ForPulseNumberMock.mutex.Unlock()

	for _, e := range mmForPulseNumber.ForPulseNumberMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p2, e.results.err
		}
	}

	if mmForPulseNumber.ForPulseNumberMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmForPulseNumber.ForPulseNumberMock.defaultExpectation.Counter, 1)
		want := mmForPulseNumber.ForPulseNumberMock.defaultExpectation.params
		got := PulseAccessorMockForPulseNumberParams{ctx, p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmForPulseNumber.t.Errorf("PulseAccessorMock.ForPulseNumber got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmForPulseNumber.ForPulseNumberMock.defaultExpectation.results
		if results == nil {
			mmForPulseNumber.t.Fatal("No results are set for the PulseAccessorMock.ForPulseNumber")
		}
		return (*results).p2, (*results).err
	}
	if mmForPulseNumber.funcForPulseNumber != nil {
		return mmForPulseNumber.funcForPulseNumber(ctx, p1)
	}
	mmForPulseNumber.t.Fatalf("Unexpected call to PulseAccessorMock.ForPulseNumber. %v %v", ctx, p1)
	return
}

// ForPulseNumberAfterCounter returns a count of finished PulseAccessorMock.ForPulseNumber invocations
func (mmForPulseNumber *PulseAccessorMock) ForPulseNumberAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmForPulseNumber.afterForPulseNumberCounter)
}

// ForPulseNumberBeforeCounter returns a count of PulseAccessorMock.ForPulseNumber invocations
func (mmForPulseNumber *PulseAccessorMock) ForPulseNumberBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmForPulseNumber.beforeForPulseNumberCounter)
}

// Calls returns a list of arguments used in each call to PulseAccessorMock.ForPulseNumber.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmForPulseNumber *mPulseAccessorMockForPulseNumber) Calls() []*PulseAccessorMockForPulseNumberParams {
	mmForPulseNumber.mutex.RLock()

	argCopy := make([]*PulseAccessorMockForPulseNumberParams, len(mmForPulseNumber.callArgs))
	copy(argCopy, mmForPulseNumber.callArgs)

	mmForPulseNumber.mutex.RUnlock()

	return argCopy
}

// MinimockForPulseNumberDone returns true if the count of the ForPulseNumber invocations corresponds
// the number of defined expectations
func (m *PulseAccessorMock) MinimockForPulseNumberDone() bool {
	for _, e := range m.ForPulseNumberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ForPulseNumberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterForPulseNumberCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcForPulseNumber != nil && mm_atomic.LoadUint64(&m.afterForPulseNumberCounter) < 1 {
		return false
	}
	return true
}

// MinimockForPulseNumberInspect logs each unmet expectation
func (m *PulseAccessorMock) MinimockForPulseNumberInspect() {
	for _, e := range m.ForPulseNumberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PulseAccessorMock.ForPulseNumber with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ForPulseNumberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterForPulseNumberCounter) < 1 {
		if m.ForPulseNumberMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PulseAccessorMock.ForPulseNumber")
		} else {
			m.t.Errorf("Expected call to PulseAccessorMock.ForPulseNumber with params: %#v", *m.ForPulseNumberMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcForPulseNumber != nil && mm_atomic.LoadUint64(&m.afterForPulseNumberCounter) < 1 {
		m.t.Error("Expected call to PulseAccessorMock.ForPulseNumber")
	}
}

type mPulseAccessorMockLatest struct {
	mock               *PulseAccessorMock
	defaultExpectation *PulseAccessorMockLatestExpectation
	expectations       []*PulseAccessorMockLatestExpectation

	callArgs []*PulseAccessorMockLatestParams
	mutex    sync.RWMutex
}

// PulseAccessorMockLatestExpectation specifies expectation struct of the PulseAccessor.Latest
type PulseAccessorMockLatestExpectation struct {
	mock    *PulseAccessorMock
	params  *PulseAccessorMockLatestParams
	results *PulseAccessorMockLatestResults
	Counter uint64
}

// PulseAccessorMockLatestParams contains parameters of the PulseAccessor.Latest
type PulseAccessorMockLatestParams struct {
	ctx context.Context
}

// PulseAccessorMockLatestResults contains results of the PulseAccessor.Latest
type PulseAccessorMockLatestResults struct {
	p1  insolar.Pulse
	err error
}

// Expect sets up expected params for PulseAccessor.Latest
func (mmLatest *mPulseAccessorMockLatest) Expect(ctx context.Context) *mPulseAccessorMockLatest {
	if mmLatest.mock.funcLatest != nil {
		mmLatest.mock.t.Fatalf("PulseAccessorMock.Latest mock is already set by Set")
	}

	if mmLatest.defaultExpectation == nil {
		mmLatest.defaultExpectation = &PulseAccessorMockLatestExpectation{}
	}

	mmLatest.defaultExpectation.params = &PulseAccessorMockLatestParams{ctx}
	for _, e := range mmLatest.expectations {
		if minimock.Equal(e.params, mmLatest.defaultExpectation.params) {
			mmLatest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLatest.defaultExpectation.params)
		}
	}

	return mmLatest
}

// Inspect accepts an inspector function that has same arguments as the PulseAccessor.Latest
func (mmLatest *mPulseAccessorMockLatest) Inspect(f func(ctx context.Context)) *mPulseAccessorMockLatest {
	if mmLatest.mock.inspectFuncLatest != nil {
		mmLatest.mock.t.Fatalf("Inspect function is already set for PulseAccessorMock.Latest")
	}

	mmLatest.mock.inspectFuncLatest = f

	return mmLatest
}

// Return sets up results that will be returned by PulseAccessor.Latest
func (mmLatest *mPulseAccessorMockLatest) Return(p1 insolar.Pulse, err error) *PulseAccessorMock {
	if mmLatest.mock.funcLatest != nil {
		mmLatest.mock.t.Fatalf("PulseAccessorMock.Latest mock is already set by Set")
	}

	if mmLatest.defaultExpectation == nil {
		mmLatest.defaultExpectation = &PulseAccessorMockLatestExpectation{mock: mmLatest.mock}
	}
	mmLatest.defaultExpectation.results = &PulseAccessorMockLatestResults{p1, err}
	return mmLatest.mock
}

//Set uses given function f to mock the PulseAccessor.Latest method
func (mmLatest *mPulseAccessorMockLatest) Set(f func(ctx context.Context) (p1 insolar.Pulse, err error)) *PulseAccessorMock {
	if mmLatest.defaultExpectation != nil {
		mmLatest.mock.t.Fatalf("Default expectation is already set for the PulseAccessor.Latest method")
	}

	if len(mmLatest.expectations) > 0 {
		mmLatest.mock.t.Fatalf("Some expectations are already set for the PulseAccessor.Latest method")
	}

	mmLatest.mock.funcLatest = f
	return mmLatest.mock
}

// When sets expectation for the PulseAccessor.Latest which will trigger the result defined by the following
// Then helper
func (mmLatest *mPulseAccessorMockLatest) When(ctx context.Context) *PulseAccessorMockLatestExpectation {
	if mmLatest.mock.funcLatest != nil {
		mmLatest.mock.t.Fatalf("PulseAccessorMock.Latest mock is already set by Set")
	}

	expectation := &PulseAccessorMockLatestExpectation{
		mock:   mmLatest.mock,
		params: &PulseAccessorMockLatestParams{ctx},
	}
	mmLatest.expectations = append(mmLatest.expectations, expectation)
	return expectation
}

// Then sets up PulseAccessor.Latest return parameters for the expectation previously defined by the When method
func (e *PulseAccessorMockLatestExpectation) Then(p1 insolar.Pulse, err error) *PulseAccessorMock {
	e.results = &PulseAccessorMockLatestResults{p1, err}
	return e.mock
}

// Latest implements storage.PulseAccessor
func (mmLatest *PulseAccessorMock) Latest(ctx context.Context) (p1 insolar.Pulse, err error) {
	mm_atomic.AddUint64(&mmLatest.beforeLatestCounter, 1)
	defer mm_atomic.AddUint64(&mmLatest.afterLatestCounter, 1)

	if mmLatest.inspectFuncLatest != nil {
		mmLatest.inspectFuncLatest(ctx)
	}

	params := &PulseAccessorMockLatestParams{ctx}

	// Record call args
	mmLatest.LatestMock.mutex.Lock()
	mmLatest.LatestMock.callArgs = append(mmLatest.LatestMock.callArgs, params)
	mmLatest.LatestMock.mutex.Unlock()

	for _, e := range mmLatest.LatestMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmLatest.LatestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLatest.LatestMock.defaultExpectation.Counter, 1)
		want := mmLatest.LatestMock.defaultExpectation.params
		got := PulseAccessorMockLatestParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmLatest.t.Errorf("PulseAccessorMock.Latest got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmLatest.LatestMock.defaultExpectation.results
		if results == nil {
			mmLatest.t.Fatal("No results are set for the PulseAccessorMock.Latest")
		}
		return (*results).p1, (*results).err
	}
	if mmLatest.funcLatest != nil {
		return mmLatest.funcLatest(ctx)
	}
	mmLatest.t.Fatalf("Unexpected call to PulseAccessorMock.Latest. %v", ctx)
	return
}

// LatestAfterCounter returns a count of finished PulseAccessorMock.Latest invocations
func (mmLatest *PulseAccessorMock) LatestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLatest.afterLatestCounter)
}

// LatestBeforeCounter returns a count of PulseAccessorMock.Latest invocations
func (mmLatest *PulseAccessorMock) LatestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLatest.beforeLatestCounter)
}

// Calls returns a list of arguments used in each call to PulseAccessorMock.Latest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLatest *mPulseAccessorMockLatest) Calls() []*PulseAccessorMockLatestParams {
	mmLatest.mutex.RLock()

	argCopy := make([]*PulseAccessorMockLatestParams, len(mmLatest.callArgs))
	copy(argCopy, mmLatest.callArgs)

	mmLatest.mutex.RUnlock()

	return argCopy
}

// MinimockLatestDone returns true if the count of the Latest invocations corresponds
// the number of defined expectations
func (m *PulseAccessorMock) MinimockLatestDone() bool {
	for _, e := range m.LatestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LatestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLatestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLatest != nil && mm_atomic.LoadUint64(&m.afterLatestCounter) < 1 {
		return false
	}
	return true
}

// MinimockLatestInspect logs each unmet expectation
func (m *PulseAccessorMock) MinimockLatestInspect() {
	for _, e := range m.LatestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PulseAccessorMock.Latest with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LatestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLatestCounter) < 1 {
		if m.LatestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PulseAccessorMock.Latest")
		} else {
			m.t.Errorf("Expected call to PulseAccessorMock.Latest with params: %#v", *m.LatestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLatest != nil && mm_atomic.LoadUint64(&m.afterLatestCounter) < 1 {
		m.t.Error("Expected call to PulseAccessorMock.Latest")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PulseAccessorMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockForPulseNumberInspect()

		m.MinimockLatestInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PulseAccessorMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PulseAccessorMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockForPulseNumberDone() &&
		m.MinimockLatestDone()
}
