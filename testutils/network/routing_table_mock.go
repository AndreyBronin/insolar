package network

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
	mm_network "github.com/insolar/insolar/network"
	"github.com/insolar/insolar/network/hostnetwork/host"
)

// RoutingTableMock implements network.RoutingTable
type RoutingTableMock struct {
	t minimock.Tester

	funcAddToKnownHosts          func(hp1 *host.Host)
	inspectFuncAddToKnownHosts   func(hp1 *host.Host)
	afterAddToKnownHostsCounter  uint64
	beforeAddToKnownHostsCounter uint64
	AddToKnownHostsMock          mRoutingTableMockAddToKnownHosts

	funcRebalance          func(p1 mm_network.PartitionPolicy)
	inspectFuncRebalance   func(p1 mm_network.PartitionPolicy)
	afterRebalanceCounter  uint64
	beforeRebalanceCounter uint64
	RebalanceMock          mRoutingTableMockRebalance

	funcResolve          func(r1 insolar.Reference) (hp1 *host.Host, err error)
	inspectFuncResolve   func(r1 insolar.Reference)
	afterResolveCounter  uint64
	beforeResolveCounter uint64
	ResolveMock          mRoutingTableMockResolve

	funcResolveConsensus          func(s1 insolar.ShortNodeID) (hp1 *host.Host, err error)
	inspectFuncResolveConsensus   func(s1 insolar.ShortNodeID)
	afterResolveConsensusCounter  uint64
	beforeResolveConsensusCounter uint64
	ResolveConsensusMock          mRoutingTableMockResolveConsensus

	funcResolveConsensusRef          func(r1 insolar.Reference) (hp1 *host.Host, err error)
	inspectFuncResolveConsensusRef   func(r1 insolar.Reference)
	afterResolveConsensusRefCounter  uint64
	beforeResolveConsensusRefCounter uint64
	ResolveConsensusRefMock          mRoutingTableMockResolveConsensusRef
}

// NewRoutingTableMock returns a mock for network.RoutingTable
func NewRoutingTableMock(t minimock.Tester) *RoutingTableMock {
	m := &RoutingTableMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddToKnownHostsMock = mRoutingTableMockAddToKnownHosts{mock: m}
	m.AddToKnownHostsMock.callArgs = []*RoutingTableMockAddToKnownHostsParams{}

	m.RebalanceMock = mRoutingTableMockRebalance{mock: m}
	m.RebalanceMock.callArgs = []*RoutingTableMockRebalanceParams{}

	m.ResolveMock = mRoutingTableMockResolve{mock: m}
	m.ResolveMock.callArgs = []*RoutingTableMockResolveParams{}

	m.ResolveConsensusMock = mRoutingTableMockResolveConsensus{mock: m}
	m.ResolveConsensusMock.callArgs = []*RoutingTableMockResolveConsensusParams{}

	m.ResolveConsensusRefMock = mRoutingTableMockResolveConsensusRef{mock: m}
	m.ResolveConsensusRefMock.callArgs = []*RoutingTableMockResolveConsensusRefParams{}

	return m
}

type mRoutingTableMockAddToKnownHosts struct {
	mock               *RoutingTableMock
	defaultExpectation *RoutingTableMockAddToKnownHostsExpectation
	expectations       []*RoutingTableMockAddToKnownHostsExpectation

	callArgs []*RoutingTableMockAddToKnownHostsParams
	mutex    sync.RWMutex
}

// RoutingTableMockAddToKnownHostsExpectation specifies expectation struct of the RoutingTable.AddToKnownHosts
type RoutingTableMockAddToKnownHostsExpectation struct {
	mock   *RoutingTableMock
	params *RoutingTableMockAddToKnownHostsParams

	Counter uint64
}

// RoutingTableMockAddToKnownHostsParams contains parameters of the RoutingTable.AddToKnownHosts
type RoutingTableMockAddToKnownHostsParams struct {
	hp1 *host.Host
}

// Expect sets up expected params for RoutingTable.AddToKnownHosts
func (mmAddToKnownHosts *mRoutingTableMockAddToKnownHosts) Expect(hp1 *host.Host) *mRoutingTableMockAddToKnownHosts {
	if mmAddToKnownHosts.mock.funcAddToKnownHosts != nil {
		mmAddToKnownHosts.mock.t.Fatalf("RoutingTableMock.AddToKnownHosts mock is already set by Set")
	}

	if mmAddToKnownHosts.defaultExpectation == nil {
		mmAddToKnownHosts.defaultExpectation = &RoutingTableMockAddToKnownHostsExpectation{}
	}

	mmAddToKnownHosts.defaultExpectation.params = &RoutingTableMockAddToKnownHostsParams{hp1}
	for _, e := range mmAddToKnownHosts.expectations {
		if minimock.Equal(e.params, mmAddToKnownHosts.defaultExpectation.params) {
			mmAddToKnownHosts.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddToKnownHosts.defaultExpectation.params)
		}
	}

	return mmAddToKnownHosts
}

// Inspect accepts an inspector function that has same arguments as the RoutingTable.AddToKnownHosts
func (mmAddToKnownHosts *mRoutingTableMockAddToKnownHosts) Inspect(f func(hp1 *host.Host)) *mRoutingTableMockAddToKnownHosts {
	if mmAddToKnownHosts.mock.inspectFuncAddToKnownHosts != nil {
		mmAddToKnownHosts.mock.t.Fatalf("Inspect function is already set for RoutingTableMock.AddToKnownHosts")
	}

	mmAddToKnownHosts.mock.inspectFuncAddToKnownHosts = f

	return mmAddToKnownHosts
}

// Return sets up results that will be returned by RoutingTable.AddToKnownHosts
func (mmAddToKnownHosts *mRoutingTableMockAddToKnownHosts) Return() *RoutingTableMock {
	if mmAddToKnownHosts.mock.funcAddToKnownHosts != nil {
		mmAddToKnownHosts.mock.t.Fatalf("RoutingTableMock.AddToKnownHosts mock is already set by Set")
	}

	if mmAddToKnownHosts.defaultExpectation == nil {
		mmAddToKnownHosts.defaultExpectation = &RoutingTableMockAddToKnownHostsExpectation{mock: mmAddToKnownHosts.mock}
	}

	return mmAddToKnownHosts.mock
}

//Set uses given function f to mock the RoutingTable.AddToKnownHosts method
func (mmAddToKnownHosts *mRoutingTableMockAddToKnownHosts) Set(f func(hp1 *host.Host)) *RoutingTableMock {
	if mmAddToKnownHosts.defaultExpectation != nil {
		mmAddToKnownHosts.mock.t.Fatalf("Default expectation is already set for the RoutingTable.AddToKnownHosts method")
	}

	if len(mmAddToKnownHosts.expectations) > 0 {
		mmAddToKnownHosts.mock.t.Fatalf("Some expectations are already set for the RoutingTable.AddToKnownHosts method")
	}

	mmAddToKnownHosts.mock.funcAddToKnownHosts = f
	return mmAddToKnownHosts.mock
}

// AddToKnownHosts implements network.RoutingTable
func (mmAddToKnownHosts *RoutingTableMock) AddToKnownHosts(hp1 *host.Host) {
	mm_atomic.AddUint64(&mmAddToKnownHosts.beforeAddToKnownHostsCounter, 1)
	defer mm_atomic.AddUint64(&mmAddToKnownHosts.afterAddToKnownHostsCounter, 1)

	if mmAddToKnownHosts.inspectFuncAddToKnownHosts != nil {
		mmAddToKnownHosts.inspectFuncAddToKnownHosts(hp1)
	}

	params := &RoutingTableMockAddToKnownHostsParams{hp1}

	// Record call args
	mmAddToKnownHosts.AddToKnownHostsMock.mutex.Lock()
	mmAddToKnownHosts.AddToKnownHostsMock.callArgs = append(mmAddToKnownHosts.AddToKnownHostsMock.callArgs, params)
	mmAddToKnownHosts.AddToKnownHostsMock.mutex.Unlock()

	for _, e := range mmAddToKnownHosts.AddToKnownHostsMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddToKnownHosts.AddToKnownHostsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddToKnownHosts.AddToKnownHostsMock.defaultExpectation.Counter, 1)
		want := mmAddToKnownHosts.AddToKnownHostsMock.defaultExpectation.params
		got := RoutingTableMockAddToKnownHostsParams{hp1}
		if want != nil && !minimock.Equal(*want, got) {
			mmAddToKnownHosts.t.Errorf("RoutingTableMock.AddToKnownHosts got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmAddToKnownHosts.funcAddToKnownHosts != nil {
		mmAddToKnownHosts.funcAddToKnownHosts(hp1)
		return
	}
	mmAddToKnownHosts.t.Fatalf("Unexpected call to RoutingTableMock.AddToKnownHosts. %v", hp1)

}

// AddToKnownHostsAfterCounter returns a count of finished RoutingTableMock.AddToKnownHosts invocations
func (mmAddToKnownHosts *RoutingTableMock) AddToKnownHostsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToKnownHosts.afterAddToKnownHostsCounter)
}

// AddToKnownHostsBeforeCounter returns a count of RoutingTableMock.AddToKnownHosts invocations
func (mmAddToKnownHosts *RoutingTableMock) AddToKnownHostsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToKnownHosts.beforeAddToKnownHostsCounter)
}

// Calls returns a list of arguments used in each call to RoutingTableMock.AddToKnownHosts.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddToKnownHosts *mRoutingTableMockAddToKnownHosts) Calls() []*RoutingTableMockAddToKnownHostsParams {
	mmAddToKnownHosts.mutex.RLock()

	argCopy := make([]*RoutingTableMockAddToKnownHostsParams, len(mmAddToKnownHosts.callArgs))
	copy(argCopy, mmAddToKnownHosts.callArgs)

	mmAddToKnownHosts.mutex.RUnlock()

	return argCopy
}

// MinimockAddToKnownHostsDone returns true if the count of the AddToKnownHosts invocations corresponds
// the number of defined expectations
func (m *RoutingTableMock) MinimockAddToKnownHostsDone() bool {
	for _, e := range m.AddToKnownHostsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddToKnownHostsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddToKnownHostsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToKnownHosts != nil && mm_atomic.LoadUint64(&m.afterAddToKnownHostsCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddToKnownHostsInspect logs each unmet expectation
func (m *RoutingTableMock) MinimockAddToKnownHostsInspect() {
	for _, e := range m.AddToKnownHostsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RoutingTableMock.AddToKnownHosts with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddToKnownHostsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddToKnownHostsCounter) < 1 {
		if m.AddToKnownHostsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RoutingTableMock.AddToKnownHosts")
		} else {
			m.t.Errorf("Expected call to RoutingTableMock.AddToKnownHosts with params: %#v", *m.AddToKnownHostsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToKnownHosts != nil && mm_atomic.LoadUint64(&m.afterAddToKnownHostsCounter) < 1 {
		m.t.Error("Expected call to RoutingTableMock.AddToKnownHosts")
	}
}

type mRoutingTableMockRebalance struct {
	mock               *RoutingTableMock
	defaultExpectation *RoutingTableMockRebalanceExpectation
	expectations       []*RoutingTableMockRebalanceExpectation

	callArgs []*RoutingTableMockRebalanceParams
	mutex    sync.RWMutex
}

// RoutingTableMockRebalanceExpectation specifies expectation struct of the RoutingTable.Rebalance
type RoutingTableMockRebalanceExpectation struct {
	mock   *RoutingTableMock
	params *RoutingTableMockRebalanceParams

	Counter uint64
}

// RoutingTableMockRebalanceParams contains parameters of the RoutingTable.Rebalance
type RoutingTableMockRebalanceParams struct {
	p1 mm_network.PartitionPolicy
}

// Expect sets up expected params for RoutingTable.Rebalance
func (mmRebalance *mRoutingTableMockRebalance) Expect(p1 mm_network.PartitionPolicy) *mRoutingTableMockRebalance {
	if mmRebalance.mock.funcRebalance != nil {
		mmRebalance.mock.t.Fatalf("RoutingTableMock.Rebalance mock is already set by Set")
	}

	if mmRebalance.defaultExpectation == nil {
		mmRebalance.defaultExpectation = &RoutingTableMockRebalanceExpectation{}
	}

	mmRebalance.defaultExpectation.params = &RoutingTableMockRebalanceParams{p1}
	for _, e := range mmRebalance.expectations {
		if minimock.Equal(e.params, mmRebalance.defaultExpectation.params) {
			mmRebalance.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRebalance.defaultExpectation.params)
		}
	}

	return mmRebalance
}

// Inspect accepts an inspector function that has same arguments as the RoutingTable.Rebalance
func (mmRebalance *mRoutingTableMockRebalance) Inspect(f func(p1 mm_network.PartitionPolicy)) *mRoutingTableMockRebalance {
	if mmRebalance.mock.inspectFuncRebalance != nil {
		mmRebalance.mock.t.Fatalf("Inspect function is already set for RoutingTableMock.Rebalance")
	}

	mmRebalance.mock.inspectFuncRebalance = f

	return mmRebalance
}

// Return sets up results that will be returned by RoutingTable.Rebalance
func (mmRebalance *mRoutingTableMockRebalance) Return() *RoutingTableMock {
	if mmRebalance.mock.funcRebalance != nil {
		mmRebalance.mock.t.Fatalf("RoutingTableMock.Rebalance mock is already set by Set")
	}

	if mmRebalance.defaultExpectation == nil {
		mmRebalance.defaultExpectation = &RoutingTableMockRebalanceExpectation{mock: mmRebalance.mock}
	}

	return mmRebalance.mock
}

//Set uses given function f to mock the RoutingTable.Rebalance method
func (mmRebalance *mRoutingTableMockRebalance) Set(f func(p1 mm_network.PartitionPolicy)) *RoutingTableMock {
	if mmRebalance.defaultExpectation != nil {
		mmRebalance.mock.t.Fatalf("Default expectation is already set for the RoutingTable.Rebalance method")
	}

	if len(mmRebalance.expectations) > 0 {
		mmRebalance.mock.t.Fatalf("Some expectations are already set for the RoutingTable.Rebalance method")
	}

	mmRebalance.mock.funcRebalance = f
	return mmRebalance.mock
}

// Rebalance implements network.RoutingTable
func (mmRebalance *RoutingTableMock) Rebalance(p1 mm_network.PartitionPolicy) {
	mm_atomic.AddUint64(&mmRebalance.beforeRebalanceCounter, 1)
	defer mm_atomic.AddUint64(&mmRebalance.afterRebalanceCounter, 1)

	if mmRebalance.inspectFuncRebalance != nil {
		mmRebalance.inspectFuncRebalance(p1)
	}

	params := &RoutingTableMockRebalanceParams{p1}

	// Record call args
	mmRebalance.RebalanceMock.mutex.Lock()
	mmRebalance.RebalanceMock.callArgs = append(mmRebalance.RebalanceMock.callArgs, params)
	mmRebalance.RebalanceMock.mutex.Unlock()

	for _, e := range mmRebalance.RebalanceMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmRebalance.RebalanceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRebalance.RebalanceMock.defaultExpectation.Counter, 1)
		want := mmRebalance.RebalanceMock.defaultExpectation.params
		got := RoutingTableMockRebalanceParams{p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmRebalance.t.Errorf("RoutingTableMock.Rebalance got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmRebalance.funcRebalance != nil {
		mmRebalance.funcRebalance(p1)
		return
	}
	mmRebalance.t.Fatalf("Unexpected call to RoutingTableMock.Rebalance. %v", p1)

}

// RebalanceAfterCounter returns a count of finished RoutingTableMock.Rebalance invocations
func (mmRebalance *RoutingTableMock) RebalanceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRebalance.afterRebalanceCounter)
}

// RebalanceBeforeCounter returns a count of RoutingTableMock.Rebalance invocations
func (mmRebalance *RoutingTableMock) RebalanceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRebalance.beforeRebalanceCounter)
}

// Calls returns a list of arguments used in each call to RoutingTableMock.Rebalance.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRebalance *mRoutingTableMockRebalance) Calls() []*RoutingTableMockRebalanceParams {
	mmRebalance.mutex.RLock()

	argCopy := make([]*RoutingTableMockRebalanceParams, len(mmRebalance.callArgs))
	copy(argCopy, mmRebalance.callArgs)

	mmRebalance.mutex.RUnlock()

	return argCopy
}

// MinimockRebalanceDone returns true if the count of the Rebalance invocations corresponds
// the number of defined expectations
func (m *RoutingTableMock) MinimockRebalanceDone() bool {
	for _, e := range m.RebalanceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RebalanceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRebalanceCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRebalance != nil && mm_atomic.LoadUint64(&m.afterRebalanceCounter) < 1 {
		return false
	}
	return true
}

// MinimockRebalanceInspect logs each unmet expectation
func (m *RoutingTableMock) MinimockRebalanceInspect() {
	for _, e := range m.RebalanceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RoutingTableMock.Rebalance with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RebalanceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRebalanceCounter) < 1 {
		if m.RebalanceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RoutingTableMock.Rebalance")
		} else {
			m.t.Errorf("Expected call to RoutingTableMock.Rebalance with params: %#v", *m.RebalanceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRebalance != nil && mm_atomic.LoadUint64(&m.afterRebalanceCounter) < 1 {
		m.t.Error("Expected call to RoutingTableMock.Rebalance")
	}
}

type mRoutingTableMockResolve struct {
	mock               *RoutingTableMock
	defaultExpectation *RoutingTableMockResolveExpectation
	expectations       []*RoutingTableMockResolveExpectation

	callArgs []*RoutingTableMockResolveParams
	mutex    sync.RWMutex
}

// RoutingTableMockResolveExpectation specifies expectation struct of the RoutingTable.Resolve
type RoutingTableMockResolveExpectation struct {
	mock    *RoutingTableMock
	params  *RoutingTableMockResolveParams
	results *RoutingTableMockResolveResults
	Counter uint64
}

// RoutingTableMockResolveParams contains parameters of the RoutingTable.Resolve
type RoutingTableMockResolveParams struct {
	r1 insolar.Reference
}

// RoutingTableMockResolveResults contains results of the RoutingTable.Resolve
type RoutingTableMockResolveResults struct {
	hp1 *host.Host
	err error
}

// Expect sets up expected params for RoutingTable.Resolve
func (mmResolve *mRoutingTableMockResolve) Expect(r1 insolar.Reference) *mRoutingTableMockResolve {
	if mmResolve.mock.funcResolve != nil {
		mmResolve.mock.t.Fatalf("RoutingTableMock.Resolve mock is already set by Set")
	}

	if mmResolve.defaultExpectation == nil {
		mmResolve.defaultExpectation = &RoutingTableMockResolveExpectation{}
	}

	mmResolve.defaultExpectation.params = &RoutingTableMockResolveParams{r1}
	for _, e := range mmResolve.expectations {
		if minimock.Equal(e.params, mmResolve.defaultExpectation.params) {
			mmResolve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmResolve.defaultExpectation.params)
		}
	}

	return mmResolve
}

// Inspect accepts an inspector function that has same arguments as the RoutingTable.Resolve
func (mmResolve *mRoutingTableMockResolve) Inspect(f func(r1 insolar.Reference)) *mRoutingTableMockResolve {
	if mmResolve.mock.inspectFuncResolve != nil {
		mmResolve.mock.t.Fatalf("Inspect function is already set for RoutingTableMock.Resolve")
	}

	mmResolve.mock.inspectFuncResolve = f

	return mmResolve
}

// Return sets up results that will be returned by RoutingTable.Resolve
func (mmResolve *mRoutingTableMockResolve) Return(hp1 *host.Host, err error) *RoutingTableMock {
	if mmResolve.mock.funcResolve != nil {
		mmResolve.mock.t.Fatalf("RoutingTableMock.Resolve mock is already set by Set")
	}

	if mmResolve.defaultExpectation == nil {
		mmResolve.defaultExpectation = &RoutingTableMockResolveExpectation{mock: mmResolve.mock}
	}
	mmResolve.defaultExpectation.results = &RoutingTableMockResolveResults{hp1, err}
	return mmResolve.mock
}

//Set uses given function f to mock the RoutingTable.Resolve method
func (mmResolve *mRoutingTableMockResolve) Set(f func(r1 insolar.Reference) (hp1 *host.Host, err error)) *RoutingTableMock {
	if mmResolve.defaultExpectation != nil {
		mmResolve.mock.t.Fatalf("Default expectation is already set for the RoutingTable.Resolve method")
	}

	if len(mmResolve.expectations) > 0 {
		mmResolve.mock.t.Fatalf("Some expectations are already set for the RoutingTable.Resolve method")
	}

	mmResolve.mock.funcResolve = f
	return mmResolve.mock
}

// When sets expectation for the RoutingTable.Resolve which will trigger the result defined by the following
// Then helper
func (mmResolve *mRoutingTableMockResolve) When(r1 insolar.Reference) *RoutingTableMockResolveExpectation {
	if mmResolve.mock.funcResolve != nil {
		mmResolve.mock.t.Fatalf("RoutingTableMock.Resolve mock is already set by Set")
	}

	expectation := &RoutingTableMockResolveExpectation{
		mock:   mmResolve.mock,
		params: &RoutingTableMockResolveParams{r1},
	}
	mmResolve.expectations = append(mmResolve.expectations, expectation)
	return expectation
}

// Then sets up RoutingTable.Resolve return parameters for the expectation previously defined by the When method
func (e *RoutingTableMockResolveExpectation) Then(hp1 *host.Host, err error) *RoutingTableMock {
	e.results = &RoutingTableMockResolveResults{hp1, err}
	return e.mock
}

// Resolve implements network.RoutingTable
func (mmResolve *RoutingTableMock) Resolve(r1 insolar.Reference) (hp1 *host.Host, err error) {
	mm_atomic.AddUint64(&mmResolve.beforeResolveCounter, 1)
	defer mm_atomic.AddUint64(&mmResolve.afterResolveCounter, 1)

	if mmResolve.inspectFuncResolve != nil {
		mmResolve.inspectFuncResolve(r1)
	}

	params := &RoutingTableMockResolveParams{r1}

	// Record call args
	mmResolve.ResolveMock.mutex.Lock()
	mmResolve.ResolveMock.callArgs = append(mmResolve.ResolveMock.callArgs, params)
	mmResolve.ResolveMock.mutex.Unlock()

	for _, e := range mmResolve.ResolveMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.hp1, e.results.err
		}
	}

	if mmResolve.ResolveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmResolve.ResolveMock.defaultExpectation.Counter, 1)
		want := mmResolve.ResolveMock.defaultExpectation.params
		got := RoutingTableMockResolveParams{r1}
		if want != nil && !minimock.Equal(*want, got) {
			mmResolve.t.Errorf("RoutingTableMock.Resolve got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmResolve.ResolveMock.defaultExpectation.results
		if results == nil {
			mmResolve.t.Fatal("No results are set for the RoutingTableMock.Resolve")
		}
		return (*results).hp1, (*results).err
	}
	if mmResolve.funcResolve != nil {
		return mmResolve.funcResolve(r1)
	}
	mmResolve.t.Fatalf("Unexpected call to RoutingTableMock.Resolve. %v", r1)
	return
}

// ResolveAfterCounter returns a count of finished RoutingTableMock.Resolve invocations
func (mmResolve *RoutingTableMock) ResolveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmResolve.afterResolveCounter)
}

// ResolveBeforeCounter returns a count of RoutingTableMock.Resolve invocations
func (mmResolve *RoutingTableMock) ResolveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmResolve.beforeResolveCounter)
}

// Calls returns a list of arguments used in each call to RoutingTableMock.Resolve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmResolve *mRoutingTableMockResolve) Calls() []*RoutingTableMockResolveParams {
	mmResolve.mutex.RLock()

	argCopy := make([]*RoutingTableMockResolveParams, len(mmResolve.callArgs))
	copy(argCopy, mmResolve.callArgs)

	mmResolve.mutex.RUnlock()

	return argCopy
}

// MinimockResolveDone returns true if the count of the Resolve invocations corresponds
// the number of defined expectations
func (m *RoutingTableMock) MinimockResolveDone() bool {
	for _, e := range m.ResolveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ResolveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterResolveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcResolve != nil && mm_atomic.LoadUint64(&m.afterResolveCounter) < 1 {
		return false
	}
	return true
}

// MinimockResolveInspect logs each unmet expectation
func (m *RoutingTableMock) MinimockResolveInspect() {
	for _, e := range m.ResolveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RoutingTableMock.Resolve with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ResolveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterResolveCounter) < 1 {
		if m.ResolveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RoutingTableMock.Resolve")
		} else {
			m.t.Errorf("Expected call to RoutingTableMock.Resolve with params: %#v", *m.ResolveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcResolve != nil && mm_atomic.LoadUint64(&m.afterResolveCounter) < 1 {
		m.t.Error("Expected call to RoutingTableMock.Resolve")
	}
}

type mRoutingTableMockResolveConsensus struct {
	mock               *RoutingTableMock
	defaultExpectation *RoutingTableMockResolveConsensusExpectation
	expectations       []*RoutingTableMockResolveConsensusExpectation

	callArgs []*RoutingTableMockResolveConsensusParams
	mutex    sync.RWMutex
}

// RoutingTableMockResolveConsensusExpectation specifies expectation struct of the RoutingTable.ResolveConsensus
type RoutingTableMockResolveConsensusExpectation struct {
	mock    *RoutingTableMock
	params  *RoutingTableMockResolveConsensusParams
	results *RoutingTableMockResolveConsensusResults
	Counter uint64
}

// RoutingTableMockResolveConsensusParams contains parameters of the RoutingTable.ResolveConsensus
type RoutingTableMockResolveConsensusParams struct {
	s1 insolar.ShortNodeID
}

// RoutingTableMockResolveConsensusResults contains results of the RoutingTable.ResolveConsensus
type RoutingTableMockResolveConsensusResults struct {
	hp1 *host.Host
	err error
}

// Expect sets up expected params for RoutingTable.ResolveConsensus
func (mmResolveConsensus *mRoutingTableMockResolveConsensus) Expect(s1 insolar.ShortNodeID) *mRoutingTableMockResolveConsensus {
	if mmResolveConsensus.mock.funcResolveConsensus != nil {
		mmResolveConsensus.mock.t.Fatalf("RoutingTableMock.ResolveConsensus mock is already set by Set")
	}

	if mmResolveConsensus.defaultExpectation == nil {
		mmResolveConsensus.defaultExpectation = &RoutingTableMockResolveConsensusExpectation{}
	}

	mmResolveConsensus.defaultExpectation.params = &RoutingTableMockResolveConsensusParams{s1}
	for _, e := range mmResolveConsensus.expectations {
		if minimock.Equal(e.params, mmResolveConsensus.defaultExpectation.params) {
			mmResolveConsensus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmResolveConsensus.defaultExpectation.params)
		}
	}

	return mmResolveConsensus
}

// Inspect accepts an inspector function that has same arguments as the RoutingTable.ResolveConsensus
func (mmResolveConsensus *mRoutingTableMockResolveConsensus) Inspect(f func(s1 insolar.ShortNodeID)) *mRoutingTableMockResolveConsensus {
	if mmResolveConsensus.mock.inspectFuncResolveConsensus != nil {
		mmResolveConsensus.mock.t.Fatalf("Inspect function is already set for RoutingTableMock.ResolveConsensus")
	}

	mmResolveConsensus.mock.inspectFuncResolveConsensus = f

	return mmResolveConsensus
}

// Return sets up results that will be returned by RoutingTable.ResolveConsensus
func (mmResolveConsensus *mRoutingTableMockResolveConsensus) Return(hp1 *host.Host, err error) *RoutingTableMock {
	if mmResolveConsensus.mock.funcResolveConsensus != nil {
		mmResolveConsensus.mock.t.Fatalf("RoutingTableMock.ResolveConsensus mock is already set by Set")
	}

	if mmResolveConsensus.defaultExpectation == nil {
		mmResolveConsensus.defaultExpectation = &RoutingTableMockResolveConsensusExpectation{mock: mmResolveConsensus.mock}
	}
	mmResolveConsensus.defaultExpectation.results = &RoutingTableMockResolveConsensusResults{hp1, err}
	return mmResolveConsensus.mock
}

//Set uses given function f to mock the RoutingTable.ResolveConsensus method
func (mmResolveConsensus *mRoutingTableMockResolveConsensus) Set(f func(s1 insolar.ShortNodeID) (hp1 *host.Host, err error)) *RoutingTableMock {
	if mmResolveConsensus.defaultExpectation != nil {
		mmResolveConsensus.mock.t.Fatalf("Default expectation is already set for the RoutingTable.ResolveConsensus method")
	}

	if len(mmResolveConsensus.expectations) > 0 {
		mmResolveConsensus.mock.t.Fatalf("Some expectations are already set for the RoutingTable.ResolveConsensus method")
	}

	mmResolveConsensus.mock.funcResolveConsensus = f
	return mmResolveConsensus.mock
}

// When sets expectation for the RoutingTable.ResolveConsensus which will trigger the result defined by the following
// Then helper
func (mmResolveConsensus *mRoutingTableMockResolveConsensus) When(s1 insolar.ShortNodeID) *RoutingTableMockResolveConsensusExpectation {
	if mmResolveConsensus.mock.funcResolveConsensus != nil {
		mmResolveConsensus.mock.t.Fatalf("RoutingTableMock.ResolveConsensus mock is already set by Set")
	}

	expectation := &RoutingTableMockResolveConsensusExpectation{
		mock:   mmResolveConsensus.mock,
		params: &RoutingTableMockResolveConsensusParams{s1},
	}
	mmResolveConsensus.expectations = append(mmResolveConsensus.expectations, expectation)
	return expectation
}

// Then sets up RoutingTable.ResolveConsensus return parameters for the expectation previously defined by the When method
func (e *RoutingTableMockResolveConsensusExpectation) Then(hp1 *host.Host, err error) *RoutingTableMock {
	e.results = &RoutingTableMockResolveConsensusResults{hp1, err}
	return e.mock
}

// ResolveConsensus implements network.RoutingTable
func (mmResolveConsensus *RoutingTableMock) ResolveConsensus(s1 insolar.ShortNodeID) (hp1 *host.Host, err error) {
	mm_atomic.AddUint64(&mmResolveConsensus.beforeResolveConsensusCounter, 1)
	defer mm_atomic.AddUint64(&mmResolveConsensus.afterResolveConsensusCounter, 1)

	if mmResolveConsensus.inspectFuncResolveConsensus != nil {
		mmResolveConsensus.inspectFuncResolveConsensus(s1)
	}

	params := &RoutingTableMockResolveConsensusParams{s1}

	// Record call args
	mmResolveConsensus.ResolveConsensusMock.mutex.Lock()
	mmResolveConsensus.ResolveConsensusMock.callArgs = append(mmResolveConsensus.ResolveConsensusMock.callArgs, params)
	mmResolveConsensus.ResolveConsensusMock.mutex.Unlock()

	for _, e := range mmResolveConsensus.ResolveConsensusMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.hp1, e.results.err
		}
	}

	if mmResolveConsensus.ResolveConsensusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmResolveConsensus.ResolveConsensusMock.defaultExpectation.Counter, 1)
		want := mmResolveConsensus.ResolveConsensusMock.defaultExpectation.params
		got := RoutingTableMockResolveConsensusParams{s1}
		if want != nil && !minimock.Equal(*want, got) {
			mmResolveConsensus.t.Errorf("RoutingTableMock.ResolveConsensus got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmResolveConsensus.ResolveConsensusMock.defaultExpectation.results
		if results == nil {
			mmResolveConsensus.t.Fatal("No results are set for the RoutingTableMock.ResolveConsensus")
		}
		return (*results).hp1, (*results).err
	}
	if mmResolveConsensus.funcResolveConsensus != nil {
		return mmResolveConsensus.funcResolveConsensus(s1)
	}
	mmResolveConsensus.t.Fatalf("Unexpected call to RoutingTableMock.ResolveConsensus. %v", s1)
	return
}

// ResolveConsensusAfterCounter returns a count of finished RoutingTableMock.ResolveConsensus invocations
func (mmResolveConsensus *RoutingTableMock) ResolveConsensusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmResolveConsensus.afterResolveConsensusCounter)
}

// ResolveConsensusBeforeCounter returns a count of RoutingTableMock.ResolveConsensus invocations
func (mmResolveConsensus *RoutingTableMock) ResolveConsensusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmResolveConsensus.beforeResolveConsensusCounter)
}

// Calls returns a list of arguments used in each call to RoutingTableMock.ResolveConsensus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmResolveConsensus *mRoutingTableMockResolveConsensus) Calls() []*RoutingTableMockResolveConsensusParams {
	mmResolveConsensus.mutex.RLock()

	argCopy := make([]*RoutingTableMockResolveConsensusParams, len(mmResolveConsensus.callArgs))
	copy(argCopy, mmResolveConsensus.callArgs)

	mmResolveConsensus.mutex.RUnlock()

	return argCopy
}

// MinimockResolveConsensusDone returns true if the count of the ResolveConsensus invocations corresponds
// the number of defined expectations
func (m *RoutingTableMock) MinimockResolveConsensusDone() bool {
	for _, e := range m.ResolveConsensusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ResolveConsensusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterResolveConsensusCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcResolveConsensus != nil && mm_atomic.LoadUint64(&m.afterResolveConsensusCounter) < 1 {
		return false
	}
	return true
}

// MinimockResolveConsensusInspect logs each unmet expectation
func (m *RoutingTableMock) MinimockResolveConsensusInspect() {
	for _, e := range m.ResolveConsensusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RoutingTableMock.ResolveConsensus with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ResolveConsensusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterResolveConsensusCounter) < 1 {
		if m.ResolveConsensusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RoutingTableMock.ResolveConsensus")
		} else {
			m.t.Errorf("Expected call to RoutingTableMock.ResolveConsensus with params: %#v", *m.ResolveConsensusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcResolveConsensus != nil && mm_atomic.LoadUint64(&m.afterResolveConsensusCounter) < 1 {
		m.t.Error("Expected call to RoutingTableMock.ResolveConsensus")
	}
}

type mRoutingTableMockResolveConsensusRef struct {
	mock               *RoutingTableMock
	defaultExpectation *RoutingTableMockResolveConsensusRefExpectation
	expectations       []*RoutingTableMockResolveConsensusRefExpectation

	callArgs []*RoutingTableMockResolveConsensusRefParams
	mutex    sync.RWMutex
}

// RoutingTableMockResolveConsensusRefExpectation specifies expectation struct of the RoutingTable.ResolveConsensusRef
type RoutingTableMockResolveConsensusRefExpectation struct {
	mock    *RoutingTableMock
	params  *RoutingTableMockResolveConsensusRefParams
	results *RoutingTableMockResolveConsensusRefResults
	Counter uint64
}

// RoutingTableMockResolveConsensusRefParams contains parameters of the RoutingTable.ResolveConsensusRef
type RoutingTableMockResolveConsensusRefParams struct {
	r1 insolar.Reference
}

// RoutingTableMockResolveConsensusRefResults contains results of the RoutingTable.ResolveConsensusRef
type RoutingTableMockResolveConsensusRefResults struct {
	hp1 *host.Host
	err error
}

// Expect sets up expected params for RoutingTable.ResolveConsensusRef
func (mmResolveConsensusRef *mRoutingTableMockResolveConsensusRef) Expect(r1 insolar.Reference) *mRoutingTableMockResolveConsensusRef {
	if mmResolveConsensusRef.mock.funcResolveConsensusRef != nil {
		mmResolveConsensusRef.mock.t.Fatalf("RoutingTableMock.ResolveConsensusRef mock is already set by Set")
	}

	if mmResolveConsensusRef.defaultExpectation == nil {
		mmResolveConsensusRef.defaultExpectation = &RoutingTableMockResolveConsensusRefExpectation{}
	}

	mmResolveConsensusRef.defaultExpectation.params = &RoutingTableMockResolveConsensusRefParams{r1}
	for _, e := range mmResolveConsensusRef.expectations {
		if minimock.Equal(e.params, mmResolveConsensusRef.defaultExpectation.params) {
			mmResolveConsensusRef.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmResolveConsensusRef.defaultExpectation.params)
		}
	}

	return mmResolveConsensusRef
}

// Inspect accepts an inspector function that has same arguments as the RoutingTable.ResolveConsensusRef
func (mmResolveConsensusRef *mRoutingTableMockResolveConsensusRef) Inspect(f func(r1 insolar.Reference)) *mRoutingTableMockResolveConsensusRef {
	if mmResolveConsensusRef.mock.inspectFuncResolveConsensusRef != nil {
		mmResolveConsensusRef.mock.t.Fatalf("Inspect function is already set for RoutingTableMock.ResolveConsensusRef")
	}

	mmResolveConsensusRef.mock.inspectFuncResolveConsensusRef = f

	return mmResolveConsensusRef
}

// Return sets up results that will be returned by RoutingTable.ResolveConsensusRef
func (mmResolveConsensusRef *mRoutingTableMockResolveConsensusRef) Return(hp1 *host.Host, err error) *RoutingTableMock {
	if mmResolveConsensusRef.mock.funcResolveConsensusRef != nil {
		mmResolveConsensusRef.mock.t.Fatalf("RoutingTableMock.ResolveConsensusRef mock is already set by Set")
	}

	if mmResolveConsensusRef.defaultExpectation == nil {
		mmResolveConsensusRef.defaultExpectation = &RoutingTableMockResolveConsensusRefExpectation{mock: mmResolveConsensusRef.mock}
	}
	mmResolveConsensusRef.defaultExpectation.results = &RoutingTableMockResolveConsensusRefResults{hp1, err}
	return mmResolveConsensusRef.mock
}

//Set uses given function f to mock the RoutingTable.ResolveConsensusRef method
func (mmResolveConsensusRef *mRoutingTableMockResolveConsensusRef) Set(f func(r1 insolar.Reference) (hp1 *host.Host, err error)) *RoutingTableMock {
	if mmResolveConsensusRef.defaultExpectation != nil {
		mmResolveConsensusRef.mock.t.Fatalf("Default expectation is already set for the RoutingTable.ResolveConsensusRef method")
	}

	if len(mmResolveConsensusRef.expectations) > 0 {
		mmResolveConsensusRef.mock.t.Fatalf("Some expectations are already set for the RoutingTable.ResolveConsensusRef method")
	}

	mmResolveConsensusRef.mock.funcResolveConsensusRef = f
	return mmResolveConsensusRef.mock
}

// When sets expectation for the RoutingTable.ResolveConsensusRef which will trigger the result defined by the following
// Then helper
func (mmResolveConsensusRef *mRoutingTableMockResolveConsensusRef) When(r1 insolar.Reference) *RoutingTableMockResolveConsensusRefExpectation {
	if mmResolveConsensusRef.mock.funcResolveConsensusRef != nil {
		mmResolveConsensusRef.mock.t.Fatalf("RoutingTableMock.ResolveConsensusRef mock is already set by Set")
	}

	expectation := &RoutingTableMockResolveConsensusRefExpectation{
		mock:   mmResolveConsensusRef.mock,
		params: &RoutingTableMockResolveConsensusRefParams{r1},
	}
	mmResolveConsensusRef.expectations = append(mmResolveConsensusRef.expectations, expectation)
	return expectation
}

// Then sets up RoutingTable.ResolveConsensusRef return parameters for the expectation previously defined by the When method
func (e *RoutingTableMockResolveConsensusRefExpectation) Then(hp1 *host.Host, err error) *RoutingTableMock {
	e.results = &RoutingTableMockResolveConsensusRefResults{hp1, err}
	return e.mock
}

// ResolveConsensusRef implements network.RoutingTable
func (mmResolveConsensusRef *RoutingTableMock) ResolveConsensusRef(r1 insolar.Reference) (hp1 *host.Host, err error) {
	mm_atomic.AddUint64(&mmResolveConsensusRef.beforeResolveConsensusRefCounter, 1)
	defer mm_atomic.AddUint64(&mmResolveConsensusRef.afterResolveConsensusRefCounter, 1)

	if mmResolveConsensusRef.inspectFuncResolveConsensusRef != nil {
		mmResolveConsensusRef.inspectFuncResolveConsensusRef(r1)
	}

	params := &RoutingTableMockResolveConsensusRefParams{r1}

	// Record call args
	mmResolveConsensusRef.ResolveConsensusRefMock.mutex.Lock()
	mmResolveConsensusRef.ResolveConsensusRefMock.callArgs = append(mmResolveConsensusRef.ResolveConsensusRefMock.callArgs, params)
	mmResolveConsensusRef.ResolveConsensusRefMock.mutex.Unlock()

	for _, e := range mmResolveConsensusRef.ResolveConsensusRefMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.hp1, e.results.err
		}
	}

	if mmResolveConsensusRef.ResolveConsensusRefMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmResolveConsensusRef.ResolveConsensusRefMock.defaultExpectation.Counter, 1)
		want := mmResolveConsensusRef.ResolveConsensusRefMock.defaultExpectation.params
		got := RoutingTableMockResolveConsensusRefParams{r1}
		if want != nil && !minimock.Equal(*want, got) {
			mmResolveConsensusRef.t.Errorf("RoutingTableMock.ResolveConsensusRef got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmResolveConsensusRef.ResolveConsensusRefMock.defaultExpectation.results
		if results == nil {
			mmResolveConsensusRef.t.Fatal("No results are set for the RoutingTableMock.ResolveConsensusRef")
		}
		return (*results).hp1, (*results).err
	}
	if mmResolveConsensusRef.funcResolveConsensusRef != nil {
		return mmResolveConsensusRef.funcResolveConsensusRef(r1)
	}
	mmResolveConsensusRef.t.Fatalf("Unexpected call to RoutingTableMock.ResolveConsensusRef. %v", r1)
	return
}

// ResolveConsensusRefAfterCounter returns a count of finished RoutingTableMock.ResolveConsensusRef invocations
func (mmResolveConsensusRef *RoutingTableMock) ResolveConsensusRefAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmResolveConsensusRef.afterResolveConsensusRefCounter)
}

// ResolveConsensusRefBeforeCounter returns a count of RoutingTableMock.ResolveConsensusRef invocations
func (mmResolveConsensusRef *RoutingTableMock) ResolveConsensusRefBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmResolveConsensusRef.beforeResolveConsensusRefCounter)
}

// Calls returns a list of arguments used in each call to RoutingTableMock.ResolveConsensusRef.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmResolveConsensusRef *mRoutingTableMockResolveConsensusRef) Calls() []*RoutingTableMockResolveConsensusRefParams {
	mmResolveConsensusRef.mutex.RLock()

	argCopy := make([]*RoutingTableMockResolveConsensusRefParams, len(mmResolveConsensusRef.callArgs))
	copy(argCopy, mmResolveConsensusRef.callArgs)

	mmResolveConsensusRef.mutex.RUnlock()

	return argCopy
}

// MinimockResolveConsensusRefDone returns true if the count of the ResolveConsensusRef invocations corresponds
// the number of defined expectations
func (m *RoutingTableMock) MinimockResolveConsensusRefDone() bool {
	for _, e := range m.ResolveConsensusRefMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ResolveConsensusRefMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterResolveConsensusRefCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcResolveConsensusRef != nil && mm_atomic.LoadUint64(&m.afterResolveConsensusRefCounter) < 1 {
		return false
	}
	return true
}

// MinimockResolveConsensusRefInspect logs each unmet expectation
func (m *RoutingTableMock) MinimockResolveConsensusRefInspect() {
	for _, e := range m.ResolveConsensusRefMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RoutingTableMock.ResolveConsensusRef with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ResolveConsensusRefMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterResolveConsensusRefCounter) < 1 {
		if m.ResolveConsensusRefMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RoutingTableMock.ResolveConsensusRef")
		} else {
			m.t.Errorf("Expected call to RoutingTableMock.ResolveConsensusRef with params: %#v", *m.ResolveConsensusRefMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcResolveConsensusRef != nil && mm_atomic.LoadUint64(&m.afterResolveConsensusRefCounter) < 1 {
		m.t.Error("Expected call to RoutingTableMock.ResolveConsensusRef")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RoutingTableMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddToKnownHostsInspect()

		m.MinimockRebalanceInspect()

		m.MinimockResolveInspect()

		m.MinimockResolveConsensusInspect()

		m.MinimockResolveConsensusRefInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RoutingTableMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RoutingTableMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddToKnownHostsDone() &&
		m.MinimockRebalanceDone() &&
		m.MinimockResolveDone() &&
		m.MinimockResolveConsensusDone() &&
		m.MinimockResolveConsensusRefDone()
}
