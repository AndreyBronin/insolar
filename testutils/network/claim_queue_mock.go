package network

// Code generated by http://github.com/gojuno/minimock (3.0.0). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/insolar/network/consensusv1/packets"
)

// ClaimQueueMock implements network.ClaimQueue
type ClaimQueueMock struct {
	t minimock.Tester

	funcClear          func()
	inspectFuncClear   func()
	afterClearCounter  uint64
	beforeClearCounter uint64
	ClearMock          mClaimQueueMockClear

	funcFront          func() (r1 packets.ReferendumClaim)
	inspectFuncFront   func()
	afterFrontCounter  uint64
	beforeFrontCounter uint64
	FrontMock          mClaimQueueMockFront

	funcLength          func() (i1 int)
	inspectFuncLength   func()
	afterLengthCounter  uint64
	beforeLengthCounter uint64
	LengthMock          mClaimQueueMockLength

	funcPop          func() (r1 packets.ReferendumClaim)
	inspectFuncPop   func()
	afterPopCounter  uint64
	beforePopCounter uint64
	PopMock          mClaimQueueMockPop

	funcPush          func(claim packets.ReferendumClaim)
	inspectFuncPush   func(claim packets.ReferendumClaim)
	afterPushCounter  uint64
	beforePushCounter uint64
	PushMock          mClaimQueueMockPush
}

// NewClaimQueueMock returns a mock for network.ClaimQueue
func NewClaimQueueMock(t minimock.Tester) *ClaimQueueMock {
	m := &ClaimQueueMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ClearMock = mClaimQueueMockClear{mock: m}

	m.FrontMock = mClaimQueueMockFront{mock: m}

	m.LengthMock = mClaimQueueMockLength{mock: m}

	m.PopMock = mClaimQueueMockPop{mock: m}

	m.PushMock = mClaimQueueMockPush{mock: m}
	m.PushMock.callArgs = []*ClaimQueueMockPushParams{}

	return m
}

type mClaimQueueMockClear struct {
	mock               *ClaimQueueMock
	defaultExpectation *ClaimQueueMockClearExpectation
	expectations       []*ClaimQueueMockClearExpectation
}

// ClaimQueueMockClearExpectation specifies expectation struct of the ClaimQueue.Clear
type ClaimQueueMockClearExpectation struct {
	mock *ClaimQueueMock

	Counter uint64
}

// Expect sets up expected params for ClaimQueue.Clear
func (mmClear *mClaimQueueMockClear) Expect() *mClaimQueueMockClear {
	if mmClear.mock.funcClear != nil {
		mmClear.mock.t.Fatalf("ClaimQueueMock.Clear mock is already set by Set")
	}

	if mmClear.defaultExpectation == nil {
		mmClear.defaultExpectation = &ClaimQueueMockClearExpectation{}
	}

	return mmClear
}

// Inspect accepts an inspector function that has same arguments as the ClaimQueue.Clear
func (mmClear *mClaimQueueMockClear) Inspect(f func()) *mClaimQueueMockClear {
	if mmClear.mock.inspectFuncClear != nil {
		mmClear.mock.t.Fatalf("Inspect function is already set for ClaimQueueMock.Clear")
	}

	mmClear.mock.inspectFuncClear = f

	return mmClear
}

// Return sets up results that will be returned by ClaimQueue.Clear
func (mmClear *mClaimQueueMockClear) Return() *ClaimQueueMock {
	if mmClear.mock.funcClear != nil {
		mmClear.mock.t.Fatalf("ClaimQueueMock.Clear mock is already set by Set")
	}

	if mmClear.defaultExpectation == nil {
		mmClear.defaultExpectation = &ClaimQueueMockClearExpectation{mock: mmClear.mock}
	}

	return mmClear.mock
}

//Set uses given function f to mock the ClaimQueue.Clear method
func (mmClear *mClaimQueueMockClear) Set(f func()) *ClaimQueueMock {
	if mmClear.defaultExpectation != nil {
		mmClear.mock.t.Fatalf("Default expectation is already set for the ClaimQueue.Clear method")
	}

	if len(mmClear.expectations) > 0 {
		mmClear.mock.t.Fatalf("Some expectations are already set for the ClaimQueue.Clear method")
	}

	mmClear.mock.funcClear = f
	return mmClear.mock
}

// Clear implements network.ClaimQueue
func (mmClear *ClaimQueueMock) Clear() {
	mm_atomic.AddUint64(&mmClear.beforeClearCounter, 1)
	defer mm_atomic.AddUint64(&mmClear.afterClearCounter, 1)

	if mmClear.inspectFuncClear != nil {
		mmClear.inspectFuncClear()
	}

	if mmClear.ClearMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClear.ClearMock.defaultExpectation.Counter, 1)

		return

	}
	if mmClear.funcClear != nil {
		mmClear.funcClear()
		return
	}
	mmClear.t.Fatalf("Unexpected call to ClaimQueueMock.Clear.")

}

// ClearAfterCounter returns a count of finished ClaimQueueMock.Clear invocations
func (mmClear *ClaimQueueMock) ClearAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClear.afterClearCounter)
}

// ClearBeforeCounter returns a count of ClaimQueueMock.Clear invocations
func (mmClear *ClaimQueueMock) ClearBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClear.beforeClearCounter)
}

// MinimockClearDone returns true if the count of the Clear invocations corresponds
// the number of defined expectations
func (m *ClaimQueueMock) MinimockClearDone() bool {
	for _, e := range m.ClearMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ClearMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterClearCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClear != nil && mm_atomic.LoadUint64(&m.afterClearCounter) < 1 {
		return false
	}
	return true
}

// MinimockClearInspect logs each unmet expectation
func (m *ClaimQueueMock) MinimockClearInspect() {
	for _, e := range m.ClearMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ClaimQueueMock.Clear")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ClearMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterClearCounter) < 1 {
		m.t.Error("Expected call to ClaimQueueMock.Clear")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClear != nil && mm_atomic.LoadUint64(&m.afterClearCounter) < 1 {
		m.t.Error("Expected call to ClaimQueueMock.Clear")
	}
}

type mClaimQueueMockFront struct {
	mock               *ClaimQueueMock
	defaultExpectation *ClaimQueueMockFrontExpectation
	expectations       []*ClaimQueueMockFrontExpectation
}

// ClaimQueueMockFrontExpectation specifies expectation struct of the ClaimQueue.Front
type ClaimQueueMockFrontExpectation struct {
	mock *ClaimQueueMock

	results *ClaimQueueMockFrontResults
	Counter uint64
}

// ClaimQueueMockFrontResults contains results of the ClaimQueue.Front
type ClaimQueueMockFrontResults struct {
	r1 packets.ReferendumClaim
}

// Expect sets up expected params for ClaimQueue.Front
func (mmFront *mClaimQueueMockFront) Expect() *mClaimQueueMockFront {
	if mmFront.mock.funcFront != nil {
		mmFront.mock.t.Fatalf("ClaimQueueMock.Front mock is already set by Set")
	}

	if mmFront.defaultExpectation == nil {
		mmFront.defaultExpectation = &ClaimQueueMockFrontExpectation{}
	}

	return mmFront
}

// Inspect accepts an inspector function that has same arguments as the ClaimQueue.Front
func (mmFront *mClaimQueueMockFront) Inspect(f func()) *mClaimQueueMockFront {
	if mmFront.mock.inspectFuncFront != nil {
		mmFront.mock.t.Fatalf("Inspect function is already set for ClaimQueueMock.Front")
	}

	mmFront.mock.inspectFuncFront = f

	return mmFront
}

// Return sets up results that will be returned by ClaimQueue.Front
func (mmFront *mClaimQueueMockFront) Return(r1 packets.ReferendumClaim) *ClaimQueueMock {
	if mmFront.mock.funcFront != nil {
		mmFront.mock.t.Fatalf("ClaimQueueMock.Front mock is already set by Set")
	}

	if mmFront.defaultExpectation == nil {
		mmFront.defaultExpectation = &ClaimQueueMockFrontExpectation{mock: mmFront.mock}
	}
	mmFront.defaultExpectation.results = &ClaimQueueMockFrontResults{r1}
	return mmFront.mock
}

//Set uses given function f to mock the ClaimQueue.Front method
func (mmFront *mClaimQueueMockFront) Set(f func() (r1 packets.ReferendumClaim)) *ClaimQueueMock {
	if mmFront.defaultExpectation != nil {
		mmFront.mock.t.Fatalf("Default expectation is already set for the ClaimQueue.Front method")
	}

	if len(mmFront.expectations) > 0 {
		mmFront.mock.t.Fatalf("Some expectations are already set for the ClaimQueue.Front method")
	}

	mmFront.mock.funcFront = f
	return mmFront.mock
}

// Front implements network.ClaimQueue
func (mmFront *ClaimQueueMock) Front() (r1 packets.ReferendumClaim) {
	mm_atomic.AddUint64(&mmFront.beforeFrontCounter, 1)
	defer mm_atomic.AddUint64(&mmFront.afterFrontCounter, 1)

	if mmFront.inspectFuncFront != nil {
		mmFront.inspectFuncFront()
	}

	if mmFront.FrontMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFront.FrontMock.defaultExpectation.Counter, 1)

		results := mmFront.FrontMock.defaultExpectation.results
		if results == nil {
			mmFront.t.Fatal("No results are set for the ClaimQueueMock.Front")
		}
		return (*results).r1
	}
	if mmFront.funcFront != nil {
		return mmFront.funcFront()
	}
	mmFront.t.Fatalf("Unexpected call to ClaimQueueMock.Front.")
	return
}

// FrontAfterCounter returns a count of finished ClaimQueueMock.Front invocations
func (mmFront *ClaimQueueMock) FrontAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFront.afterFrontCounter)
}

// FrontBeforeCounter returns a count of ClaimQueueMock.Front invocations
func (mmFront *ClaimQueueMock) FrontBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFront.beforeFrontCounter)
}

// MinimockFrontDone returns true if the count of the Front invocations corresponds
// the number of defined expectations
func (m *ClaimQueueMock) MinimockFrontDone() bool {
	for _, e := range m.FrontMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FrontMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFrontCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFront != nil && mm_atomic.LoadUint64(&m.afterFrontCounter) < 1 {
		return false
	}
	return true
}

// MinimockFrontInspect logs each unmet expectation
func (m *ClaimQueueMock) MinimockFrontInspect() {
	for _, e := range m.FrontMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ClaimQueueMock.Front")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FrontMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFrontCounter) < 1 {
		m.t.Error("Expected call to ClaimQueueMock.Front")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFront != nil && mm_atomic.LoadUint64(&m.afterFrontCounter) < 1 {
		m.t.Error("Expected call to ClaimQueueMock.Front")
	}
}

type mClaimQueueMockLength struct {
	mock               *ClaimQueueMock
	defaultExpectation *ClaimQueueMockLengthExpectation
	expectations       []*ClaimQueueMockLengthExpectation
}

// ClaimQueueMockLengthExpectation specifies expectation struct of the ClaimQueue.Length
type ClaimQueueMockLengthExpectation struct {
	mock *ClaimQueueMock

	results *ClaimQueueMockLengthResults
	Counter uint64
}

// ClaimQueueMockLengthResults contains results of the ClaimQueue.Length
type ClaimQueueMockLengthResults struct {
	i1 int
}

// Expect sets up expected params for ClaimQueue.Length
func (mmLength *mClaimQueueMockLength) Expect() *mClaimQueueMockLength {
	if mmLength.mock.funcLength != nil {
		mmLength.mock.t.Fatalf("ClaimQueueMock.Length mock is already set by Set")
	}

	if mmLength.defaultExpectation == nil {
		mmLength.defaultExpectation = &ClaimQueueMockLengthExpectation{}
	}

	return mmLength
}

// Inspect accepts an inspector function that has same arguments as the ClaimQueue.Length
func (mmLength *mClaimQueueMockLength) Inspect(f func()) *mClaimQueueMockLength {
	if mmLength.mock.inspectFuncLength != nil {
		mmLength.mock.t.Fatalf("Inspect function is already set for ClaimQueueMock.Length")
	}

	mmLength.mock.inspectFuncLength = f

	return mmLength
}

// Return sets up results that will be returned by ClaimQueue.Length
func (mmLength *mClaimQueueMockLength) Return(i1 int) *ClaimQueueMock {
	if mmLength.mock.funcLength != nil {
		mmLength.mock.t.Fatalf("ClaimQueueMock.Length mock is already set by Set")
	}

	if mmLength.defaultExpectation == nil {
		mmLength.defaultExpectation = &ClaimQueueMockLengthExpectation{mock: mmLength.mock}
	}
	mmLength.defaultExpectation.results = &ClaimQueueMockLengthResults{i1}
	return mmLength.mock
}

//Set uses given function f to mock the ClaimQueue.Length method
func (mmLength *mClaimQueueMockLength) Set(f func() (i1 int)) *ClaimQueueMock {
	if mmLength.defaultExpectation != nil {
		mmLength.mock.t.Fatalf("Default expectation is already set for the ClaimQueue.Length method")
	}

	if len(mmLength.expectations) > 0 {
		mmLength.mock.t.Fatalf("Some expectations are already set for the ClaimQueue.Length method")
	}

	mmLength.mock.funcLength = f
	return mmLength.mock
}

// Length implements network.ClaimQueue
func (mmLength *ClaimQueueMock) Length() (i1 int) {
	mm_atomic.AddUint64(&mmLength.beforeLengthCounter, 1)
	defer mm_atomic.AddUint64(&mmLength.afterLengthCounter, 1)

	if mmLength.inspectFuncLength != nil {
		mmLength.inspectFuncLength()
	}

	if mmLength.LengthMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLength.LengthMock.defaultExpectation.Counter, 1)

		results := mmLength.LengthMock.defaultExpectation.results
		if results == nil {
			mmLength.t.Fatal("No results are set for the ClaimQueueMock.Length")
		}
		return (*results).i1
	}
	if mmLength.funcLength != nil {
		return mmLength.funcLength()
	}
	mmLength.t.Fatalf("Unexpected call to ClaimQueueMock.Length.")
	return
}

// LengthAfterCounter returns a count of finished ClaimQueueMock.Length invocations
func (mmLength *ClaimQueueMock) LengthAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLength.afterLengthCounter)
}

// LengthBeforeCounter returns a count of ClaimQueueMock.Length invocations
func (mmLength *ClaimQueueMock) LengthBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLength.beforeLengthCounter)
}

// MinimockLengthDone returns true if the count of the Length invocations corresponds
// the number of defined expectations
func (m *ClaimQueueMock) MinimockLengthDone() bool {
	for _, e := range m.LengthMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LengthMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLengthCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLength != nil && mm_atomic.LoadUint64(&m.afterLengthCounter) < 1 {
		return false
	}
	return true
}

// MinimockLengthInspect logs each unmet expectation
func (m *ClaimQueueMock) MinimockLengthInspect() {
	for _, e := range m.LengthMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ClaimQueueMock.Length")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LengthMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLengthCounter) < 1 {
		m.t.Error("Expected call to ClaimQueueMock.Length")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLength != nil && mm_atomic.LoadUint64(&m.afterLengthCounter) < 1 {
		m.t.Error("Expected call to ClaimQueueMock.Length")
	}
}

type mClaimQueueMockPop struct {
	mock               *ClaimQueueMock
	defaultExpectation *ClaimQueueMockPopExpectation
	expectations       []*ClaimQueueMockPopExpectation
}

// ClaimQueueMockPopExpectation specifies expectation struct of the ClaimQueue.Pop
type ClaimQueueMockPopExpectation struct {
	mock *ClaimQueueMock

	results *ClaimQueueMockPopResults
	Counter uint64
}

// ClaimQueueMockPopResults contains results of the ClaimQueue.Pop
type ClaimQueueMockPopResults struct {
	r1 packets.ReferendumClaim
}

// Expect sets up expected params for ClaimQueue.Pop
func (mmPop *mClaimQueueMockPop) Expect() *mClaimQueueMockPop {
	if mmPop.mock.funcPop != nil {
		mmPop.mock.t.Fatalf("ClaimQueueMock.Pop mock is already set by Set")
	}

	if mmPop.defaultExpectation == nil {
		mmPop.defaultExpectation = &ClaimQueueMockPopExpectation{}
	}

	return mmPop
}

// Inspect accepts an inspector function that has same arguments as the ClaimQueue.Pop
func (mmPop *mClaimQueueMockPop) Inspect(f func()) *mClaimQueueMockPop {
	if mmPop.mock.inspectFuncPop != nil {
		mmPop.mock.t.Fatalf("Inspect function is already set for ClaimQueueMock.Pop")
	}

	mmPop.mock.inspectFuncPop = f

	return mmPop
}

// Return sets up results that will be returned by ClaimQueue.Pop
func (mmPop *mClaimQueueMockPop) Return(r1 packets.ReferendumClaim) *ClaimQueueMock {
	if mmPop.mock.funcPop != nil {
		mmPop.mock.t.Fatalf("ClaimQueueMock.Pop mock is already set by Set")
	}

	if mmPop.defaultExpectation == nil {
		mmPop.defaultExpectation = &ClaimQueueMockPopExpectation{mock: mmPop.mock}
	}
	mmPop.defaultExpectation.results = &ClaimQueueMockPopResults{r1}
	return mmPop.mock
}

//Set uses given function f to mock the ClaimQueue.Pop method
func (mmPop *mClaimQueueMockPop) Set(f func() (r1 packets.ReferendumClaim)) *ClaimQueueMock {
	if mmPop.defaultExpectation != nil {
		mmPop.mock.t.Fatalf("Default expectation is already set for the ClaimQueue.Pop method")
	}

	if len(mmPop.expectations) > 0 {
		mmPop.mock.t.Fatalf("Some expectations are already set for the ClaimQueue.Pop method")
	}

	mmPop.mock.funcPop = f
	return mmPop.mock
}

// Pop implements network.ClaimQueue
func (mmPop *ClaimQueueMock) Pop() (r1 packets.ReferendumClaim) {
	mm_atomic.AddUint64(&mmPop.beforePopCounter, 1)
	defer mm_atomic.AddUint64(&mmPop.afterPopCounter, 1)

	if mmPop.inspectFuncPop != nil {
		mmPop.inspectFuncPop()
	}

	if mmPop.PopMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPop.PopMock.defaultExpectation.Counter, 1)

		results := mmPop.PopMock.defaultExpectation.results
		if results == nil {
			mmPop.t.Fatal("No results are set for the ClaimQueueMock.Pop")
		}
		return (*results).r1
	}
	if mmPop.funcPop != nil {
		return mmPop.funcPop()
	}
	mmPop.t.Fatalf("Unexpected call to ClaimQueueMock.Pop.")
	return
}

// PopAfterCounter returns a count of finished ClaimQueueMock.Pop invocations
func (mmPop *ClaimQueueMock) PopAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPop.afterPopCounter)
}

// PopBeforeCounter returns a count of ClaimQueueMock.Pop invocations
func (mmPop *ClaimQueueMock) PopBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPop.beforePopCounter)
}

// MinimockPopDone returns true if the count of the Pop invocations corresponds
// the number of defined expectations
func (m *ClaimQueueMock) MinimockPopDone() bool {
	for _, e := range m.PopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPopCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPop != nil && mm_atomic.LoadUint64(&m.afterPopCounter) < 1 {
		return false
	}
	return true
}

// MinimockPopInspect logs each unmet expectation
func (m *ClaimQueueMock) MinimockPopInspect() {
	for _, e := range m.PopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ClaimQueueMock.Pop")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPopCounter) < 1 {
		m.t.Error("Expected call to ClaimQueueMock.Pop")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPop != nil && mm_atomic.LoadUint64(&m.afterPopCounter) < 1 {
		m.t.Error("Expected call to ClaimQueueMock.Pop")
	}
}

type mClaimQueueMockPush struct {
	mock               *ClaimQueueMock
	defaultExpectation *ClaimQueueMockPushExpectation
	expectations       []*ClaimQueueMockPushExpectation

	callArgs []*ClaimQueueMockPushParams
	mutex    sync.RWMutex
}

// ClaimQueueMockPushExpectation specifies expectation struct of the ClaimQueue.Push
type ClaimQueueMockPushExpectation struct {
	mock   *ClaimQueueMock
	params *ClaimQueueMockPushParams

	Counter uint64
}

// ClaimQueueMockPushParams contains parameters of the ClaimQueue.Push
type ClaimQueueMockPushParams struct {
	claim packets.ReferendumClaim
}

// Expect sets up expected params for ClaimQueue.Push
func (mmPush *mClaimQueueMockPush) Expect(claim packets.ReferendumClaim) *mClaimQueueMockPush {
	if mmPush.mock.funcPush != nil {
		mmPush.mock.t.Fatalf("ClaimQueueMock.Push mock is already set by Set")
	}

	if mmPush.defaultExpectation == nil {
		mmPush.defaultExpectation = &ClaimQueueMockPushExpectation{}
	}

	mmPush.defaultExpectation.params = &ClaimQueueMockPushParams{claim}
	for _, e := range mmPush.expectations {
		if minimock.Equal(e.params, mmPush.defaultExpectation.params) {
			mmPush.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPush.defaultExpectation.params)
		}
	}

	return mmPush
}

// Inspect accepts an inspector function that has same arguments as the ClaimQueue.Push
func (mmPush *mClaimQueueMockPush) Inspect(f func(claim packets.ReferendumClaim)) *mClaimQueueMockPush {
	if mmPush.mock.inspectFuncPush != nil {
		mmPush.mock.t.Fatalf("Inspect function is already set for ClaimQueueMock.Push")
	}

	mmPush.mock.inspectFuncPush = f

	return mmPush
}

// Return sets up results that will be returned by ClaimQueue.Push
func (mmPush *mClaimQueueMockPush) Return() *ClaimQueueMock {
	if mmPush.mock.funcPush != nil {
		mmPush.mock.t.Fatalf("ClaimQueueMock.Push mock is already set by Set")
	}

	if mmPush.defaultExpectation == nil {
		mmPush.defaultExpectation = &ClaimQueueMockPushExpectation{mock: mmPush.mock}
	}

	return mmPush.mock
}

//Set uses given function f to mock the ClaimQueue.Push method
func (mmPush *mClaimQueueMockPush) Set(f func(claim packets.ReferendumClaim)) *ClaimQueueMock {
	if mmPush.defaultExpectation != nil {
		mmPush.mock.t.Fatalf("Default expectation is already set for the ClaimQueue.Push method")
	}

	if len(mmPush.expectations) > 0 {
		mmPush.mock.t.Fatalf("Some expectations are already set for the ClaimQueue.Push method")
	}

	mmPush.mock.funcPush = f
	return mmPush.mock
}

// Push implements network.ClaimQueue
func (mmPush *ClaimQueueMock) Push(claim packets.ReferendumClaim) {
	mm_atomic.AddUint64(&mmPush.beforePushCounter, 1)
	defer mm_atomic.AddUint64(&mmPush.afterPushCounter, 1)

	if mmPush.inspectFuncPush != nil {
		mmPush.inspectFuncPush(claim)
	}

	params := &ClaimQueueMockPushParams{claim}

	// Record call args
	mmPush.PushMock.mutex.Lock()
	mmPush.PushMock.callArgs = append(mmPush.PushMock.callArgs, params)
	mmPush.PushMock.mutex.Unlock()

	for _, e := range mmPush.PushMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPush.PushMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPush.PushMock.defaultExpectation.Counter, 1)
		want := mmPush.PushMock.defaultExpectation.params
		got := ClaimQueueMockPushParams{claim}
		if want != nil && !minimock.Equal(*want, got) {
			mmPush.t.Errorf("ClaimQueueMock.Push got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmPush.funcPush != nil {
		mmPush.funcPush(claim)
		return
	}
	mmPush.t.Fatalf("Unexpected call to ClaimQueueMock.Push. %v", claim)

}

// PushAfterCounter returns a count of finished ClaimQueueMock.Push invocations
func (mmPush *ClaimQueueMock) PushAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPush.afterPushCounter)
}

// PushBeforeCounter returns a count of ClaimQueueMock.Push invocations
func (mmPush *ClaimQueueMock) PushBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPush.beforePushCounter)
}

// Calls returns a list of arguments used in each call to ClaimQueueMock.Push.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPush *mClaimQueueMockPush) Calls() []*ClaimQueueMockPushParams {
	mmPush.mutex.RLock()

	argCopy := make([]*ClaimQueueMockPushParams, len(mmPush.callArgs))
	copy(argCopy, mmPush.callArgs)

	mmPush.mutex.RUnlock()

	return argCopy
}

// MinimockPushDone returns true if the count of the Push invocations corresponds
// the number of defined expectations
func (m *ClaimQueueMock) MinimockPushDone() bool {
	for _, e := range m.PushMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PushMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPushCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPush != nil && mm_atomic.LoadUint64(&m.afterPushCounter) < 1 {
		return false
	}
	return true
}

// MinimockPushInspect logs each unmet expectation
func (m *ClaimQueueMock) MinimockPushInspect() {
	for _, e := range m.PushMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClaimQueueMock.Push with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PushMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPushCounter) < 1 {
		if m.PushMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClaimQueueMock.Push")
		} else {
			m.t.Errorf("Expected call to ClaimQueueMock.Push with params: %#v", *m.PushMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPush != nil && mm_atomic.LoadUint64(&m.afterPushCounter) < 1 {
		m.t.Error("Expected call to ClaimQueueMock.Push")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ClaimQueueMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockClearInspect()

		m.MinimockFrontInspect()

		m.MinimockLengthInspect()

		m.MinimockPopInspect()

		m.MinimockPushInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ClaimQueueMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ClaimQueueMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockClearDone() &&
		m.MinimockFrontDone() &&
		m.MinimockLengthDone() &&
		m.MinimockPopDone() &&
		m.MinimockPushDone()
}
