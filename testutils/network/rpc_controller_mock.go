package network

// Code generated by http://github.com/gojuno/minimock (3.0.0). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/insolar/insolar"
)

// RPCControllerMock implements controller.RPCController
type RPCControllerMock struct {
	t minimock.Tester

	funcInit          func(ctx context.Context) (err error)
	inspectFuncInit   func(ctx context.Context)
	afterInitCounter  uint64
	beforeInitCounter uint64
	InitMock          mRPCControllerMockInit

	funcRemoteProcedureRegister          func(name string, method insolar.RemoteProcedure)
	inspectFuncRemoteProcedureRegister   func(name string, method insolar.RemoteProcedure)
	afterRemoteProcedureRegisterCounter  uint64
	beforeRemoteProcedureRegisterCounter uint64
	RemoteProcedureRegisterMock          mRPCControllerMockRemoteProcedureRegister

	funcSendBytes          func(ctx context.Context, nodeID insolar.Reference, name string, msgBytes []byte) (ba1 []byte, err error)
	inspectFuncSendBytes   func(ctx context.Context, nodeID insolar.Reference, name string, msgBytes []byte)
	afterSendBytesCounter  uint64
	beforeSendBytesCounter uint64
	SendBytesMock          mRPCControllerMockSendBytes

	funcSendCascadeMessage          func(data insolar.Cascade, method string, msg insolar.Parcel) (err error)
	inspectFuncSendCascadeMessage   func(data insolar.Cascade, method string, msg insolar.Parcel)
	afterSendCascadeMessageCounter  uint64
	beforeSendCascadeMessageCounter uint64
	SendCascadeMessageMock          mRPCControllerMockSendCascadeMessage

	funcSendMessage          func(nodeID insolar.Reference, name string, msg insolar.Parcel) (ba1 []byte, err error)
	inspectFuncSendMessage   func(nodeID insolar.Reference, name string, msg insolar.Parcel)
	afterSendMessageCounter  uint64
	beforeSendMessageCounter uint64
	SendMessageMock          mRPCControllerMockSendMessage
}

// NewRPCControllerMock returns a mock for controller.RPCController
func NewRPCControllerMock(t minimock.Tester) *RPCControllerMock {
	m := &RPCControllerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.InitMock = mRPCControllerMockInit{mock: m}
	m.InitMock.callArgs = []*RPCControllerMockInitParams{}

	m.RemoteProcedureRegisterMock = mRPCControllerMockRemoteProcedureRegister{mock: m}
	m.RemoteProcedureRegisterMock.callArgs = []*RPCControllerMockRemoteProcedureRegisterParams{}

	m.SendBytesMock = mRPCControllerMockSendBytes{mock: m}
	m.SendBytesMock.callArgs = []*RPCControllerMockSendBytesParams{}

	m.SendCascadeMessageMock = mRPCControllerMockSendCascadeMessage{mock: m}
	m.SendCascadeMessageMock.callArgs = []*RPCControllerMockSendCascadeMessageParams{}

	m.SendMessageMock = mRPCControllerMockSendMessage{mock: m}
	m.SendMessageMock.callArgs = []*RPCControllerMockSendMessageParams{}

	return m
}

type mRPCControllerMockInit struct {
	mock               *RPCControllerMock
	defaultExpectation *RPCControllerMockInitExpectation
	expectations       []*RPCControllerMockInitExpectation

	callArgs []*RPCControllerMockInitParams
	mutex    sync.RWMutex
}

// RPCControllerMockInitExpectation specifies expectation struct of the RPCController.Init
type RPCControllerMockInitExpectation struct {
	mock    *RPCControllerMock
	params  *RPCControllerMockInitParams
	results *RPCControllerMockInitResults
	Counter uint64
}

// RPCControllerMockInitParams contains parameters of the RPCController.Init
type RPCControllerMockInitParams struct {
	ctx context.Context
}

// RPCControllerMockInitResults contains results of the RPCController.Init
type RPCControllerMockInitResults struct {
	err error
}

// Expect sets up expected params for RPCController.Init
func (mmInit *mRPCControllerMockInit) Expect(ctx context.Context) *mRPCControllerMockInit {
	if mmInit.mock.funcInit != nil {
		mmInit.mock.t.Fatalf("RPCControllerMock.Init mock is already set by Set")
	}

	if mmInit.defaultExpectation == nil {
		mmInit.defaultExpectation = &RPCControllerMockInitExpectation{}
	}

	mmInit.defaultExpectation.params = &RPCControllerMockInitParams{ctx}
	for _, e := range mmInit.expectations {
		if minimock.Equal(e.params, mmInit.defaultExpectation.params) {
			mmInit.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInit.defaultExpectation.params)
		}
	}

	return mmInit
}

// Inspect accepts an inspector function that has same arguments as the RPCController.Init
func (mmInit *mRPCControllerMockInit) Inspect(f func(ctx context.Context)) *mRPCControllerMockInit {
	if mmInit.mock.inspectFuncInit != nil {
		mmInit.mock.t.Fatalf("Inspect function is already set for RPCControllerMock.Init")
	}

	mmInit.mock.inspectFuncInit = f

	return mmInit
}

// Return sets up results that will be returned by RPCController.Init
func (mmInit *mRPCControllerMockInit) Return(err error) *RPCControllerMock {
	if mmInit.mock.funcInit != nil {
		mmInit.mock.t.Fatalf("RPCControllerMock.Init mock is already set by Set")
	}

	if mmInit.defaultExpectation == nil {
		mmInit.defaultExpectation = &RPCControllerMockInitExpectation{mock: mmInit.mock}
	}
	mmInit.defaultExpectation.results = &RPCControllerMockInitResults{err}
	return mmInit.mock
}

//Set uses given function f to mock the RPCController.Init method
func (mmInit *mRPCControllerMockInit) Set(f func(ctx context.Context) (err error)) *RPCControllerMock {
	if mmInit.defaultExpectation != nil {
		mmInit.mock.t.Fatalf("Default expectation is already set for the RPCController.Init method")
	}

	if len(mmInit.expectations) > 0 {
		mmInit.mock.t.Fatalf("Some expectations are already set for the RPCController.Init method")
	}

	mmInit.mock.funcInit = f
	return mmInit.mock
}

// When sets expectation for the RPCController.Init which will trigger the result defined by the following
// Then helper
func (mmInit *mRPCControllerMockInit) When(ctx context.Context) *RPCControllerMockInitExpectation {
	if mmInit.mock.funcInit != nil {
		mmInit.mock.t.Fatalf("RPCControllerMock.Init mock is already set by Set")
	}

	expectation := &RPCControllerMockInitExpectation{
		mock:   mmInit.mock,
		params: &RPCControllerMockInitParams{ctx},
	}
	mmInit.expectations = append(mmInit.expectations, expectation)
	return expectation
}

// Then sets up RPCController.Init return parameters for the expectation previously defined by the When method
func (e *RPCControllerMockInitExpectation) Then(err error) *RPCControllerMock {
	e.results = &RPCControllerMockInitResults{err}
	return e.mock
}

// Init implements controller.RPCController
func (mmInit *RPCControllerMock) Init(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmInit.beforeInitCounter, 1)
	defer mm_atomic.AddUint64(&mmInit.afterInitCounter, 1)

	if mmInit.inspectFuncInit != nil {
		mmInit.inspectFuncInit(ctx)
	}

	params := &RPCControllerMockInitParams{ctx}

	// Record call args
	mmInit.InitMock.mutex.Lock()
	mmInit.InitMock.callArgs = append(mmInit.InitMock.callArgs, params)
	mmInit.InitMock.mutex.Unlock()

	for _, e := range mmInit.InitMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmInit.InitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInit.InitMock.defaultExpectation.Counter, 1)
		want := mmInit.InitMock.defaultExpectation.params
		got := RPCControllerMockInitParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmInit.t.Errorf("RPCControllerMock.Init got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmInit.InitMock.defaultExpectation.results
		if results == nil {
			mmInit.t.Fatal("No results are set for the RPCControllerMock.Init")
		}
		return (*results).err
	}
	if mmInit.funcInit != nil {
		return mmInit.funcInit(ctx)
	}
	mmInit.t.Fatalf("Unexpected call to RPCControllerMock.Init. %v", ctx)
	return
}

// InitAfterCounter returns a count of finished RPCControllerMock.Init invocations
func (mmInit *RPCControllerMock) InitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInit.afterInitCounter)
}

// InitBeforeCounter returns a count of RPCControllerMock.Init invocations
func (mmInit *RPCControllerMock) InitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInit.beforeInitCounter)
}

// Calls returns a list of arguments used in each call to RPCControllerMock.Init.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInit *mRPCControllerMockInit) Calls() []*RPCControllerMockInitParams {
	mmInit.mutex.RLock()

	argCopy := make([]*RPCControllerMockInitParams, len(mmInit.callArgs))
	copy(argCopy, mmInit.callArgs)

	mmInit.mutex.RUnlock()

	return argCopy
}

// MinimockInitDone returns true if the count of the Init invocations corresponds
// the number of defined expectations
func (m *RPCControllerMock) MinimockInitDone() bool {
	for _, e := range m.InitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInitCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInit != nil && mm_atomic.LoadUint64(&m.afterInitCounter) < 1 {
		return false
	}
	return true
}

// MinimockInitInspect logs each unmet expectation
func (m *RPCControllerMock) MinimockInitInspect() {
	for _, e := range m.InitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RPCControllerMock.Init with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInitCounter) < 1 {
		if m.InitMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RPCControllerMock.Init")
		} else {
			m.t.Errorf("Expected call to RPCControllerMock.Init with params: %#v", *m.InitMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInit != nil && mm_atomic.LoadUint64(&m.afterInitCounter) < 1 {
		m.t.Error("Expected call to RPCControllerMock.Init")
	}
}

type mRPCControllerMockRemoteProcedureRegister struct {
	mock               *RPCControllerMock
	defaultExpectation *RPCControllerMockRemoteProcedureRegisterExpectation
	expectations       []*RPCControllerMockRemoteProcedureRegisterExpectation

	callArgs []*RPCControllerMockRemoteProcedureRegisterParams
	mutex    sync.RWMutex
}

// RPCControllerMockRemoteProcedureRegisterExpectation specifies expectation struct of the RPCController.RemoteProcedureRegister
type RPCControllerMockRemoteProcedureRegisterExpectation struct {
	mock   *RPCControllerMock
	params *RPCControllerMockRemoteProcedureRegisterParams

	Counter uint64
}

// RPCControllerMockRemoteProcedureRegisterParams contains parameters of the RPCController.RemoteProcedureRegister
type RPCControllerMockRemoteProcedureRegisterParams struct {
	name   string
	method insolar.RemoteProcedure
}

// Expect sets up expected params for RPCController.RemoteProcedureRegister
func (mmRemoteProcedureRegister *mRPCControllerMockRemoteProcedureRegister) Expect(name string, method insolar.RemoteProcedure) *mRPCControllerMockRemoteProcedureRegister {
	if mmRemoteProcedureRegister.mock.funcRemoteProcedureRegister != nil {
		mmRemoteProcedureRegister.mock.t.Fatalf("RPCControllerMock.RemoteProcedureRegister mock is already set by Set")
	}

	if mmRemoteProcedureRegister.defaultExpectation == nil {
		mmRemoteProcedureRegister.defaultExpectation = &RPCControllerMockRemoteProcedureRegisterExpectation{}
	}

	mmRemoteProcedureRegister.defaultExpectation.params = &RPCControllerMockRemoteProcedureRegisterParams{name, method}
	for _, e := range mmRemoteProcedureRegister.expectations {
		if minimock.Equal(e.params, mmRemoteProcedureRegister.defaultExpectation.params) {
			mmRemoteProcedureRegister.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoteProcedureRegister.defaultExpectation.params)
		}
	}

	return mmRemoteProcedureRegister
}

// Inspect accepts an inspector function that has same arguments as the RPCController.RemoteProcedureRegister
func (mmRemoteProcedureRegister *mRPCControllerMockRemoteProcedureRegister) Inspect(f func(name string, method insolar.RemoteProcedure)) *mRPCControllerMockRemoteProcedureRegister {
	if mmRemoteProcedureRegister.mock.inspectFuncRemoteProcedureRegister != nil {
		mmRemoteProcedureRegister.mock.t.Fatalf("Inspect function is already set for RPCControllerMock.RemoteProcedureRegister")
	}

	mmRemoteProcedureRegister.mock.inspectFuncRemoteProcedureRegister = f

	return mmRemoteProcedureRegister
}

// Return sets up results that will be returned by RPCController.RemoteProcedureRegister
func (mmRemoteProcedureRegister *mRPCControllerMockRemoteProcedureRegister) Return() *RPCControllerMock {
	if mmRemoteProcedureRegister.mock.funcRemoteProcedureRegister != nil {
		mmRemoteProcedureRegister.mock.t.Fatalf("RPCControllerMock.RemoteProcedureRegister mock is already set by Set")
	}

	if mmRemoteProcedureRegister.defaultExpectation == nil {
		mmRemoteProcedureRegister.defaultExpectation = &RPCControllerMockRemoteProcedureRegisterExpectation{mock: mmRemoteProcedureRegister.mock}
	}

	return mmRemoteProcedureRegister.mock
}

//Set uses given function f to mock the RPCController.RemoteProcedureRegister method
func (mmRemoteProcedureRegister *mRPCControllerMockRemoteProcedureRegister) Set(f func(name string, method insolar.RemoteProcedure)) *RPCControllerMock {
	if mmRemoteProcedureRegister.defaultExpectation != nil {
		mmRemoteProcedureRegister.mock.t.Fatalf("Default expectation is already set for the RPCController.RemoteProcedureRegister method")
	}

	if len(mmRemoteProcedureRegister.expectations) > 0 {
		mmRemoteProcedureRegister.mock.t.Fatalf("Some expectations are already set for the RPCController.RemoteProcedureRegister method")
	}

	mmRemoteProcedureRegister.mock.funcRemoteProcedureRegister = f
	return mmRemoteProcedureRegister.mock
}

// RemoteProcedureRegister implements controller.RPCController
func (mmRemoteProcedureRegister *RPCControllerMock) RemoteProcedureRegister(name string, method insolar.RemoteProcedure) {
	mm_atomic.AddUint64(&mmRemoteProcedureRegister.beforeRemoteProcedureRegisterCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoteProcedureRegister.afterRemoteProcedureRegisterCounter, 1)

	if mmRemoteProcedureRegister.inspectFuncRemoteProcedureRegister != nil {
		mmRemoteProcedureRegister.inspectFuncRemoteProcedureRegister(name, method)
	}

	params := &RPCControllerMockRemoteProcedureRegisterParams{name, method}

	// Record call args
	mmRemoteProcedureRegister.RemoteProcedureRegisterMock.mutex.Lock()
	mmRemoteProcedureRegister.RemoteProcedureRegisterMock.callArgs = append(mmRemoteProcedureRegister.RemoteProcedureRegisterMock.callArgs, params)
	mmRemoteProcedureRegister.RemoteProcedureRegisterMock.mutex.Unlock()

	for _, e := range mmRemoteProcedureRegister.RemoteProcedureRegisterMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmRemoteProcedureRegister.RemoteProcedureRegisterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoteProcedureRegister.RemoteProcedureRegisterMock.defaultExpectation.Counter, 1)
		want := mmRemoteProcedureRegister.RemoteProcedureRegisterMock.defaultExpectation.params
		got := RPCControllerMockRemoteProcedureRegisterParams{name, method}
		if want != nil && !minimock.Equal(*want, got) {
			mmRemoteProcedureRegister.t.Errorf("RPCControllerMock.RemoteProcedureRegister got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmRemoteProcedureRegister.funcRemoteProcedureRegister != nil {
		mmRemoteProcedureRegister.funcRemoteProcedureRegister(name, method)
		return
	}
	mmRemoteProcedureRegister.t.Fatalf("Unexpected call to RPCControllerMock.RemoteProcedureRegister. %v %v", name, method)

}

// RemoteProcedureRegisterAfterCounter returns a count of finished RPCControllerMock.RemoteProcedureRegister invocations
func (mmRemoteProcedureRegister *RPCControllerMock) RemoteProcedureRegisterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoteProcedureRegister.afterRemoteProcedureRegisterCounter)
}

// RemoteProcedureRegisterBeforeCounter returns a count of RPCControllerMock.RemoteProcedureRegister invocations
func (mmRemoteProcedureRegister *RPCControllerMock) RemoteProcedureRegisterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoteProcedureRegister.beforeRemoteProcedureRegisterCounter)
}

// Calls returns a list of arguments used in each call to RPCControllerMock.RemoteProcedureRegister.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoteProcedureRegister *mRPCControllerMockRemoteProcedureRegister) Calls() []*RPCControllerMockRemoteProcedureRegisterParams {
	mmRemoteProcedureRegister.mutex.RLock()

	argCopy := make([]*RPCControllerMockRemoteProcedureRegisterParams, len(mmRemoteProcedureRegister.callArgs))
	copy(argCopy, mmRemoteProcedureRegister.callArgs)

	mmRemoteProcedureRegister.mutex.RUnlock()

	return argCopy
}

// MinimockRemoteProcedureRegisterDone returns true if the count of the RemoteProcedureRegister invocations corresponds
// the number of defined expectations
func (m *RPCControllerMock) MinimockRemoteProcedureRegisterDone() bool {
	for _, e := range m.RemoteProcedureRegisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoteProcedureRegisterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoteProcedureRegisterCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoteProcedureRegister != nil && mm_atomic.LoadUint64(&m.afterRemoteProcedureRegisterCounter) < 1 {
		return false
	}
	return true
}

// MinimockRemoteProcedureRegisterInspect logs each unmet expectation
func (m *RPCControllerMock) MinimockRemoteProcedureRegisterInspect() {
	for _, e := range m.RemoteProcedureRegisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RPCControllerMock.RemoteProcedureRegister with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoteProcedureRegisterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoteProcedureRegisterCounter) < 1 {
		if m.RemoteProcedureRegisterMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RPCControllerMock.RemoteProcedureRegister")
		} else {
			m.t.Errorf("Expected call to RPCControllerMock.RemoteProcedureRegister with params: %#v", *m.RemoteProcedureRegisterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoteProcedureRegister != nil && mm_atomic.LoadUint64(&m.afterRemoteProcedureRegisterCounter) < 1 {
		m.t.Error("Expected call to RPCControllerMock.RemoteProcedureRegister")
	}
}

type mRPCControllerMockSendBytes struct {
	mock               *RPCControllerMock
	defaultExpectation *RPCControllerMockSendBytesExpectation
	expectations       []*RPCControllerMockSendBytesExpectation

	callArgs []*RPCControllerMockSendBytesParams
	mutex    sync.RWMutex
}

// RPCControllerMockSendBytesExpectation specifies expectation struct of the RPCController.SendBytes
type RPCControllerMockSendBytesExpectation struct {
	mock    *RPCControllerMock
	params  *RPCControllerMockSendBytesParams
	results *RPCControllerMockSendBytesResults
	Counter uint64
}

// RPCControllerMockSendBytesParams contains parameters of the RPCController.SendBytes
type RPCControllerMockSendBytesParams struct {
	ctx      context.Context
	nodeID   insolar.Reference
	name     string
	msgBytes []byte
}

// RPCControllerMockSendBytesResults contains results of the RPCController.SendBytes
type RPCControllerMockSendBytesResults struct {
	ba1 []byte
	err error
}

// Expect sets up expected params for RPCController.SendBytes
func (mmSendBytes *mRPCControllerMockSendBytes) Expect(ctx context.Context, nodeID insolar.Reference, name string, msgBytes []byte) *mRPCControllerMockSendBytes {
	if mmSendBytes.mock.funcSendBytes != nil {
		mmSendBytes.mock.t.Fatalf("RPCControllerMock.SendBytes mock is already set by Set")
	}

	if mmSendBytes.defaultExpectation == nil {
		mmSendBytes.defaultExpectation = &RPCControllerMockSendBytesExpectation{}
	}

	mmSendBytes.defaultExpectation.params = &RPCControllerMockSendBytesParams{ctx, nodeID, name, msgBytes}
	for _, e := range mmSendBytes.expectations {
		if minimock.Equal(e.params, mmSendBytes.defaultExpectation.params) {
			mmSendBytes.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendBytes.defaultExpectation.params)
		}
	}

	return mmSendBytes
}

// Inspect accepts an inspector function that has same arguments as the RPCController.SendBytes
func (mmSendBytes *mRPCControllerMockSendBytes) Inspect(f func(ctx context.Context, nodeID insolar.Reference, name string, msgBytes []byte)) *mRPCControllerMockSendBytes {
	if mmSendBytes.mock.inspectFuncSendBytes != nil {
		mmSendBytes.mock.t.Fatalf("Inspect function is already set for RPCControllerMock.SendBytes")
	}

	mmSendBytes.mock.inspectFuncSendBytes = f

	return mmSendBytes
}

// Return sets up results that will be returned by RPCController.SendBytes
func (mmSendBytes *mRPCControllerMockSendBytes) Return(ba1 []byte, err error) *RPCControllerMock {
	if mmSendBytes.mock.funcSendBytes != nil {
		mmSendBytes.mock.t.Fatalf("RPCControllerMock.SendBytes mock is already set by Set")
	}

	if mmSendBytes.defaultExpectation == nil {
		mmSendBytes.defaultExpectation = &RPCControllerMockSendBytesExpectation{mock: mmSendBytes.mock}
	}
	mmSendBytes.defaultExpectation.results = &RPCControllerMockSendBytesResults{ba1, err}
	return mmSendBytes.mock
}

//Set uses given function f to mock the RPCController.SendBytes method
func (mmSendBytes *mRPCControllerMockSendBytes) Set(f func(ctx context.Context, nodeID insolar.Reference, name string, msgBytes []byte) (ba1 []byte, err error)) *RPCControllerMock {
	if mmSendBytes.defaultExpectation != nil {
		mmSendBytes.mock.t.Fatalf("Default expectation is already set for the RPCController.SendBytes method")
	}

	if len(mmSendBytes.expectations) > 0 {
		mmSendBytes.mock.t.Fatalf("Some expectations are already set for the RPCController.SendBytes method")
	}

	mmSendBytes.mock.funcSendBytes = f
	return mmSendBytes.mock
}

// When sets expectation for the RPCController.SendBytes which will trigger the result defined by the following
// Then helper
func (mmSendBytes *mRPCControllerMockSendBytes) When(ctx context.Context, nodeID insolar.Reference, name string, msgBytes []byte) *RPCControllerMockSendBytesExpectation {
	if mmSendBytes.mock.funcSendBytes != nil {
		mmSendBytes.mock.t.Fatalf("RPCControllerMock.SendBytes mock is already set by Set")
	}

	expectation := &RPCControllerMockSendBytesExpectation{
		mock:   mmSendBytes.mock,
		params: &RPCControllerMockSendBytesParams{ctx, nodeID, name, msgBytes},
	}
	mmSendBytes.expectations = append(mmSendBytes.expectations, expectation)
	return expectation
}

// Then sets up RPCController.SendBytes return parameters for the expectation previously defined by the When method
func (e *RPCControllerMockSendBytesExpectation) Then(ba1 []byte, err error) *RPCControllerMock {
	e.results = &RPCControllerMockSendBytesResults{ba1, err}
	return e.mock
}

// SendBytes implements controller.RPCController
func (mmSendBytes *RPCControllerMock) SendBytes(ctx context.Context, nodeID insolar.Reference, name string, msgBytes []byte) (ba1 []byte, err error) {
	mm_atomic.AddUint64(&mmSendBytes.beforeSendBytesCounter, 1)
	defer mm_atomic.AddUint64(&mmSendBytes.afterSendBytesCounter, 1)

	if mmSendBytes.inspectFuncSendBytes != nil {
		mmSendBytes.inspectFuncSendBytes(ctx, nodeID, name, msgBytes)
	}

	params := &RPCControllerMockSendBytesParams{ctx, nodeID, name, msgBytes}

	// Record call args
	mmSendBytes.SendBytesMock.mutex.Lock()
	mmSendBytes.SendBytesMock.callArgs = append(mmSendBytes.SendBytesMock.callArgs, params)
	mmSendBytes.SendBytesMock.mutex.Unlock()

	for _, e := range mmSendBytes.SendBytesMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ba1, e.results.err
		}
	}

	if mmSendBytes.SendBytesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendBytes.SendBytesMock.defaultExpectation.Counter, 1)
		want := mmSendBytes.SendBytesMock.defaultExpectation.params
		got := RPCControllerMockSendBytesParams{ctx, nodeID, name, msgBytes}
		if want != nil && !minimock.Equal(*want, got) {
			mmSendBytes.t.Errorf("RPCControllerMock.SendBytes got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmSendBytes.SendBytesMock.defaultExpectation.results
		if results == nil {
			mmSendBytes.t.Fatal("No results are set for the RPCControllerMock.SendBytes")
		}
		return (*results).ba1, (*results).err
	}
	if mmSendBytes.funcSendBytes != nil {
		return mmSendBytes.funcSendBytes(ctx, nodeID, name, msgBytes)
	}
	mmSendBytes.t.Fatalf("Unexpected call to RPCControllerMock.SendBytes. %v %v %v %v", ctx, nodeID, name, msgBytes)
	return
}

// SendBytesAfterCounter returns a count of finished RPCControllerMock.SendBytes invocations
func (mmSendBytes *RPCControllerMock) SendBytesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendBytes.afterSendBytesCounter)
}

// SendBytesBeforeCounter returns a count of RPCControllerMock.SendBytes invocations
func (mmSendBytes *RPCControllerMock) SendBytesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendBytes.beforeSendBytesCounter)
}

// Calls returns a list of arguments used in each call to RPCControllerMock.SendBytes.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendBytes *mRPCControllerMockSendBytes) Calls() []*RPCControllerMockSendBytesParams {
	mmSendBytes.mutex.RLock()

	argCopy := make([]*RPCControllerMockSendBytesParams, len(mmSendBytes.callArgs))
	copy(argCopy, mmSendBytes.callArgs)

	mmSendBytes.mutex.RUnlock()

	return argCopy
}

// MinimockSendBytesDone returns true if the count of the SendBytes invocations corresponds
// the number of defined expectations
func (m *RPCControllerMock) MinimockSendBytesDone() bool {
	for _, e := range m.SendBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendBytesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendBytesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendBytes != nil && mm_atomic.LoadUint64(&m.afterSendBytesCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendBytesInspect logs each unmet expectation
func (m *RPCControllerMock) MinimockSendBytesInspect() {
	for _, e := range m.SendBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RPCControllerMock.SendBytes with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendBytesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendBytesCounter) < 1 {
		if m.SendBytesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RPCControllerMock.SendBytes")
		} else {
			m.t.Errorf("Expected call to RPCControllerMock.SendBytes with params: %#v", *m.SendBytesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendBytes != nil && mm_atomic.LoadUint64(&m.afterSendBytesCounter) < 1 {
		m.t.Error("Expected call to RPCControllerMock.SendBytes")
	}
}

type mRPCControllerMockSendCascadeMessage struct {
	mock               *RPCControllerMock
	defaultExpectation *RPCControllerMockSendCascadeMessageExpectation
	expectations       []*RPCControllerMockSendCascadeMessageExpectation

	callArgs []*RPCControllerMockSendCascadeMessageParams
	mutex    sync.RWMutex
}

// RPCControllerMockSendCascadeMessageExpectation specifies expectation struct of the RPCController.SendCascadeMessage
type RPCControllerMockSendCascadeMessageExpectation struct {
	mock    *RPCControllerMock
	params  *RPCControllerMockSendCascadeMessageParams
	results *RPCControllerMockSendCascadeMessageResults
	Counter uint64
}

// RPCControllerMockSendCascadeMessageParams contains parameters of the RPCController.SendCascadeMessage
type RPCControllerMockSendCascadeMessageParams struct {
	data   insolar.Cascade
	method string
	msg    insolar.Parcel
}

// RPCControllerMockSendCascadeMessageResults contains results of the RPCController.SendCascadeMessage
type RPCControllerMockSendCascadeMessageResults struct {
	err error
}

// Expect sets up expected params for RPCController.SendCascadeMessage
func (mmSendCascadeMessage *mRPCControllerMockSendCascadeMessage) Expect(data insolar.Cascade, method string, msg insolar.Parcel) *mRPCControllerMockSendCascadeMessage {
	if mmSendCascadeMessage.mock.funcSendCascadeMessage != nil {
		mmSendCascadeMessage.mock.t.Fatalf("RPCControllerMock.SendCascadeMessage mock is already set by Set")
	}

	if mmSendCascadeMessage.defaultExpectation == nil {
		mmSendCascadeMessage.defaultExpectation = &RPCControllerMockSendCascadeMessageExpectation{}
	}

	mmSendCascadeMessage.defaultExpectation.params = &RPCControllerMockSendCascadeMessageParams{data, method, msg}
	for _, e := range mmSendCascadeMessage.expectations {
		if minimock.Equal(e.params, mmSendCascadeMessage.defaultExpectation.params) {
			mmSendCascadeMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendCascadeMessage.defaultExpectation.params)
		}
	}

	return mmSendCascadeMessage
}

// Inspect accepts an inspector function that has same arguments as the RPCController.SendCascadeMessage
func (mmSendCascadeMessage *mRPCControllerMockSendCascadeMessage) Inspect(f func(data insolar.Cascade, method string, msg insolar.Parcel)) *mRPCControllerMockSendCascadeMessage {
	if mmSendCascadeMessage.mock.inspectFuncSendCascadeMessage != nil {
		mmSendCascadeMessage.mock.t.Fatalf("Inspect function is already set for RPCControllerMock.SendCascadeMessage")
	}

	mmSendCascadeMessage.mock.inspectFuncSendCascadeMessage = f

	return mmSendCascadeMessage
}

// Return sets up results that will be returned by RPCController.SendCascadeMessage
func (mmSendCascadeMessage *mRPCControllerMockSendCascadeMessage) Return(err error) *RPCControllerMock {
	if mmSendCascadeMessage.mock.funcSendCascadeMessage != nil {
		mmSendCascadeMessage.mock.t.Fatalf("RPCControllerMock.SendCascadeMessage mock is already set by Set")
	}

	if mmSendCascadeMessage.defaultExpectation == nil {
		mmSendCascadeMessage.defaultExpectation = &RPCControllerMockSendCascadeMessageExpectation{mock: mmSendCascadeMessage.mock}
	}
	mmSendCascadeMessage.defaultExpectation.results = &RPCControllerMockSendCascadeMessageResults{err}
	return mmSendCascadeMessage.mock
}

//Set uses given function f to mock the RPCController.SendCascadeMessage method
func (mmSendCascadeMessage *mRPCControllerMockSendCascadeMessage) Set(f func(data insolar.Cascade, method string, msg insolar.Parcel) (err error)) *RPCControllerMock {
	if mmSendCascadeMessage.defaultExpectation != nil {
		mmSendCascadeMessage.mock.t.Fatalf("Default expectation is already set for the RPCController.SendCascadeMessage method")
	}

	if len(mmSendCascadeMessage.expectations) > 0 {
		mmSendCascadeMessage.mock.t.Fatalf("Some expectations are already set for the RPCController.SendCascadeMessage method")
	}

	mmSendCascadeMessage.mock.funcSendCascadeMessage = f
	return mmSendCascadeMessage.mock
}

// When sets expectation for the RPCController.SendCascadeMessage which will trigger the result defined by the following
// Then helper
func (mmSendCascadeMessage *mRPCControllerMockSendCascadeMessage) When(data insolar.Cascade, method string, msg insolar.Parcel) *RPCControllerMockSendCascadeMessageExpectation {
	if mmSendCascadeMessage.mock.funcSendCascadeMessage != nil {
		mmSendCascadeMessage.mock.t.Fatalf("RPCControllerMock.SendCascadeMessage mock is already set by Set")
	}

	expectation := &RPCControllerMockSendCascadeMessageExpectation{
		mock:   mmSendCascadeMessage.mock,
		params: &RPCControllerMockSendCascadeMessageParams{data, method, msg},
	}
	mmSendCascadeMessage.expectations = append(mmSendCascadeMessage.expectations, expectation)
	return expectation
}

// Then sets up RPCController.SendCascadeMessage return parameters for the expectation previously defined by the When method
func (e *RPCControllerMockSendCascadeMessageExpectation) Then(err error) *RPCControllerMock {
	e.results = &RPCControllerMockSendCascadeMessageResults{err}
	return e.mock
}

// SendCascadeMessage implements controller.RPCController
func (mmSendCascadeMessage *RPCControllerMock) SendCascadeMessage(data insolar.Cascade, method string, msg insolar.Parcel) (err error) {
	mm_atomic.AddUint64(&mmSendCascadeMessage.beforeSendCascadeMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmSendCascadeMessage.afterSendCascadeMessageCounter, 1)

	if mmSendCascadeMessage.inspectFuncSendCascadeMessage != nil {
		mmSendCascadeMessage.inspectFuncSendCascadeMessage(data, method, msg)
	}

	params := &RPCControllerMockSendCascadeMessageParams{data, method, msg}

	// Record call args
	mmSendCascadeMessage.SendCascadeMessageMock.mutex.Lock()
	mmSendCascadeMessage.SendCascadeMessageMock.callArgs = append(mmSendCascadeMessage.SendCascadeMessageMock.callArgs, params)
	mmSendCascadeMessage.SendCascadeMessageMock.mutex.Unlock()

	for _, e := range mmSendCascadeMessage.SendCascadeMessageMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendCascadeMessage.SendCascadeMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendCascadeMessage.SendCascadeMessageMock.defaultExpectation.Counter, 1)
		want := mmSendCascadeMessage.SendCascadeMessageMock.defaultExpectation.params
		got := RPCControllerMockSendCascadeMessageParams{data, method, msg}
		if want != nil && !minimock.Equal(*want, got) {
			mmSendCascadeMessage.t.Errorf("RPCControllerMock.SendCascadeMessage got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmSendCascadeMessage.SendCascadeMessageMock.defaultExpectation.results
		if results == nil {
			mmSendCascadeMessage.t.Fatal("No results are set for the RPCControllerMock.SendCascadeMessage")
		}
		return (*results).err
	}
	if mmSendCascadeMessage.funcSendCascadeMessage != nil {
		return mmSendCascadeMessage.funcSendCascadeMessage(data, method, msg)
	}
	mmSendCascadeMessage.t.Fatalf("Unexpected call to RPCControllerMock.SendCascadeMessage. %v %v %v", data, method, msg)
	return
}

// SendCascadeMessageAfterCounter returns a count of finished RPCControllerMock.SendCascadeMessage invocations
func (mmSendCascadeMessage *RPCControllerMock) SendCascadeMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendCascadeMessage.afterSendCascadeMessageCounter)
}

// SendCascadeMessageBeforeCounter returns a count of RPCControllerMock.SendCascadeMessage invocations
func (mmSendCascadeMessage *RPCControllerMock) SendCascadeMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendCascadeMessage.beforeSendCascadeMessageCounter)
}

// Calls returns a list of arguments used in each call to RPCControllerMock.SendCascadeMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendCascadeMessage *mRPCControllerMockSendCascadeMessage) Calls() []*RPCControllerMockSendCascadeMessageParams {
	mmSendCascadeMessage.mutex.RLock()

	argCopy := make([]*RPCControllerMockSendCascadeMessageParams, len(mmSendCascadeMessage.callArgs))
	copy(argCopy, mmSendCascadeMessage.callArgs)

	mmSendCascadeMessage.mutex.RUnlock()

	return argCopy
}

// MinimockSendCascadeMessageDone returns true if the count of the SendCascadeMessage invocations corresponds
// the number of defined expectations
func (m *RPCControllerMock) MinimockSendCascadeMessageDone() bool {
	for _, e := range m.SendCascadeMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendCascadeMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendCascadeMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendCascadeMessage != nil && mm_atomic.LoadUint64(&m.afterSendCascadeMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendCascadeMessageInspect logs each unmet expectation
func (m *RPCControllerMock) MinimockSendCascadeMessageInspect() {
	for _, e := range m.SendCascadeMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RPCControllerMock.SendCascadeMessage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendCascadeMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendCascadeMessageCounter) < 1 {
		if m.SendCascadeMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RPCControllerMock.SendCascadeMessage")
		} else {
			m.t.Errorf("Expected call to RPCControllerMock.SendCascadeMessage with params: %#v", *m.SendCascadeMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendCascadeMessage != nil && mm_atomic.LoadUint64(&m.afterSendCascadeMessageCounter) < 1 {
		m.t.Error("Expected call to RPCControllerMock.SendCascadeMessage")
	}
}

type mRPCControllerMockSendMessage struct {
	mock               *RPCControllerMock
	defaultExpectation *RPCControllerMockSendMessageExpectation
	expectations       []*RPCControllerMockSendMessageExpectation

	callArgs []*RPCControllerMockSendMessageParams
	mutex    sync.RWMutex
}

// RPCControllerMockSendMessageExpectation specifies expectation struct of the RPCController.SendMessage
type RPCControllerMockSendMessageExpectation struct {
	mock    *RPCControllerMock
	params  *RPCControllerMockSendMessageParams
	results *RPCControllerMockSendMessageResults
	Counter uint64
}

// RPCControllerMockSendMessageParams contains parameters of the RPCController.SendMessage
type RPCControllerMockSendMessageParams struct {
	nodeID insolar.Reference
	name   string
	msg    insolar.Parcel
}

// RPCControllerMockSendMessageResults contains results of the RPCController.SendMessage
type RPCControllerMockSendMessageResults struct {
	ba1 []byte
	err error
}

// Expect sets up expected params for RPCController.SendMessage
func (mmSendMessage *mRPCControllerMockSendMessage) Expect(nodeID insolar.Reference, name string, msg insolar.Parcel) *mRPCControllerMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("RPCControllerMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &RPCControllerMockSendMessageExpectation{}
	}

	mmSendMessage.defaultExpectation.params = &RPCControllerMockSendMessageParams{nodeID, name, msg}
	for _, e := range mmSendMessage.expectations {
		if minimock.Equal(e.params, mmSendMessage.defaultExpectation.params) {
			mmSendMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMessage.defaultExpectation.params)
		}
	}

	return mmSendMessage
}

// Inspect accepts an inspector function that has same arguments as the RPCController.SendMessage
func (mmSendMessage *mRPCControllerMockSendMessage) Inspect(f func(nodeID insolar.Reference, name string, msg insolar.Parcel)) *mRPCControllerMockSendMessage {
	if mmSendMessage.mock.inspectFuncSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("Inspect function is already set for RPCControllerMock.SendMessage")
	}

	mmSendMessage.mock.inspectFuncSendMessage = f

	return mmSendMessage
}

// Return sets up results that will be returned by RPCController.SendMessage
func (mmSendMessage *mRPCControllerMockSendMessage) Return(ba1 []byte, err error) *RPCControllerMock {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("RPCControllerMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &RPCControllerMockSendMessageExpectation{mock: mmSendMessage.mock}
	}
	mmSendMessage.defaultExpectation.results = &RPCControllerMockSendMessageResults{ba1, err}
	return mmSendMessage.mock
}

//Set uses given function f to mock the RPCController.SendMessage method
func (mmSendMessage *mRPCControllerMockSendMessage) Set(f func(nodeID insolar.Reference, name string, msg insolar.Parcel) (ba1 []byte, err error)) *RPCControllerMock {
	if mmSendMessage.defaultExpectation != nil {
		mmSendMessage.mock.t.Fatalf("Default expectation is already set for the RPCController.SendMessage method")
	}

	if len(mmSendMessage.expectations) > 0 {
		mmSendMessage.mock.t.Fatalf("Some expectations are already set for the RPCController.SendMessage method")
	}

	mmSendMessage.mock.funcSendMessage = f
	return mmSendMessage.mock
}

// When sets expectation for the RPCController.SendMessage which will trigger the result defined by the following
// Then helper
func (mmSendMessage *mRPCControllerMockSendMessage) When(nodeID insolar.Reference, name string, msg insolar.Parcel) *RPCControllerMockSendMessageExpectation {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("RPCControllerMock.SendMessage mock is already set by Set")
	}

	expectation := &RPCControllerMockSendMessageExpectation{
		mock:   mmSendMessage.mock,
		params: &RPCControllerMockSendMessageParams{nodeID, name, msg},
	}
	mmSendMessage.expectations = append(mmSendMessage.expectations, expectation)
	return expectation
}

// Then sets up RPCController.SendMessage return parameters for the expectation previously defined by the When method
func (e *RPCControllerMockSendMessageExpectation) Then(ba1 []byte, err error) *RPCControllerMock {
	e.results = &RPCControllerMockSendMessageResults{ba1, err}
	return e.mock
}

// SendMessage implements controller.RPCController
func (mmSendMessage *RPCControllerMock) SendMessage(nodeID insolar.Reference, name string, msg insolar.Parcel) (ba1 []byte, err error) {
	mm_atomic.AddUint64(&mmSendMessage.beforeSendMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMessage.afterSendMessageCounter, 1)

	if mmSendMessage.inspectFuncSendMessage != nil {
		mmSendMessage.inspectFuncSendMessage(nodeID, name, msg)
	}

	params := &RPCControllerMockSendMessageParams{nodeID, name, msg}

	// Record call args
	mmSendMessage.SendMessageMock.mutex.Lock()
	mmSendMessage.SendMessageMock.callArgs = append(mmSendMessage.SendMessageMock.callArgs, params)
	mmSendMessage.SendMessageMock.mutex.Unlock()

	for _, e := range mmSendMessage.SendMessageMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ba1, e.results.err
		}
	}

	if mmSendMessage.SendMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMessage.SendMessageMock.defaultExpectation.Counter, 1)
		want := mmSendMessage.SendMessageMock.defaultExpectation.params
		got := RPCControllerMockSendMessageParams{nodeID, name, msg}
		if want != nil && !minimock.Equal(*want, got) {
			mmSendMessage.t.Errorf("RPCControllerMock.SendMessage got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmSendMessage.SendMessageMock.defaultExpectation.results
		if results == nil {
			mmSendMessage.t.Fatal("No results are set for the RPCControllerMock.SendMessage")
		}
		return (*results).ba1, (*results).err
	}
	if mmSendMessage.funcSendMessage != nil {
		return mmSendMessage.funcSendMessage(nodeID, name, msg)
	}
	mmSendMessage.t.Fatalf("Unexpected call to RPCControllerMock.SendMessage. %v %v %v", nodeID, name, msg)
	return
}

// SendMessageAfterCounter returns a count of finished RPCControllerMock.SendMessage invocations
func (mmSendMessage *RPCControllerMock) SendMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.afterSendMessageCounter)
}

// SendMessageBeforeCounter returns a count of RPCControllerMock.SendMessage invocations
func (mmSendMessage *RPCControllerMock) SendMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.beforeSendMessageCounter)
}

// Calls returns a list of arguments used in each call to RPCControllerMock.SendMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMessage *mRPCControllerMockSendMessage) Calls() []*RPCControllerMockSendMessageParams {
	mmSendMessage.mutex.RLock()

	argCopy := make([]*RPCControllerMockSendMessageParams, len(mmSendMessage.callArgs))
	copy(argCopy, mmSendMessage.callArgs)

	mmSendMessage.mutex.RUnlock()

	return argCopy
}

// MinimockSendMessageDone returns true if the count of the SendMessage invocations corresponds
// the number of defined expectations
func (m *RPCControllerMock) MinimockSendMessageDone() bool {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendMessageInspect logs each unmet expectation
func (m *RPCControllerMock) MinimockSendMessageInspect() {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RPCControllerMock.SendMessage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		if m.SendMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RPCControllerMock.SendMessage")
		} else {
			m.t.Errorf("Expected call to RPCControllerMock.SendMessage with params: %#v", *m.SendMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		m.t.Error("Expected call to RPCControllerMock.SendMessage")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RPCControllerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockInitInspect()

		m.MinimockRemoteProcedureRegisterInspect()

		m.MinimockSendBytesInspect()

		m.MinimockSendCascadeMessageInspect()

		m.MinimockSendMessageInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RPCControllerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RPCControllerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockInitDone() &&
		m.MinimockRemoteProcedureRegisterDone() &&
		m.MinimockSendBytesDone() &&
		m.MinimockSendCascadeMessageDone() &&
		m.MinimockSendMessageDone()
}
