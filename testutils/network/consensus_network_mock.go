package network

// Code generated by http://github.com/gojuno/minimock (3.0.0). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/insolar/insolar"
	mm_network "github.com/insolar/insolar/network"
	"github.com/insolar/insolar/network/consensusv1/packets"
)

// ConsensusNetworkMock implements network.ConsensusNetwork
type ConsensusNetworkMock struct {
	t minimock.Tester

	funcInit          func(ctx context.Context) (err error)
	inspectFuncInit   func(ctx context.Context)
	afterInitCounter  uint64
	beforeInitCounter uint64
	InitMock          mConsensusNetworkMockInit

	funcPublicAddress          func() (s1 string)
	inspectFuncPublicAddress   func()
	afterPublicAddressCounter  uint64
	beforePublicAddressCounter uint64
	PublicAddressMock          mConsensusNetworkMockPublicAddress

	funcRegisterPacketHandler          func(t packets.PacketType, handler mm_network.ConsensusPacketHandler)
	inspectFuncRegisterPacketHandler   func(t packets.PacketType, handler mm_network.ConsensusPacketHandler)
	afterRegisterPacketHandlerCounter  uint64
	beforeRegisterPacketHandlerCounter uint64
	RegisterPacketHandlerMock          mConsensusNetworkMockRegisterPacketHandler

	funcSignAndSendPacket          func(packet packets.ConsensusPacket, receiver insolar.Reference, service insolar.CryptographyService) (err error)
	inspectFuncSignAndSendPacket   func(packet packets.ConsensusPacket, receiver insolar.Reference, service insolar.CryptographyService)
	afterSignAndSendPacketCounter  uint64
	beforeSignAndSendPacketCounter uint64
	SignAndSendPacketMock          mConsensusNetworkMockSignAndSendPacket

	funcStart          func(ctx context.Context) (err error)
	inspectFuncStart   func(ctx context.Context)
	afterStartCounter  uint64
	beforeStartCounter uint64
	StartMock          mConsensusNetworkMockStart

	funcStop          func(ctx context.Context) (err error)
	inspectFuncStop   func(ctx context.Context)
	afterStopCounter  uint64
	beforeStopCounter uint64
	StopMock          mConsensusNetworkMockStop
}

// NewConsensusNetworkMock returns a mock for network.ConsensusNetwork
func NewConsensusNetworkMock(t minimock.Tester) *ConsensusNetworkMock {
	m := &ConsensusNetworkMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.InitMock = mConsensusNetworkMockInit{mock: m}
	m.InitMock.callArgs = []*ConsensusNetworkMockInitParams{}

	m.PublicAddressMock = mConsensusNetworkMockPublicAddress{mock: m}

	m.RegisterPacketHandlerMock = mConsensusNetworkMockRegisterPacketHandler{mock: m}
	m.RegisterPacketHandlerMock.callArgs = []*ConsensusNetworkMockRegisterPacketHandlerParams{}

	m.SignAndSendPacketMock = mConsensusNetworkMockSignAndSendPacket{mock: m}
	m.SignAndSendPacketMock.callArgs = []*ConsensusNetworkMockSignAndSendPacketParams{}

	m.StartMock = mConsensusNetworkMockStart{mock: m}
	m.StartMock.callArgs = []*ConsensusNetworkMockStartParams{}

	m.StopMock = mConsensusNetworkMockStop{mock: m}
	m.StopMock.callArgs = []*ConsensusNetworkMockStopParams{}

	return m
}

type mConsensusNetworkMockInit struct {
	mock               *ConsensusNetworkMock
	defaultExpectation *ConsensusNetworkMockInitExpectation
	expectations       []*ConsensusNetworkMockInitExpectation

	callArgs []*ConsensusNetworkMockInitParams
	mutex    sync.RWMutex
}

// ConsensusNetworkMockInitExpectation specifies expectation struct of the ConsensusNetwork.Init
type ConsensusNetworkMockInitExpectation struct {
	mock    *ConsensusNetworkMock
	params  *ConsensusNetworkMockInitParams
	results *ConsensusNetworkMockInitResults
	Counter uint64
}

// ConsensusNetworkMockInitParams contains parameters of the ConsensusNetwork.Init
type ConsensusNetworkMockInitParams struct {
	ctx context.Context
}

// ConsensusNetworkMockInitResults contains results of the ConsensusNetwork.Init
type ConsensusNetworkMockInitResults struct {
	err error
}

// Expect sets up expected params for ConsensusNetwork.Init
func (mmInit *mConsensusNetworkMockInit) Expect(ctx context.Context) *mConsensusNetworkMockInit {
	if mmInit.mock.funcInit != nil {
		mmInit.mock.t.Fatalf("ConsensusNetworkMock.Init mock is already set by Set")
	}

	if mmInit.defaultExpectation == nil {
		mmInit.defaultExpectation = &ConsensusNetworkMockInitExpectation{}
	}

	mmInit.defaultExpectation.params = &ConsensusNetworkMockInitParams{ctx}
	for _, e := range mmInit.expectations {
		if minimock.Equal(e.params, mmInit.defaultExpectation.params) {
			mmInit.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInit.defaultExpectation.params)
		}
	}

	return mmInit
}

// Inspect accepts an inspector function that has same arguments as the ConsensusNetwork.Init
func (mmInit *mConsensusNetworkMockInit) Inspect(f func(ctx context.Context)) *mConsensusNetworkMockInit {
	if mmInit.mock.inspectFuncInit != nil {
		mmInit.mock.t.Fatalf("Inspect function is already set for ConsensusNetworkMock.Init")
	}

	mmInit.mock.inspectFuncInit = f

	return mmInit
}

// Return sets up results that will be returned by ConsensusNetwork.Init
func (mmInit *mConsensusNetworkMockInit) Return(err error) *ConsensusNetworkMock {
	if mmInit.mock.funcInit != nil {
		mmInit.mock.t.Fatalf("ConsensusNetworkMock.Init mock is already set by Set")
	}

	if mmInit.defaultExpectation == nil {
		mmInit.defaultExpectation = &ConsensusNetworkMockInitExpectation{mock: mmInit.mock}
	}
	mmInit.defaultExpectation.results = &ConsensusNetworkMockInitResults{err}
	return mmInit.mock
}

//Set uses given function f to mock the ConsensusNetwork.Init method
func (mmInit *mConsensusNetworkMockInit) Set(f func(ctx context.Context) (err error)) *ConsensusNetworkMock {
	if mmInit.defaultExpectation != nil {
		mmInit.mock.t.Fatalf("Default expectation is already set for the ConsensusNetwork.Init method")
	}

	if len(mmInit.expectations) > 0 {
		mmInit.mock.t.Fatalf("Some expectations are already set for the ConsensusNetwork.Init method")
	}

	mmInit.mock.funcInit = f
	return mmInit.mock
}

// When sets expectation for the ConsensusNetwork.Init which will trigger the result defined by the following
// Then helper
func (mmInit *mConsensusNetworkMockInit) When(ctx context.Context) *ConsensusNetworkMockInitExpectation {
	if mmInit.mock.funcInit != nil {
		mmInit.mock.t.Fatalf("ConsensusNetworkMock.Init mock is already set by Set")
	}

	expectation := &ConsensusNetworkMockInitExpectation{
		mock:   mmInit.mock,
		params: &ConsensusNetworkMockInitParams{ctx},
	}
	mmInit.expectations = append(mmInit.expectations, expectation)
	return expectation
}

// Then sets up ConsensusNetwork.Init return parameters for the expectation previously defined by the When method
func (e *ConsensusNetworkMockInitExpectation) Then(err error) *ConsensusNetworkMock {
	e.results = &ConsensusNetworkMockInitResults{err}
	return e.mock
}

// Init implements network.ConsensusNetwork
func (mmInit *ConsensusNetworkMock) Init(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmInit.beforeInitCounter, 1)
	defer mm_atomic.AddUint64(&mmInit.afterInitCounter, 1)

	if mmInit.inspectFuncInit != nil {
		mmInit.inspectFuncInit(ctx)
	}

	params := &ConsensusNetworkMockInitParams{ctx}

	// Record call args
	mmInit.InitMock.mutex.Lock()
	mmInit.InitMock.callArgs = append(mmInit.InitMock.callArgs, params)
	mmInit.InitMock.mutex.Unlock()

	for _, e := range mmInit.InitMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmInit.InitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInit.InitMock.defaultExpectation.Counter, 1)
		want := mmInit.InitMock.defaultExpectation.params
		got := ConsensusNetworkMockInitParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmInit.t.Errorf("ConsensusNetworkMock.Init got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmInit.InitMock.defaultExpectation.results
		if results == nil {
			mmInit.t.Fatal("No results are set for the ConsensusNetworkMock.Init")
		}
		return (*results).err
	}
	if mmInit.funcInit != nil {
		return mmInit.funcInit(ctx)
	}
	mmInit.t.Fatalf("Unexpected call to ConsensusNetworkMock.Init. %v", ctx)
	return
}

// InitAfterCounter returns a count of finished ConsensusNetworkMock.Init invocations
func (mmInit *ConsensusNetworkMock) InitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInit.afterInitCounter)
}

// InitBeforeCounter returns a count of ConsensusNetworkMock.Init invocations
func (mmInit *ConsensusNetworkMock) InitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInit.beforeInitCounter)
}

// Calls returns a list of arguments used in each call to ConsensusNetworkMock.Init.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInit *mConsensusNetworkMockInit) Calls() []*ConsensusNetworkMockInitParams {
	mmInit.mutex.RLock()

	argCopy := make([]*ConsensusNetworkMockInitParams, len(mmInit.callArgs))
	copy(argCopy, mmInit.callArgs)

	mmInit.mutex.RUnlock()

	return argCopy
}

// MinimockInitDone returns true if the count of the Init invocations corresponds
// the number of defined expectations
func (m *ConsensusNetworkMock) MinimockInitDone() bool {
	for _, e := range m.InitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInitCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInit != nil && mm_atomic.LoadUint64(&m.afterInitCounter) < 1 {
		return false
	}
	return true
}

// MinimockInitInspect logs each unmet expectation
func (m *ConsensusNetworkMock) MinimockInitInspect() {
	for _, e := range m.InitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConsensusNetworkMock.Init with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInitCounter) < 1 {
		if m.InitMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConsensusNetworkMock.Init")
		} else {
			m.t.Errorf("Expected call to ConsensusNetworkMock.Init with params: %#v", *m.InitMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInit != nil && mm_atomic.LoadUint64(&m.afterInitCounter) < 1 {
		m.t.Error("Expected call to ConsensusNetworkMock.Init")
	}
}

type mConsensusNetworkMockPublicAddress struct {
	mock               *ConsensusNetworkMock
	defaultExpectation *ConsensusNetworkMockPublicAddressExpectation
	expectations       []*ConsensusNetworkMockPublicAddressExpectation
}

// ConsensusNetworkMockPublicAddressExpectation specifies expectation struct of the ConsensusNetwork.PublicAddress
type ConsensusNetworkMockPublicAddressExpectation struct {
	mock *ConsensusNetworkMock

	results *ConsensusNetworkMockPublicAddressResults
	Counter uint64
}

// ConsensusNetworkMockPublicAddressResults contains results of the ConsensusNetwork.PublicAddress
type ConsensusNetworkMockPublicAddressResults struct {
	s1 string
}

// Expect sets up expected params for ConsensusNetwork.PublicAddress
func (mmPublicAddress *mConsensusNetworkMockPublicAddress) Expect() *mConsensusNetworkMockPublicAddress {
	if mmPublicAddress.mock.funcPublicAddress != nil {
		mmPublicAddress.mock.t.Fatalf("ConsensusNetworkMock.PublicAddress mock is already set by Set")
	}

	if mmPublicAddress.defaultExpectation == nil {
		mmPublicAddress.defaultExpectation = &ConsensusNetworkMockPublicAddressExpectation{}
	}

	return mmPublicAddress
}

// Inspect accepts an inspector function that has same arguments as the ConsensusNetwork.PublicAddress
func (mmPublicAddress *mConsensusNetworkMockPublicAddress) Inspect(f func()) *mConsensusNetworkMockPublicAddress {
	if mmPublicAddress.mock.inspectFuncPublicAddress != nil {
		mmPublicAddress.mock.t.Fatalf("Inspect function is already set for ConsensusNetworkMock.PublicAddress")
	}

	mmPublicAddress.mock.inspectFuncPublicAddress = f

	return mmPublicAddress
}

// Return sets up results that will be returned by ConsensusNetwork.PublicAddress
func (mmPublicAddress *mConsensusNetworkMockPublicAddress) Return(s1 string) *ConsensusNetworkMock {
	if mmPublicAddress.mock.funcPublicAddress != nil {
		mmPublicAddress.mock.t.Fatalf("ConsensusNetworkMock.PublicAddress mock is already set by Set")
	}

	if mmPublicAddress.defaultExpectation == nil {
		mmPublicAddress.defaultExpectation = &ConsensusNetworkMockPublicAddressExpectation{mock: mmPublicAddress.mock}
	}
	mmPublicAddress.defaultExpectation.results = &ConsensusNetworkMockPublicAddressResults{s1}
	return mmPublicAddress.mock
}

//Set uses given function f to mock the ConsensusNetwork.PublicAddress method
func (mmPublicAddress *mConsensusNetworkMockPublicAddress) Set(f func() (s1 string)) *ConsensusNetworkMock {
	if mmPublicAddress.defaultExpectation != nil {
		mmPublicAddress.mock.t.Fatalf("Default expectation is already set for the ConsensusNetwork.PublicAddress method")
	}

	if len(mmPublicAddress.expectations) > 0 {
		mmPublicAddress.mock.t.Fatalf("Some expectations are already set for the ConsensusNetwork.PublicAddress method")
	}

	mmPublicAddress.mock.funcPublicAddress = f
	return mmPublicAddress.mock
}

// PublicAddress implements network.ConsensusNetwork
func (mmPublicAddress *ConsensusNetworkMock) PublicAddress() (s1 string) {
	mm_atomic.AddUint64(&mmPublicAddress.beforePublicAddressCounter, 1)
	defer mm_atomic.AddUint64(&mmPublicAddress.afterPublicAddressCounter, 1)

	if mmPublicAddress.inspectFuncPublicAddress != nil {
		mmPublicAddress.inspectFuncPublicAddress()
	}

	if mmPublicAddress.PublicAddressMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPublicAddress.PublicAddressMock.defaultExpectation.Counter, 1)

		results := mmPublicAddress.PublicAddressMock.defaultExpectation.results
		if results == nil {
			mmPublicAddress.t.Fatal("No results are set for the ConsensusNetworkMock.PublicAddress")
		}
		return (*results).s1
	}
	if mmPublicAddress.funcPublicAddress != nil {
		return mmPublicAddress.funcPublicAddress()
	}
	mmPublicAddress.t.Fatalf("Unexpected call to ConsensusNetworkMock.PublicAddress.")
	return
}

// PublicAddressAfterCounter returns a count of finished ConsensusNetworkMock.PublicAddress invocations
func (mmPublicAddress *ConsensusNetworkMock) PublicAddressAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublicAddress.afterPublicAddressCounter)
}

// PublicAddressBeforeCounter returns a count of ConsensusNetworkMock.PublicAddress invocations
func (mmPublicAddress *ConsensusNetworkMock) PublicAddressBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublicAddress.beforePublicAddressCounter)
}

// MinimockPublicAddressDone returns true if the count of the PublicAddress invocations corresponds
// the number of defined expectations
func (m *ConsensusNetworkMock) MinimockPublicAddressDone() bool {
	for _, e := range m.PublicAddressMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublicAddressMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublicAddressCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublicAddress != nil && mm_atomic.LoadUint64(&m.afterPublicAddressCounter) < 1 {
		return false
	}
	return true
}

// MinimockPublicAddressInspect logs each unmet expectation
func (m *ConsensusNetworkMock) MinimockPublicAddressInspect() {
	for _, e := range m.PublicAddressMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConsensusNetworkMock.PublicAddress")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublicAddressMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublicAddressCounter) < 1 {
		m.t.Error("Expected call to ConsensusNetworkMock.PublicAddress")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublicAddress != nil && mm_atomic.LoadUint64(&m.afterPublicAddressCounter) < 1 {
		m.t.Error("Expected call to ConsensusNetworkMock.PublicAddress")
	}
}

type mConsensusNetworkMockRegisterPacketHandler struct {
	mock               *ConsensusNetworkMock
	defaultExpectation *ConsensusNetworkMockRegisterPacketHandlerExpectation
	expectations       []*ConsensusNetworkMockRegisterPacketHandlerExpectation

	callArgs []*ConsensusNetworkMockRegisterPacketHandlerParams
	mutex    sync.RWMutex
}

// ConsensusNetworkMockRegisterPacketHandlerExpectation specifies expectation struct of the ConsensusNetwork.RegisterPacketHandler
type ConsensusNetworkMockRegisterPacketHandlerExpectation struct {
	mock   *ConsensusNetworkMock
	params *ConsensusNetworkMockRegisterPacketHandlerParams

	Counter uint64
}

// ConsensusNetworkMockRegisterPacketHandlerParams contains parameters of the ConsensusNetwork.RegisterPacketHandler
type ConsensusNetworkMockRegisterPacketHandlerParams struct {
	t       packets.PacketType
	handler mm_network.ConsensusPacketHandler
}

// Expect sets up expected params for ConsensusNetwork.RegisterPacketHandler
func (mmRegisterPacketHandler *mConsensusNetworkMockRegisterPacketHandler) Expect(t packets.PacketType, handler mm_network.ConsensusPacketHandler) *mConsensusNetworkMockRegisterPacketHandler {
	if mmRegisterPacketHandler.mock.funcRegisterPacketHandler != nil {
		mmRegisterPacketHandler.mock.t.Fatalf("ConsensusNetworkMock.RegisterPacketHandler mock is already set by Set")
	}

	if mmRegisterPacketHandler.defaultExpectation == nil {
		mmRegisterPacketHandler.defaultExpectation = &ConsensusNetworkMockRegisterPacketHandlerExpectation{}
	}

	mmRegisterPacketHandler.defaultExpectation.params = &ConsensusNetworkMockRegisterPacketHandlerParams{t, handler}
	for _, e := range mmRegisterPacketHandler.expectations {
		if minimock.Equal(e.params, mmRegisterPacketHandler.defaultExpectation.params) {
			mmRegisterPacketHandler.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterPacketHandler.defaultExpectation.params)
		}
	}

	return mmRegisterPacketHandler
}

// Inspect accepts an inspector function that has same arguments as the ConsensusNetwork.RegisterPacketHandler
func (mmRegisterPacketHandler *mConsensusNetworkMockRegisterPacketHandler) Inspect(f func(t packets.PacketType, handler mm_network.ConsensusPacketHandler)) *mConsensusNetworkMockRegisterPacketHandler {
	if mmRegisterPacketHandler.mock.inspectFuncRegisterPacketHandler != nil {
		mmRegisterPacketHandler.mock.t.Fatalf("Inspect function is already set for ConsensusNetworkMock.RegisterPacketHandler")
	}

	mmRegisterPacketHandler.mock.inspectFuncRegisterPacketHandler = f

	return mmRegisterPacketHandler
}

// Return sets up results that will be returned by ConsensusNetwork.RegisterPacketHandler
func (mmRegisterPacketHandler *mConsensusNetworkMockRegisterPacketHandler) Return() *ConsensusNetworkMock {
	if mmRegisterPacketHandler.mock.funcRegisterPacketHandler != nil {
		mmRegisterPacketHandler.mock.t.Fatalf("ConsensusNetworkMock.RegisterPacketHandler mock is already set by Set")
	}

	if mmRegisterPacketHandler.defaultExpectation == nil {
		mmRegisterPacketHandler.defaultExpectation = &ConsensusNetworkMockRegisterPacketHandlerExpectation{mock: mmRegisterPacketHandler.mock}
	}

	return mmRegisterPacketHandler.mock
}

//Set uses given function f to mock the ConsensusNetwork.RegisterPacketHandler method
func (mmRegisterPacketHandler *mConsensusNetworkMockRegisterPacketHandler) Set(f func(t packets.PacketType, handler mm_network.ConsensusPacketHandler)) *ConsensusNetworkMock {
	if mmRegisterPacketHandler.defaultExpectation != nil {
		mmRegisterPacketHandler.mock.t.Fatalf("Default expectation is already set for the ConsensusNetwork.RegisterPacketHandler method")
	}

	if len(mmRegisterPacketHandler.expectations) > 0 {
		mmRegisterPacketHandler.mock.t.Fatalf("Some expectations are already set for the ConsensusNetwork.RegisterPacketHandler method")
	}

	mmRegisterPacketHandler.mock.funcRegisterPacketHandler = f
	return mmRegisterPacketHandler.mock
}

// RegisterPacketHandler implements network.ConsensusNetwork
func (mmRegisterPacketHandler *ConsensusNetworkMock) RegisterPacketHandler(t packets.PacketType, handler mm_network.ConsensusPacketHandler) {
	mm_atomic.AddUint64(&mmRegisterPacketHandler.beforeRegisterPacketHandlerCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterPacketHandler.afterRegisterPacketHandlerCounter, 1)

	if mmRegisterPacketHandler.inspectFuncRegisterPacketHandler != nil {
		mmRegisterPacketHandler.inspectFuncRegisterPacketHandler(t, handler)
	}

	params := &ConsensusNetworkMockRegisterPacketHandlerParams{t, handler}

	// Record call args
	mmRegisterPacketHandler.RegisterPacketHandlerMock.mutex.Lock()
	mmRegisterPacketHandler.RegisterPacketHandlerMock.callArgs = append(mmRegisterPacketHandler.RegisterPacketHandlerMock.callArgs, params)
	mmRegisterPacketHandler.RegisterPacketHandlerMock.mutex.Unlock()

	for _, e := range mmRegisterPacketHandler.RegisterPacketHandlerMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmRegisterPacketHandler.RegisterPacketHandlerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterPacketHandler.RegisterPacketHandlerMock.defaultExpectation.Counter, 1)
		want := mmRegisterPacketHandler.RegisterPacketHandlerMock.defaultExpectation.params
		got := ConsensusNetworkMockRegisterPacketHandlerParams{t, handler}
		if want != nil && !minimock.Equal(*want, got) {
			mmRegisterPacketHandler.t.Errorf("ConsensusNetworkMock.RegisterPacketHandler got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmRegisterPacketHandler.funcRegisterPacketHandler != nil {
		mmRegisterPacketHandler.funcRegisterPacketHandler(t, handler)
		return
	}
	mmRegisterPacketHandler.t.Fatalf("Unexpected call to ConsensusNetworkMock.RegisterPacketHandler. %v %v", t, handler)

}

// RegisterPacketHandlerAfterCounter returns a count of finished ConsensusNetworkMock.RegisterPacketHandler invocations
func (mmRegisterPacketHandler *ConsensusNetworkMock) RegisterPacketHandlerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterPacketHandler.afterRegisterPacketHandlerCounter)
}

// RegisterPacketHandlerBeforeCounter returns a count of ConsensusNetworkMock.RegisterPacketHandler invocations
func (mmRegisterPacketHandler *ConsensusNetworkMock) RegisterPacketHandlerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterPacketHandler.beforeRegisterPacketHandlerCounter)
}

// Calls returns a list of arguments used in each call to ConsensusNetworkMock.RegisterPacketHandler.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterPacketHandler *mConsensusNetworkMockRegisterPacketHandler) Calls() []*ConsensusNetworkMockRegisterPacketHandlerParams {
	mmRegisterPacketHandler.mutex.RLock()

	argCopy := make([]*ConsensusNetworkMockRegisterPacketHandlerParams, len(mmRegisterPacketHandler.callArgs))
	copy(argCopy, mmRegisterPacketHandler.callArgs)

	mmRegisterPacketHandler.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterPacketHandlerDone returns true if the count of the RegisterPacketHandler invocations corresponds
// the number of defined expectations
func (m *ConsensusNetworkMock) MinimockRegisterPacketHandlerDone() bool {
	for _, e := range m.RegisterPacketHandlerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterPacketHandlerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterPacketHandlerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterPacketHandler != nil && mm_atomic.LoadUint64(&m.afterRegisterPacketHandlerCounter) < 1 {
		return false
	}
	return true
}

// MinimockRegisterPacketHandlerInspect logs each unmet expectation
func (m *ConsensusNetworkMock) MinimockRegisterPacketHandlerInspect() {
	for _, e := range m.RegisterPacketHandlerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConsensusNetworkMock.RegisterPacketHandler with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterPacketHandlerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterPacketHandlerCounter) < 1 {
		if m.RegisterPacketHandlerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConsensusNetworkMock.RegisterPacketHandler")
		} else {
			m.t.Errorf("Expected call to ConsensusNetworkMock.RegisterPacketHandler with params: %#v", *m.RegisterPacketHandlerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterPacketHandler != nil && mm_atomic.LoadUint64(&m.afterRegisterPacketHandlerCounter) < 1 {
		m.t.Error("Expected call to ConsensusNetworkMock.RegisterPacketHandler")
	}
}

type mConsensusNetworkMockSignAndSendPacket struct {
	mock               *ConsensusNetworkMock
	defaultExpectation *ConsensusNetworkMockSignAndSendPacketExpectation
	expectations       []*ConsensusNetworkMockSignAndSendPacketExpectation

	callArgs []*ConsensusNetworkMockSignAndSendPacketParams
	mutex    sync.RWMutex
}

// ConsensusNetworkMockSignAndSendPacketExpectation specifies expectation struct of the ConsensusNetwork.SignAndSendPacket
type ConsensusNetworkMockSignAndSendPacketExpectation struct {
	mock    *ConsensusNetworkMock
	params  *ConsensusNetworkMockSignAndSendPacketParams
	results *ConsensusNetworkMockSignAndSendPacketResults
	Counter uint64
}

// ConsensusNetworkMockSignAndSendPacketParams contains parameters of the ConsensusNetwork.SignAndSendPacket
type ConsensusNetworkMockSignAndSendPacketParams struct {
	packet   packets.ConsensusPacket
	receiver insolar.Reference
	service  insolar.CryptographyService
}

// ConsensusNetworkMockSignAndSendPacketResults contains results of the ConsensusNetwork.SignAndSendPacket
type ConsensusNetworkMockSignAndSendPacketResults struct {
	err error
}

// Expect sets up expected params for ConsensusNetwork.SignAndSendPacket
func (mmSignAndSendPacket *mConsensusNetworkMockSignAndSendPacket) Expect(packet packets.ConsensusPacket, receiver insolar.Reference, service insolar.CryptographyService) *mConsensusNetworkMockSignAndSendPacket {
	if mmSignAndSendPacket.mock.funcSignAndSendPacket != nil {
		mmSignAndSendPacket.mock.t.Fatalf("ConsensusNetworkMock.SignAndSendPacket mock is already set by Set")
	}

	if mmSignAndSendPacket.defaultExpectation == nil {
		mmSignAndSendPacket.defaultExpectation = &ConsensusNetworkMockSignAndSendPacketExpectation{}
	}

	mmSignAndSendPacket.defaultExpectation.params = &ConsensusNetworkMockSignAndSendPacketParams{packet, receiver, service}
	for _, e := range mmSignAndSendPacket.expectations {
		if minimock.Equal(e.params, mmSignAndSendPacket.defaultExpectation.params) {
			mmSignAndSendPacket.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSignAndSendPacket.defaultExpectation.params)
		}
	}

	return mmSignAndSendPacket
}

// Inspect accepts an inspector function that has same arguments as the ConsensusNetwork.SignAndSendPacket
func (mmSignAndSendPacket *mConsensusNetworkMockSignAndSendPacket) Inspect(f func(packet packets.ConsensusPacket, receiver insolar.Reference, service insolar.CryptographyService)) *mConsensusNetworkMockSignAndSendPacket {
	if mmSignAndSendPacket.mock.inspectFuncSignAndSendPacket != nil {
		mmSignAndSendPacket.mock.t.Fatalf("Inspect function is already set for ConsensusNetworkMock.SignAndSendPacket")
	}

	mmSignAndSendPacket.mock.inspectFuncSignAndSendPacket = f

	return mmSignAndSendPacket
}

// Return sets up results that will be returned by ConsensusNetwork.SignAndSendPacket
func (mmSignAndSendPacket *mConsensusNetworkMockSignAndSendPacket) Return(err error) *ConsensusNetworkMock {
	if mmSignAndSendPacket.mock.funcSignAndSendPacket != nil {
		mmSignAndSendPacket.mock.t.Fatalf("ConsensusNetworkMock.SignAndSendPacket mock is already set by Set")
	}

	if mmSignAndSendPacket.defaultExpectation == nil {
		mmSignAndSendPacket.defaultExpectation = &ConsensusNetworkMockSignAndSendPacketExpectation{mock: mmSignAndSendPacket.mock}
	}
	mmSignAndSendPacket.defaultExpectation.results = &ConsensusNetworkMockSignAndSendPacketResults{err}
	return mmSignAndSendPacket.mock
}

//Set uses given function f to mock the ConsensusNetwork.SignAndSendPacket method
func (mmSignAndSendPacket *mConsensusNetworkMockSignAndSendPacket) Set(f func(packet packets.ConsensusPacket, receiver insolar.Reference, service insolar.CryptographyService) (err error)) *ConsensusNetworkMock {
	if mmSignAndSendPacket.defaultExpectation != nil {
		mmSignAndSendPacket.mock.t.Fatalf("Default expectation is already set for the ConsensusNetwork.SignAndSendPacket method")
	}

	if len(mmSignAndSendPacket.expectations) > 0 {
		mmSignAndSendPacket.mock.t.Fatalf("Some expectations are already set for the ConsensusNetwork.SignAndSendPacket method")
	}

	mmSignAndSendPacket.mock.funcSignAndSendPacket = f
	return mmSignAndSendPacket.mock
}

// When sets expectation for the ConsensusNetwork.SignAndSendPacket which will trigger the result defined by the following
// Then helper
func (mmSignAndSendPacket *mConsensusNetworkMockSignAndSendPacket) When(packet packets.ConsensusPacket, receiver insolar.Reference, service insolar.CryptographyService) *ConsensusNetworkMockSignAndSendPacketExpectation {
	if mmSignAndSendPacket.mock.funcSignAndSendPacket != nil {
		mmSignAndSendPacket.mock.t.Fatalf("ConsensusNetworkMock.SignAndSendPacket mock is already set by Set")
	}

	expectation := &ConsensusNetworkMockSignAndSendPacketExpectation{
		mock:   mmSignAndSendPacket.mock,
		params: &ConsensusNetworkMockSignAndSendPacketParams{packet, receiver, service},
	}
	mmSignAndSendPacket.expectations = append(mmSignAndSendPacket.expectations, expectation)
	return expectation
}

// Then sets up ConsensusNetwork.SignAndSendPacket return parameters for the expectation previously defined by the When method
func (e *ConsensusNetworkMockSignAndSendPacketExpectation) Then(err error) *ConsensusNetworkMock {
	e.results = &ConsensusNetworkMockSignAndSendPacketResults{err}
	return e.mock
}

// SignAndSendPacket implements network.ConsensusNetwork
func (mmSignAndSendPacket *ConsensusNetworkMock) SignAndSendPacket(packet packets.ConsensusPacket, receiver insolar.Reference, service insolar.CryptographyService) (err error) {
	mm_atomic.AddUint64(&mmSignAndSendPacket.beforeSignAndSendPacketCounter, 1)
	defer mm_atomic.AddUint64(&mmSignAndSendPacket.afterSignAndSendPacketCounter, 1)

	if mmSignAndSendPacket.inspectFuncSignAndSendPacket != nil {
		mmSignAndSendPacket.inspectFuncSignAndSendPacket(packet, receiver, service)
	}

	params := &ConsensusNetworkMockSignAndSendPacketParams{packet, receiver, service}

	// Record call args
	mmSignAndSendPacket.SignAndSendPacketMock.mutex.Lock()
	mmSignAndSendPacket.SignAndSendPacketMock.callArgs = append(mmSignAndSendPacket.SignAndSendPacketMock.callArgs, params)
	mmSignAndSendPacket.SignAndSendPacketMock.mutex.Unlock()

	for _, e := range mmSignAndSendPacket.SignAndSendPacketMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSignAndSendPacket.SignAndSendPacketMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSignAndSendPacket.SignAndSendPacketMock.defaultExpectation.Counter, 1)
		want := mmSignAndSendPacket.SignAndSendPacketMock.defaultExpectation.params
		got := ConsensusNetworkMockSignAndSendPacketParams{packet, receiver, service}
		if want != nil && !minimock.Equal(*want, got) {
			mmSignAndSendPacket.t.Errorf("ConsensusNetworkMock.SignAndSendPacket got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmSignAndSendPacket.SignAndSendPacketMock.defaultExpectation.results
		if results == nil {
			mmSignAndSendPacket.t.Fatal("No results are set for the ConsensusNetworkMock.SignAndSendPacket")
		}
		return (*results).err
	}
	if mmSignAndSendPacket.funcSignAndSendPacket != nil {
		return mmSignAndSendPacket.funcSignAndSendPacket(packet, receiver, service)
	}
	mmSignAndSendPacket.t.Fatalf("Unexpected call to ConsensusNetworkMock.SignAndSendPacket. %v %v %v", packet, receiver, service)
	return
}

// SignAndSendPacketAfterCounter returns a count of finished ConsensusNetworkMock.SignAndSendPacket invocations
func (mmSignAndSendPacket *ConsensusNetworkMock) SignAndSendPacketAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignAndSendPacket.afterSignAndSendPacketCounter)
}

// SignAndSendPacketBeforeCounter returns a count of ConsensusNetworkMock.SignAndSendPacket invocations
func (mmSignAndSendPacket *ConsensusNetworkMock) SignAndSendPacketBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignAndSendPacket.beforeSignAndSendPacketCounter)
}

// Calls returns a list of arguments used in each call to ConsensusNetworkMock.SignAndSendPacket.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSignAndSendPacket *mConsensusNetworkMockSignAndSendPacket) Calls() []*ConsensusNetworkMockSignAndSendPacketParams {
	mmSignAndSendPacket.mutex.RLock()

	argCopy := make([]*ConsensusNetworkMockSignAndSendPacketParams, len(mmSignAndSendPacket.callArgs))
	copy(argCopy, mmSignAndSendPacket.callArgs)

	mmSignAndSendPacket.mutex.RUnlock()

	return argCopy
}

// MinimockSignAndSendPacketDone returns true if the count of the SignAndSendPacket invocations corresponds
// the number of defined expectations
func (m *ConsensusNetworkMock) MinimockSignAndSendPacketDone() bool {
	for _, e := range m.SignAndSendPacketMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SignAndSendPacketMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSignAndSendPacketCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignAndSendPacket != nil && mm_atomic.LoadUint64(&m.afterSignAndSendPacketCounter) < 1 {
		return false
	}
	return true
}

// MinimockSignAndSendPacketInspect logs each unmet expectation
func (m *ConsensusNetworkMock) MinimockSignAndSendPacketInspect() {
	for _, e := range m.SignAndSendPacketMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConsensusNetworkMock.SignAndSendPacket with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SignAndSendPacketMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSignAndSendPacketCounter) < 1 {
		if m.SignAndSendPacketMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConsensusNetworkMock.SignAndSendPacket")
		} else {
			m.t.Errorf("Expected call to ConsensusNetworkMock.SignAndSendPacket with params: %#v", *m.SignAndSendPacketMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignAndSendPacket != nil && mm_atomic.LoadUint64(&m.afterSignAndSendPacketCounter) < 1 {
		m.t.Error("Expected call to ConsensusNetworkMock.SignAndSendPacket")
	}
}

type mConsensusNetworkMockStart struct {
	mock               *ConsensusNetworkMock
	defaultExpectation *ConsensusNetworkMockStartExpectation
	expectations       []*ConsensusNetworkMockStartExpectation

	callArgs []*ConsensusNetworkMockStartParams
	mutex    sync.RWMutex
}

// ConsensusNetworkMockStartExpectation specifies expectation struct of the ConsensusNetwork.Start
type ConsensusNetworkMockStartExpectation struct {
	mock    *ConsensusNetworkMock
	params  *ConsensusNetworkMockStartParams
	results *ConsensusNetworkMockStartResults
	Counter uint64
}

// ConsensusNetworkMockStartParams contains parameters of the ConsensusNetwork.Start
type ConsensusNetworkMockStartParams struct {
	ctx context.Context
}

// ConsensusNetworkMockStartResults contains results of the ConsensusNetwork.Start
type ConsensusNetworkMockStartResults struct {
	err error
}

// Expect sets up expected params for ConsensusNetwork.Start
func (mmStart *mConsensusNetworkMockStart) Expect(ctx context.Context) *mConsensusNetworkMockStart {
	if mmStart.mock.funcStart != nil {
		mmStart.mock.t.Fatalf("ConsensusNetworkMock.Start mock is already set by Set")
	}

	if mmStart.defaultExpectation == nil {
		mmStart.defaultExpectation = &ConsensusNetworkMockStartExpectation{}
	}

	mmStart.defaultExpectation.params = &ConsensusNetworkMockStartParams{ctx}
	for _, e := range mmStart.expectations {
		if minimock.Equal(e.params, mmStart.defaultExpectation.params) {
			mmStart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStart.defaultExpectation.params)
		}
	}

	return mmStart
}

// Inspect accepts an inspector function that has same arguments as the ConsensusNetwork.Start
func (mmStart *mConsensusNetworkMockStart) Inspect(f func(ctx context.Context)) *mConsensusNetworkMockStart {
	if mmStart.mock.inspectFuncStart != nil {
		mmStart.mock.t.Fatalf("Inspect function is already set for ConsensusNetworkMock.Start")
	}

	mmStart.mock.inspectFuncStart = f

	return mmStart
}

// Return sets up results that will be returned by ConsensusNetwork.Start
func (mmStart *mConsensusNetworkMockStart) Return(err error) *ConsensusNetworkMock {
	if mmStart.mock.funcStart != nil {
		mmStart.mock.t.Fatalf("ConsensusNetworkMock.Start mock is already set by Set")
	}

	if mmStart.defaultExpectation == nil {
		mmStart.defaultExpectation = &ConsensusNetworkMockStartExpectation{mock: mmStart.mock}
	}
	mmStart.defaultExpectation.results = &ConsensusNetworkMockStartResults{err}
	return mmStart.mock
}

//Set uses given function f to mock the ConsensusNetwork.Start method
func (mmStart *mConsensusNetworkMockStart) Set(f func(ctx context.Context) (err error)) *ConsensusNetworkMock {
	if mmStart.defaultExpectation != nil {
		mmStart.mock.t.Fatalf("Default expectation is already set for the ConsensusNetwork.Start method")
	}

	if len(mmStart.expectations) > 0 {
		mmStart.mock.t.Fatalf("Some expectations are already set for the ConsensusNetwork.Start method")
	}

	mmStart.mock.funcStart = f
	return mmStart.mock
}

// When sets expectation for the ConsensusNetwork.Start which will trigger the result defined by the following
// Then helper
func (mmStart *mConsensusNetworkMockStart) When(ctx context.Context) *ConsensusNetworkMockStartExpectation {
	if mmStart.mock.funcStart != nil {
		mmStart.mock.t.Fatalf("ConsensusNetworkMock.Start mock is already set by Set")
	}

	expectation := &ConsensusNetworkMockStartExpectation{
		mock:   mmStart.mock,
		params: &ConsensusNetworkMockStartParams{ctx},
	}
	mmStart.expectations = append(mmStart.expectations, expectation)
	return expectation
}

// Then sets up ConsensusNetwork.Start return parameters for the expectation previously defined by the When method
func (e *ConsensusNetworkMockStartExpectation) Then(err error) *ConsensusNetworkMock {
	e.results = &ConsensusNetworkMockStartResults{err}
	return e.mock
}

// Start implements network.ConsensusNetwork
func (mmStart *ConsensusNetworkMock) Start(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmStart.beforeStartCounter, 1)
	defer mm_atomic.AddUint64(&mmStart.afterStartCounter, 1)

	if mmStart.inspectFuncStart != nil {
		mmStart.inspectFuncStart(ctx)
	}

	params := &ConsensusNetworkMockStartParams{ctx}

	// Record call args
	mmStart.StartMock.mutex.Lock()
	mmStart.StartMock.callArgs = append(mmStart.StartMock.callArgs, params)
	mmStart.StartMock.mutex.Unlock()

	for _, e := range mmStart.StartMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmStart.StartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStart.StartMock.defaultExpectation.Counter, 1)
		want := mmStart.StartMock.defaultExpectation.params
		got := ConsensusNetworkMockStartParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmStart.t.Errorf("ConsensusNetworkMock.Start got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmStart.StartMock.defaultExpectation.results
		if results == nil {
			mmStart.t.Fatal("No results are set for the ConsensusNetworkMock.Start")
		}
		return (*results).err
	}
	if mmStart.funcStart != nil {
		return mmStart.funcStart(ctx)
	}
	mmStart.t.Fatalf("Unexpected call to ConsensusNetworkMock.Start. %v", ctx)
	return
}

// StartAfterCounter returns a count of finished ConsensusNetworkMock.Start invocations
func (mmStart *ConsensusNetworkMock) StartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStart.afterStartCounter)
}

// StartBeforeCounter returns a count of ConsensusNetworkMock.Start invocations
func (mmStart *ConsensusNetworkMock) StartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStart.beforeStartCounter)
}

// Calls returns a list of arguments used in each call to ConsensusNetworkMock.Start.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStart *mConsensusNetworkMockStart) Calls() []*ConsensusNetworkMockStartParams {
	mmStart.mutex.RLock()

	argCopy := make([]*ConsensusNetworkMockStartParams, len(mmStart.callArgs))
	copy(argCopy, mmStart.callArgs)

	mmStart.mutex.RUnlock()

	return argCopy
}

// MinimockStartDone returns true if the count of the Start invocations corresponds
// the number of defined expectations
func (m *ConsensusNetworkMock) MinimockStartDone() bool {
	for _, e := range m.StartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStart != nil && mm_atomic.LoadUint64(&m.afterStartCounter) < 1 {
		return false
	}
	return true
}

// MinimockStartInspect logs each unmet expectation
func (m *ConsensusNetworkMock) MinimockStartInspect() {
	for _, e := range m.StartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConsensusNetworkMock.Start with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStartCounter) < 1 {
		if m.StartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConsensusNetworkMock.Start")
		} else {
			m.t.Errorf("Expected call to ConsensusNetworkMock.Start with params: %#v", *m.StartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStart != nil && mm_atomic.LoadUint64(&m.afterStartCounter) < 1 {
		m.t.Error("Expected call to ConsensusNetworkMock.Start")
	}
}

type mConsensusNetworkMockStop struct {
	mock               *ConsensusNetworkMock
	defaultExpectation *ConsensusNetworkMockStopExpectation
	expectations       []*ConsensusNetworkMockStopExpectation

	callArgs []*ConsensusNetworkMockStopParams
	mutex    sync.RWMutex
}

// ConsensusNetworkMockStopExpectation specifies expectation struct of the ConsensusNetwork.Stop
type ConsensusNetworkMockStopExpectation struct {
	mock    *ConsensusNetworkMock
	params  *ConsensusNetworkMockStopParams
	results *ConsensusNetworkMockStopResults
	Counter uint64
}

// ConsensusNetworkMockStopParams contains parameters of the ConsensusNetwork.Stop
type ConsensusNetworkMockStopParams struct {
	ctx context.Context
}

// ConsensusNetworkMockStopResults contains results of the ConsensusNetwork.Stop
type ConsensusNetworkMockStopResults struct {
	err error
}

// Expect sets up expected params for ConsensusNetwork.Stop
func (mmStop *mConsensusNetworkMockStop) Expect(ctx context.Context) *mConsensusNetworkMockStop {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("ConsensusNetworkMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &ConsensusNetworkMockStopExpectation{}
	}

	mmStop.defaultExpectation.params = &ConsensusNetworkMockStopParams{ctx}
	for _, e := range mmStop.expectations {
		if minimock.Equal(e.params, mmStop.defaultExpectation.params) {
			mmStop.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStop.defaultExpectation.params)
		}
	}

	return mmStop
}

// Inspect accepts an inspector function that has same arguments as the ConsensusNetwork.Stop
func (mmStop *mConsensusNetworkMockStop) Inspect(f func(ctx context.Context)) *mConsensusNetworkMockStop {
	if mmStop.mock.inspectFuncStop != nil {
		mmStop.mock.t.Fatalf("Inspect function is already set for ConsensusNetworkMock.Stop")
	}

	mmStop.mock.inspectFuncStop = f

	return mmStop
}

// Return sets up results that will be returned by ConsensusNetwork.Stop
func (mmStop *mConsensusNetworkMockStop) Return(err error) *ConsensusNetworkMock {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("ConsensusNetworkMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &ConsensusNetworkMockStopExpectation{mock: mmStop.mock}
	}
	mmStop.defaultExpectation.results = &ConsensusNetworkMockStopResults{err}
	return mmStop.mock
}

//Set uses given function f to mock the ConsensusNetwork.Stop method
func (mmStop *mConsensusNetworkMockStop) Set(f func(ctx context.Context) (err error)) *ConsensusNetworkMock {
	if mmStop.defaultExpectation != nil {
		mmStop.mock.t.Fatalf("Default expectation is already set for the ConsensusNetwork.Stop method")
	}

	if len(mmStop.expectations) > 0 {
		mmStop.mock.t.Fatalf("Some expectations are already set for the ConsensusNetwork.Stop method")
	}

	mmStop.mock.funcStop = f
	return mmStop.mock
}

// When sets expectation for the ConsensusNetwork.Stop which will trigger the result defined by the following
// Then helper
func (mmStop *mConsensusNetworkMockStop) When(ctx context.Context) *ConsensusNetworkMockStopExpectation {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("ConsensusNetworkMock.Stop mock is already set by Set")
	}

	expectation := &ConsensusNetworkMockStopExpectation{
		mock:   mmStop.mock,
		params: &ConsensusNetworkMockStopParams{ctx},
	}
	mmStop.expectations = append(mmStop.expectations, expectation)
	return expectation
}

// Then sets up ConsensusNetwork.Stop return parameters for the expectation previously defined by the When method
func (e *ConsensusNetworkMockStopExpectation) Then(err error) *ConsensusNetworkMock {
	e.results = &ConsensusNetworkMockStopResults{err}
	return e.mock
}

// Stop implements network.ConsensusNetwork
func (mmStop *ConsensusNetworkMock) Stop(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmStop.beforeStopCounter, 1)
	defer mm_atomic.AddUint64(&mmStop.afterStopCounter, 1)

	if mmStop.inspectFuncStop != nil {
		mmStop.inspectFuncStop(ctx)
	}

	params := &ConsensusNetworkMockStopParams{ctx}

	// Record call args
	mmStop.StopMock.mutex.Lock()
	mmStop.StopMock.callArgs = append(mmStop.StopMock.callArgs, params)
	mmStop.StopMock.mutex.Unlock()

	for _, e := range mmStop.StopMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmStop.StopMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStop.StopMock.defaultExpectation.Counter, 1)
		want := mmStop.StopMock.defaultExpectation.params
		got := ConsensusNetworkMockStopParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmStop.t.Errorf("ConsensusNetworkMock.Stop got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmStop.StopMock.defaultExpectation.results
		if results == nil {
			mmStop.t.Fatal("No results are set for the ConsensusNetworkMock.Stop")
		}
		return (*results).err
	}
	if mmStop.funcStop != nil {
		return mmStop.funcStop(ctx)
	}
	mmStop.t.Fatalf("Unexpected call to ConsensusNetworkMock.Stop. %v", ctx)
	return
}

// StopAfterCounter returns a count of finished ConsensusNetworkMock.Stop invocations
func (mmStop *ConsensusNetworkMock) StopAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStop.afterStopCounter)
}

// StopBeforeCounter returns a count of ConsensusNetworkMock.Stop invocations
func (mmStop *ConsensusNetworkMock) StopBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStop.beforeStopCounter)
}

// Calls returns a list of arguments used in each call to ConsensusNetworkMock.Stop.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStop *mConsensusNetworkMockStop) Calls() []*ConsensusNetworkMockStopParams {
	mmStop.mutex.RLock()

	argCopy := make([]*ConsensusNetworkMockStopParams, len(mmStop.callArgs))
	copy(argCopy, mmStop.callArgs)

	mmStop.mutex.RUnlock()

	return argCopy
}

// MinimockStopDone returns true if the count of the Stop invocations corresponds
// the number of defined expectations
func (m *ConsensusNetworkMock) MinimockStopDone() bool {
	for _, e := range m.StopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStop != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		return false
	}
	return true
}

// MinimockStopInspect logs each unmet expectation
func (m *ConsensusNetworkMock) MinimockStopInspect() {
	for _, e := range m.StopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConsensusNetworkMock.Stop with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		if m.StopMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConsensusNetworkMock.Stop")
		} else {
			m.t.Errorf("Expected call to ConsensusNetworkMock.Stop with params: %#v", *m.StopMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStop != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		m.t.Error("Expected call to ConsensusNetworkMock.Stop")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ConsensusNetworkMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockInitInspect()

		m.MinimockPublicAddressInspect()

		m.MinimockRegisterPacketHandlerInspect()

		m.MinimockSignAndSendPacketInspect()

		m.MinimockStartInspect()

		m.MinimockStopInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ConsensusNetworkMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ConsensusNetworkMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockInitDone() &&
		m.MinimockPublicAddressDone() &&
		m.MinimockRegisterPacketHandlerDone() &&
		m.MinimockSignAndSendPacketDone() &&
		m.MinimockStartDone() &&
		m.MinimockStopDone()
}
