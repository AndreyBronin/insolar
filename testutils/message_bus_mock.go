package testutils

// Code generated by http://github.com/gojuno/minimock (3.0.0). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_insolar "github.com/insolar/insolar/insolar"
)

// MessageBusMock implements insolar.MessageBus
type MessageBusMock struct {
	t minimock.Tester

	funcMustRegister          func(p mm_insolar.MessageType, handler mm_insolar.MessageHandler)
	inspectFuncMustRegister   func(p mm_insolar.MessageType, handler mm_insolar.MessageHandler)
	afterMustRegisterCounter  uint64
	beforeMustRegisterCounter uint64
	MustRegisterMock          mMessageBusMockMustRegister

	funcOnPulse          func(ctx context.Context, p1 mm_insolar.Pulse) (err error)
	inspectFuncOnPulse   func(ctx context.Context, p1 mm_insolar.Pulse)
	afterOnPulseCounter  uint64
	beforeOnPulseCounter uint64
	OnPulseMock          mMessageBusMockOnPulse

	funcRegister          func(p mm_insolar.MessageType, handler mm_insolar.MessageHandler) (err error)
	inspectFuncRegister   func(p mm_insolar.MessageType, handler mm_insolar.MessageHandler)
	afterRegisterCounter  uint64
	beforeRegisterCounter uint64
	RegisterMock          mMessageBusMockRegister

	funcSend          func(ctx context.Context, m1 mm_insolar.Message, mp1 *mm_insolar.MessageSendOptions) (r1 mm_insolar.Reply, err error)
	inspectFuncSend   func(ctx context.Context, m1 mm_insolar.Message, mp1 *mm_insolar.MessageSendOptions)
	afterSendCounter  uint64
	beforeSendCounter uint64
	SendMock          mMessageBusMockSend
}

// NewMessageBusMock returns a mock for insolar.MessageBus
func NewMessageBusMock(t minimock.Tester) *MessageBusMock {
	m := &MessageBusMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.MustRegisterMock = mMessageBusMockMustRegister{mock: m}
	m.MustRegisterMock.callArgs = []*MessageBusMockMustRegisterParams{}

	m.OnPulseMock = mMessageBusMockOnPulse{mock: m}
	m.OnPulseMock.callArgs = []*MessageBusMockOnPulseParams{}

	m.RegisterMock = mMessageBusMockRegister{mock: m}
	m.RegisterMock.callArgs = []*MessageBusMockRegisterParams{}

	m.SendMock = mMessageBusMockSend{mock: m}
	m.SendMock.callArgs = []*MessageBusMockSendParams{}

	return m
}

type mMessageBusMockMustRegister struct {
	mock               *MessageBusMock
	defaultExpectation *MessageBusMockMustRegisterExpectation
	expectations       []*MessageBusMockMustRegisterExpectation

	callArgs []*MessageBusMockMustRegisterParams
	mutex    sync.RWMutex
}

// MessageBusMockMustRegisterExpectation specifies expectation struct of the MessageBus.MustRegister
type MessageBusMockMustRegisterExpectation struct {
	mock   *MessageBusMock
	params *MessageBusMockMustRegisterParams

	Counter uint64
}

// MessageBusMockMustRegisterParams contains parameters of the MessageBus.MustRegister
type MessageBusMockMustRegisterParams struct {
	p       mm_insolar.MessageType
	handler mm_insolar.MessageHandler
}

// Expect sets up expected params for MessageBus.MustRegister
func (mmMustRegister *mMessageBusMockMustRegister) Expect(p mm_insolar.MessageType, handler mm_insolar.MessageHandler) *mMessageBusMockMustRegister {
	if mmMustRegister.mock.funcMustRegister != nil {
		mmMustRegister.mock.t.Fatalf("MessageBusMock.MustRegister mock is already set by Set")
	}

	if mmMustRegister.defaultExpectation == nil {
		mmMustRegister.defaultExpectation = &MessageBusMockMustRegisterExpectation{}
	}

	mmMustRegister.defaultExpectation.params = &MessageBusMockMustRegisterParams{p, handler}
	for _, e := range mmMustRegister.expectations {
		if minimock.Equal(e.params, mmMustRegister.defaultExpectation.params) {
			mmMustRegister.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMustRegister.defaultExpectation.params)
		}
	}

	return mmMustRegister
}

// Inspect accepts an inspector function that has same arguments as the MessageBus.MustRegister
func (mmMustRegister *mMessageBusMockMustRegister) Inspect(f func(p mm_insolar.MessageType, handler mm_insolar.MessageHandler)) *mMessageBusMockMustRegister {
	if mmMustRegister.mock.inspectFuncMustRegister != nil {
		mmMustRegister.mock.t.Fatalf("Inspect function is already set for MessageBusMock.MustRegister")
	}

	mmMustRegister.mock.inspectFuncMustRegister = f

	return mmMustRegister
}

// Return sets up results that will be returned by MessageBus.MustRegister
func (mmMustRegister *mMessageBusMockMustRegister) Return() *MessageBusMock {
	if mmMustRegister.mock.funcMustRegister != nil {
		mmMustRegister.mock.t.Fatalf("MessageBusMock.MustRegister mock is already set by Set")
	}

	if mmMustRegister.defaultExpectation == nil {
		mmMustRegister.defaultExpectation = &MessageBusMockMustRegisterExpectation{mock: mmMustRegister.mock}
	}

	return mmMustRegister.mock
}

//Set uses given function f to mock the MessageBus.MustRegister method
func (mmMustRegister *mMessageBusMockMustRegister) Set(f func(p mm_insolar.MessageType, handler mm_insolar.MessageHandler)) *MessageBusMock {
	if mmMustRegister.defaultExpectation != nil {
		mmMustRegister.mock.t.Fatalf("Default expectation is already set for the MessageBus.MustRegister method")
	}

	if len(mmMustRegister.expectations) > 0 {
		mmMustRegister.mock.t.Fatalf("Some expectations are already set for the MessageBus.MustRegister method")
	}

	mmMustRegister.mock.funcMustRegister = f
	return mmMustRegister.mock
}

// MustRegister implements insolar.MessageBus
func (mmMustRegister *MessageBusMock) MustRegister(p mm_insolar.MessageType, handler mm_insolar.MessageHandler) {
	mm_atomic.AddUint64(&mmMustRegister.beforeMustRegisterCounter, 1)
	defer mm_atomic.AddUint64(&mmMustRegister.afterMustRegisterCounter, 1)

	if mmMustRegister.inspectFuncMustRegister != nil {
		mmMustRegister.inspectFuncMustRegister(p, handler)
	}

	params := &MessageBusMockMustRegisterParams{p, handler}

	// Record call args
	mmMustRegister.MustRegisterMock.mutex.Lock()
	mmMustRegister.MustRegisterMock.callArgs = append(mmMustRegister.MustRegisterMock.callArgs, params)
	mmMustRegister.MustRegisterMock.mutex.Unlock()

	for _, e := range mmMustRegister.MustRegisterMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmMustRegister.MustRegisterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMustRegister.MustRegisterMock.defaultExpectation.Counter, 1)
		want := mmMustRegister.MustRegisterMock.defaultExpectation.params
		got := MessageBusMockMustRegisterParams{p, handler}
		if want != nil && !minimock.Equal(*want, got) {
			mmMustRegister.t.Errorf("MessageBusMock.MustRegister got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmMustRegister.funcMustRegister != nil {
		mmMustRegister.funcMustRegister(p, handler)
		return
	}
	mmMustRegister.t.Fatalf("Unexpected call to MessageBusMock.MustRegister. %v %v", p, handler)

}

// MustRegisterAfterCounter returns a count of finished MessageBusMock.MustRegister invocations
func (mmMustRegister *MessageBusMock) MustRegisterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMustRegister.afterMustRegisterCounter)
}

// MustRegisterBeforeCounter returns a count of MessageBusMock.MustRegister invocations
func (mmMustRegister *MessageBusMock) MustRegisterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMustRegister.beforeMustRegisterCounter)
}

// Calls returns a list of arguments used in each call to MessageBusMock.MustRegister.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMustRegister *mMessageBusMockMustRegister) Calls() []*MessageBusMockMustRegisterParams {
	mmMustRegister.mutex.RLock()

	argCopy := make([]*MessageBusMockMustRegisterParams, len(mmMustRegister.callArgs))
	copy(argCopy, mmMustRegister.callArgs)

	mmMustRegister.mutex.RUnlock()

	return argCopy
}

// MinimockMustRegisterDone returns true if the count of the MustRegister invocations corresponds
// the number of defined expectations
func (m *MessageBusMock) MinimockMustRegisterDone() bool {
	for _, e := range m.MustRegisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MustRegisterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMustRegisterCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMustRegister != nil && mm_atomic.LoadUint64(&m.afterMustRegisterCounter) < 1 {
		return false
	}
	return true
}

// MinimockMustRegisterInspect logs each unmet expectation
func (m *MessageBusMock) MinimockMustRegisterInspect() {
	for _, e := range m.MustRegisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MessageBusMock.MustRegister with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MustRegisterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMustRegisterCounter) < 1 {
		if m.MustRegisterMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MessageBusMock.MustRegister")
		} else {
			m.t.Errorf("Expected call to MessageBusMock.MustRegister with params: %#v", *m.MustRegisterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMustRegister != nil && mm_atomic.LoadUint64(&m.afterMustRegisterCounter) < 1 {
		m.t.Error("Expected call to MessageBusMock.MustRegister")
	}
}

type mMessageBusMockOnPulse struct {
	mock               *MessageBusMock
	defaultExpectation *MessageBusMockOnPulseExpectation
	expectations       []*MessageBusMockOnPulseExpectation

	callArgs []*MessageBusMockOnPulseParams
	mutex    sync.RWMutex
}

// MessageBusMockOnPulseExpectation specifies expectation struct of the MessageBus.OnPulse
type MessageBusMockOnPulseExpectation struct {
	mock    *MessageBusMock
	params  *MessageBusMockOnPulseParams
	results *MessageBusMockOnPulseResults
	Counter uint64
}

// MessageBusMockOnPulseParams contains parameters of the MessageBus.OnPulse
type MessageBusMockOnPulseParams struct {
	ctx context.Context
	p1  mm_insolar.Pulse
}

// MessageBusMockOnPulseResults contains results of the MessageBus.OnPulse
type MessageBusMockOnPulseResults struct {
	err error
}

// Expect sets up expected params for MessageBus.OnPulse
func (mmOnPulse *mMessageBusMockOnPulse) Expect(ctx context.Context, p1 mm_insolar.Pulse) *mMessageBusMockOnPulse {
	if mmOnPulse.mock.funcOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("MessageBusMock.OnPulse mock is already set by Set")
	}

	if mmOnPulse.defaultExpectation == nil {
		mmOnPulse.defaultExpectation = &MessageBusMockOnPulseExpectation{}
	}

	mmOnPulse.defaultExpectation.params = &MessageBusMockOnPulseParams{ctx, p1}
	for _, e := range mmOnPulse.expectations {
		if minimock.Equal(e.params, mmOnPulse.defaultExpectation.params) {
			mmOnPulse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOnPulse.defaultExpectation.params)
		}
	}

	return mmOnPulse
}

// Inspect accepts an inspector function that has same arguments as the MessageBus.OnPulse
func (mmOnPulse *mMessageBusMockOnPulse) Inspect(f func(ctx context.Context, p1 mm_insolar.Pulse)) *mMessageBusMockOnPulse {
	if mmOnPulse.mock.inspectFuncOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("Inspect function is already set for MessageBusMock.OnPulse")
	}

	mmOnPulse.mock.inspectFuncOnPulse = f

	return mmOnPulse
}

// Return sets up results that will be returned by MessageBus.OnPulse
func (mmOnPulse *mMessageBusMockOnPulse) Return(err error) *MessageBusMock {
	if mmOnPulse.mock.funcOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("MessageBusMock.OnPulse mock is already set by Set")
	}

	if mmOnPulse.defaultExpectation == nil {
		mmOnPulse.defaultExpectation = &MessageBusMockOnPulseExpectation{mock: mmOnPulse.mock}
	}
	mmOnPulse.defaultExpectation.results = &MessageBusMockOnPulseResults{err}
	return mmOnPulse.mock
}

//Set uses given function f to mock the MessageBus.OnPulse method
func (mmOnPulse *mMessageBusMockOnPulse) Set(f func(ctx context.Context, p1 mm_insolar.Pulse) (err error)) *MessageBusMock {
	if mmOnPulse.defaultExpectation != nil {
		mmOnPulse.mock.t.Fatalf("Default expectation is already set for the MessageBus.OnPulse method")
	}

	if len(mmOnPulse.expectations) > 0 {
		mmOnPulse.mock.t.Fatalf("Some expectations are already set for the MessageBus.OnPulse method")
	}

	mmOnPulse.mock.funcOnPulse = f
	return mmOnPulse.mock
}

// When sets expectation for the MessageBus.OnPulse which will trigger the result defined by the following
// Then helper
func (mmOnPulse *mMessageBusMockOnPulse) When(ctx context.Context, p1 mm_insolar.Pulse) *MessageBusMockOnPulseExpectation {
	if mmOnPulse.mock.funcOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("MessageBusMock.OnPulse mock is already set by Set")
	}

	expectation := &MessageBusMockOnPulseExpectation{
		mock:   mmOnPulse.mock,
		params: &MessageBusMockOnPulseParams{ctx, p1},
	}
	mmOnPulse.expectations = append(mmOnPulse.expectations, expectation)
	return expectation
}

// Then sets up MessageBus.OnPulse return parameters for the expectation previously defined by the When method
func (e *MessageBusMockOnPulseExpectation) Then(err error) *MessageBusMock {
	e.results = &MessageBusMockOnPulseResults{err}
	return e.mock
}

// OnPulse implements insolar.MessageBus
func (mmOnPulse *MessageBusMock) OnPulse(ctx context.Context, p1 mm_insolar.Pulse) (err error) {
	mm_atomic.AddUint64(&mmOnPulse.beforeOnPulseCounter, 1)
	defer mm_atomic.AddUint64(&mmOnPulse.afterOnPulseCounter, 1)

	if mmOnPulse.inspectFuncOnPulse != nil {
		mmOnPulse.inspectFuncOnPulse(ctx, p1)
	}

	params := &MessageBusMockOnPulseParams{ctx, p1}

	// Record call args
	mmOnPulse.OnPulseMock.mutex.Lock()
	mmOnPulse.OnPulseMock.callArgs = append(mmOnPulse.OnPulseMock.callArgs, params)
	mmOnPulse.OnPulseMock.mutex.Unlock()

	for _, e := range mmOnPulse.OnPulseMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmOnPulse.OnPulseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOnPulse.OnPulseMock.defaultExpectation.Counter, 1)
		want := mmOnPulse.OnPulseMock.defaultExpectation.params
		got := MessageBusMockOnPulseParams{ctx, p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmOnPulse.t.Errorf("MessageBusMock.OnPulse got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmOnPulse.OnPulseMock.defaultExpectation.results
		if results == nil {
			mmOnPulse.t.Fatal("No results are set for the MessageBusMock.OnPulse")
		}
		return (*results).err
	}
	if mmOnPulse.funcOnPulse != nil {
		return mmOnPulse.funcOnPulse(ctx, p1)
	}
	mmOnPulse.t.Fatalf("Unexpected call to MessageBusMock.OnPulse. %v %v", ctx, p1)
	return
}

// OnPulseAfterCounter returns a count of finished MessageBusMock.OnPulse invocations
func (mmOnPulse *MessageBusMock) OnPulseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOnPulse.afterOnPulseCounter)
}

// OnPulseBeforeCounter returns a count of MessageBusMock.OnPulse invocations
func (mmOnPulse *MessageBusMock) OnPulseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOnPulse.beforeOnPulseCounter)
}

// Calls returns a list of arguments used in each call to MessageBusMock.OnPulse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOnPulse *mMessageBusMockOnPulse) Calls() []*MessageBusMockOnPulseParams {
	mmOnPulse.mutex.RLock()

	argCopy := make([]*MessageBusMockOnPulseParams, len(mmOnPulse.callArgs))
	copy(argCopy, mmOnPulse.callArgs)

	mmOnPulse.mutex.RUnlock()

	return argCopy
}

// MinimockOnPulseDone returns true if the count of the OnPulse invocations corresponds
// the number of defined expectations
func (m *MessageBusMock) MinimockOnPulseDone() bool {
	for _, e := range m.OnPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OnPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOnPulse != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		return false
	}
	return true
}

// MinimockOnPulseInspect logs each unmet expectation
func (m *MessageBusMock) MinimockOnPulseInspect() {
	for _, e := range m.OnPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MessageBusMock.OnPulse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OnPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		if m.OnPulseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MessageBusMock.OnPulse")
		} else {
			m.t.Errorf("Expected call to MessageBusMock.OnPulse with params: %#v", *m.OnPulseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOnPulse != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		m.t.Error("Expected call to MessageBusMock.OnPulse")
	}
}

type mMessageBusMockRegister struct {
	mock               *MessageBusMock
	defaultExpectation *MessageBusMockRegisterExpectation
	expectations       []*MessageBusMockRegisterExpectation

	callArgs []*MessageBusMockRegisterParams
	mutex    sync.RWMutex
}

// MessageBusMockRegisterExpectation specifies expectation struct of the MessageBus.Register
type MessageBusMockRegisterExpectation struct {
	mock    *MessageBusMock
	params  *MessageBusMockRegisterParams
	results *MessageBusMockRegisterResults
	Counter uint64
}

// MessageBusMockRegisterParams contains parameters of the MessageBus.Register
type MessageBusMockRegisterParams struct {
	p       mm_insolar.MessageType
	handler mm_insolar.MessageHandler
}

// MessageBusMockRegisterResults contains results of the MessageBus.Register
type MessageBusMockRegisterResults struct {
	err error
}

// Expect sets up expected params for MessageBus.Register
func (mmRegister *mMessageBusMockRegister) Expect(p mm_insolar.MessageType, handler mm_insolar.MessageHandler) *mMessageBusMockRegister {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("MessageBusMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &MessageBusMockRegisterExpectation{}
	}

	mmRegister.defaultExpectation.params = &MessageBusMockRegisterParams{p, handler}
	for _, e := range mmRegister.expectations {
		if minimock.Equal(e.params, mmRegister.defaultExpectation.params) {
			mmRegister.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegister.defaultExpectation.params)
		}
	}

	return mmRegister
}

// Inspect accepts an inspector function that has same arguments as the MessageBus.Register
func (mmRegister *mMessageBusMockRegister) Inspect(f func(p mm_insolar.MessageType, handler mm_insolar.MessageHandler)) *mMessageBusMockRegister {
	if mmRegister.mock.inspectFuncRegister != nil {
		mmRegister.mock.t.Fatalf("Inspect function is already set for MessageBusMock.Register")
	}

	mmRegister.mock.inspectFuncRegister = f

	return mmRegister
}

// Return sets up results that will be returned by MessageBus.Register
func (mmRegister *mMessageBusMockRegister) Return(err error) *MessageBusMock {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("MessageBusMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &MessageBusMockRegisterExpectation{mock: mmRegister.mock}
	}
	mmRegister.defaultExpectation.results = &MessageBusMockRegisterResults{err}
	return mmRegister.mock
}

//Set uses given function f to mock the MessageBus.Register method
func (mmRegister *mMessageBusMockRegister) Set(f func(p mm_insolar.MessageType, handler mm_insolar.MessageHandler) (err error)) *MessageBusMock {
	if mmRegister.defaultExpectation != nil {
		mmRegister.mock.t.Fatalf("Default expectation is already set for the MessageBus.Register method")
	}

	if len(mmRegister.expectations) > 0 {
		mmRegister.mock.t.Fatalf("Some expectations are already set for the MessageBus.Register method")
	}

	mmRegister.mock.funcRegister = f
	return mmRegister.mock
}

// When sets expectation for the MessageBus.Register which will trigger the result defined by the following
// Then helper
func (mmRegister *mMessageBusMockRegister) When(p mm_insolar.MessageType, handler mm_insolar.MessageHandler) *MessageBusMockRegisterExpectation {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("MessageBusMock.Register mock is already set by Set")
	}

	expectation := &MessageBusMockRegisterExpectation{
		mock:   mmRegister.mock,
		params: &MessageBusMockRegisterParams{p, handler},
	}
	mmRegister.expectations = append(mmRegister.expectations, expectation)
	return expectation
}

// Then sets up MessageBus.Register return parameters for the expectation previously defined by the When method
func (e *MessageBusMockRegisterExpectation) Then(err error) *MessageBusMock {
	e.results = &MessageBusMockRegisterResults{err}
	return e.mock
}

// Register implements insolar.MessageBus
func (mmRegister *MessageBusMock) Register(p mm_insolar.MessageType, handler mm_insolar.MessageHandler) (err error) {
	mm_atomic.AddUint64(&mmRegister.beforeRegisterCounter, 1)
	defer mm_atomic.AddUint64(&mmRegister.afterRegisterCounter, 1)

	if mmRegister.inspectFuncRegister != nil {
		mmRegister.inspectFuncRegister(p, handler)
	}

	params := &MessageBusMockRegisterParams{p, handler}

	// Record call args
	mmRegister.RegisterMock.mutex.Lock()
	mmRegister.RegisterMock.callArgs = append(mmRegister.RegisterMock.callArgs, params)
	mmRegister.RegisterMock.mutex.Unlock()

	for _, e := range mmRegister.RegisterMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRegister.RegisterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegister.RegisterMock.defaultExpectation.Counter, 1)
		want := mmRegister.RegisterMock.defaultExpectation.params
		got := MessageBusMockRegisterParams{p, handler}
		if want != nil && !minimock.Equal(*want, got) {
			mmRegister.t.Errorf("MessageBusMock.Register got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRegister.RegisterMock.defaultExpectation.results
		if results == nil {
			mmRegister.t.Fatal("No results are set for the MessageBusMock.Register")
		}
		return (*results).err
	}
	if mmRegister.funcRegister != nil {
		return mmRegister.funcRegister(p, handler)
	}
	mmRegister.t.Fatalf("Unexpected call to MessageBusMock.Register. %v %v", p, handler)
	return
}

// RegisterAfterCounter returns a count of finished MessageBusMock.Register invocations
func (mmRegister *MessageBusMock) RegisterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegister.afterRegisterCounter)
}

// RegisterBeforeCounter returns a count of MessageBusMock.Register invocations
func (mmRegister *MessageBusMock) RegisterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegister.beforeRegisterCounter)
}

// Calls returns a list of arguments used in each call to MessageBusMock.Register.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegister *mMessageBusMockRegister) Calls() []*MessageBusMockRegisterParams {
	mmRegister.mutex.RLock()

	argCopy := make([]*MessageBusMockRegisterParams, len(mmRegister.callArgs))
	copy(argCopy, mmRegister.callArgs)

	mmRegister.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterDone returns true if the count of the Register invocations corresponds
// the number of defined expectations
func (m *MessageBusMock) MinimockRegisterDone() bool {
	for _, e := range m.RegisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegister != nil && mm_atomic.LoadUint64(&m.afterRegisterCounter) < 1 {
		return false
	}
	return true
}

// MinimockRegisterInspect logs each unmet expectation
func (m *MessageBusMock) MinimockRegisterInspect() {
	for _, e := range m.RegisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MessageBusMock.Register with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterCounter) < 1 {
		if m.RegisterMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MessageBusMock.Register")
		} else {
			m.t.Errorf("Expected call to MessageBusMock.Register with params: %#v", *m.RegisterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegister != nil && mm_atomic.LoadUint64(&m.afterRegisterCounter) < 1 {
		m.t.Error("Expected call to MessageBusMock.Register")
	}
}

type mMessageBusMockSend struct {
	mock               *MessageBusMock
	defaultExpectation *MessageBusMockSendExpectation
	expectations       []*MessageBusMockSendExpectation

	callArgs []*MessageBusMockSendParams
	mutex    sync.RWMutex
}

// MessageBusMockSendExpectation specifies expectation struct of the MessageBus.Send
type MessageBusMockSendExpectation struct {
	mock    *MessageBusMock
	params  *MessageBusMockSendParams
	results *MessageBusMockSendResults
	Counter uint64
}

// MessageBusMockSendParams contains parameters of the MessageBus.Send
type MessageBusMockSendParams struct {
	ctx context.Context
	m1  mm_insolar.Message
	mp1 *mm_insolar.MessageSendOptions
}

// MessageBusMockSendResults contains results of the MessageBus.Send
type MessageBusMockSendResults struct {
	r1  mm_insolar.Reply
	err error
}

// Expect sets up expected params for MessageBus.Send
func (mmSend *mMessageBusMockSend) Expect(ctx context.Context, m1 mm_insolar.Message, mp1 *mm_insolar.MessageSendOptions) *mMessageBusMockSend {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("MessageBusMock.Send mock is already set by Set")
	}

	if mmSend.defaultExpectation == nil {
		mmSend.defaultExpectation = &MessageBusMockSendExpectation{}
	}

	mmSend.defaultExpectation.params = &MessageBusMockSendParams{ctx, m1, mp1}
	for _, e := range mmSend.expectations {
		if minimock.Equal(e.params, mmSend.defaultExpectation.params) {
			mmSend.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSend.defaultExpectation.params)
		}
	}

	return mmSend
}

// Inspect accepts an inspector function that has same arguments as the MessageBus.Send
func (mmSend *mMessageBusMockSend) Inspect(f func(ctx context.Context, m1 mm_insolar.Message, mp1 *mm_insolar.MessageSendOptions)) *mMessageBusMockSend {
	if mmSend.mock.inspectFuncSend != nil {
		mmSend.mock.t.Fatalf("Inspect function is already set for MessageBusMock.Send")
	}

	mmSend.mock.inspectFuncSend = f

	return mmSend
}

// Return sets up results that will be returned by MessageBus.Send
func (mmSend *mMessageBusMockSend) Return(r1 mm_insolar.Reply, err error) *MessageBusMock {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("MessageBusMock.Send mock is already set by Set")
	}

	if mmSend.defaultExpectation == nil {
		mmSend.defaultExpectation = &MessageBusMockSendExpectation{mock: mmSend.mock}
	}
	mmSend.defaultExpectation.results = &MessageBusMockSendResults{r1, err}
	return mmSend.mock
}

//Set uses given function f to mock the MessageBus.Send method
func (mmSend *mMessageBusMockSend) Set(f func(ctx context.Context, m1 mm_insolar.Message, mp1 *mm_insolar.MessageSendOptions) (r1 mm_insolar.Reply, err error)) *MessageBusMock {
	if mmSend.defaultExpectation != nil {
		mmSend.mock.t.Fatalf("Default expectation is already set for the MessageBus.Send method")
	}

	if len(mmSend.expectations) > 0 {
		mmSend.mock.t.Fatalf("Some expectations are already set for the MessageBus.Send method")
	}

	mmSend.mock.funcSend = f
	return mmSend.mock
}

// When sets expectation for the MessageBus.Send which will trigger the result defined by the following
// Then helper
func (mmSend *mMessageBusMockSend) When(ctx context.Context, m1 mm_insolar.Message, mp1 *mm_insolar.MessageSendOptions) *MessageBusMockSendExpectation {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("MessageBusMock.Send mock is already set by Set")
	}

	expectation := &MessageBusMockSendExpectation{
		mock:   mmSend.mock,
		params: &MessageBusMockSendParams{ctx, m1, mp1},
	}
	mmSend.expectations = append(mmSend.expectations, expectation)
	return expectation
}

// Then sets up MessageBus.Send return parameters for the expectation previously defined by the When method
func (e *MessageBusMockSendExpectation) Then(r1 mm_insolar.Reply, err error) *MessageBusMock {
	e.results = &MessageBusMockSendResults{r1, err}
	return e.mock
}

// Send implements insolar.MessageBus
func (mmSend *MessageBusMock) Send(ctx context.Context, m1 mm_insolar.Message, mp1 *mm_insolar.MessageSendOptions) (r1 mm_insolar.Reply, err error) {
	mm_atomic.AddUint64(&mmSend.beforeSendCounter, 1)
	defer mm_atomic.AddUint64(&mmSend.afterSendCounter, 1)

	if mmSend.inspectFuncSend != nil {
		mmSend.inspectFuncSend(ctx, m1, mp1)
	}

	params := &MessageBusMockSendParams{ctx, m1, mp1}

	// Record call args
	mmSend.SendMock.mutex.Lock()
	mmSend.SendMock.callArgs = append(mmSend.SendMock.callArgs, params)
	mmSend.SendMock.mutex.Unlock()

	for _, e := range mmSend.SendMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmSend.SendMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSend.SendMock.defaultExpectation.Counter, 1)
		want := mmSend.SendMock.defaultExpectation.params
		got := MessageBusMockSendParams{ctx, m1, mp1}
		if want != nil && !minimock.Equal(*want, got) {
			mmSend.t.Errorf("MessageBusMock.Send got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmSend.SendMock.defaultExpectation.results
		if results == nil {
			mmSend.t.Fatal("No results are set for the MessageBusMock.Send")
		}
		return (*results).r1, (*results).err
	}
	if mmSend.funcSend != nil {
		return mmSend.funcSend(ctx, m1, mp1)
	}
	mmSend.t.Fatalf("Unexpected call to MessageBusMock.Send. %v %v %v", ctx, m1, mp1)
	return
}

// SendAfterCounter returns a count of finished MessageBusMock.Send invocations
func (mmSend *MessageBusMock) SendAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSend.afterSendCounter)
}

// SendBeforeCounter returns a count of MessageBusMock.Send invocations
func (mmSend *MessageBusMock) SendBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSend.beforeSendCounter)
}

// Calls returns a list of arguments used in each call to MessageBusMock.Send.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSend *mMessageBusMockSend) Calls() []*MessageBusMockSendParams {
	mmSend.mutex.RLock()

	argCopy := make([]*MessageBusMockSendParams, len(mmSend.callArgs))
	copy(argCopy, mmSend.callArgs)

	mmSend.mutex.RUnlock()

	return argCopy
}

// MinimockSendDone returns true if the count of the Send invocations corresponds
// the number of defined expectations
func (m *MessageBusMock) MinimockSendDone() bool {
	for _, e := range m.SendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSend != nil && mm_atomic.LoadUint64(&m.afterSendCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendInspect logs each unmet expectation
func (m *MessageBusMock) MinimockSendInspect() {
	for _, e := range m.SendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MessageBusMock.Send with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendCounter) < 1 {
		if m.SendMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MessageBusMock.Send")
		} else {
			m.t.Errorf("Expected call to MessageBusMock.Send with params: %#v", *m.SendMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSend != nil && mm_atomic.LoadUint64(&m.afterSendCounter) < 1 {
		m.t.Error("Expected call to MessageBusMock.Send")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MessageBusMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockMustRegisterInspect()

		m.MinimockOnPulseInspect()

		m.MinimockRegisterInspect()

		m.MinimockSendInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MessageBusMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MessageBusMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockMustRegisterDone() &&
		m.MinimockOnPulseDone() &&
		m.MinimockRegisterDone() &&
		m.MinimockSendDone()
}
