package testutils

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	mm_insolar "github.com/insolar/insolar/insolar"
)

// NetworkMock implements insolar.Network
type NetworkMock struct {
	t minimock.Tester

	funcGetCert          func(ctx context.Context, rp1 *mm_insolar.Reference) (c2 mm_insolar.Certificate, err error)
	inspectFuncGetCert   func(ctx context.Context, rp1 *mm_insolar.Reference)
	afterGetCertCounter  uint64
	beforeGetCertCounter uint64
	GetCertMock          mNetworkMockGetCert

	funcLeave          func(ctx context.Context, ETA mm_insolar.PulseNumber)
	inspectFuncLeave   func(ctx context.Context, ETA mm_insolar.PulseNumber)
	afterLeaveCounter  uint64
	beforeLeaveCounter uint64
	LeaveMock          mNetworkMockLeave

	funcRemoteProcedureRegister          func(name string, method mm_insolar.RemoteProcedure)
	inspectFuncRemoteProcedureRegister   func(name string, method mm_insolar.RemoteProcedure)
	afterRemoteProcedureRegisterCounter  uint64
	beforeRemoteProcedureRegisterCounter uint64
	RemoteProcedureRegisterMock          mNetworkMockRemoteProcedureRegister
}

// NewNetworkMock returns a mock for insolar.Network
func NewNetworkMock(t minimock.Tester) *NetworkMock {
	m := &NetworkMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetCertMock = mNetworkMockGetCert{mock: m}
	m.GetCertMock.callArgs = []*NetworkMockGetCertParams{}

	m.LeaveMock = mNetworkMockLeave{mock: m}
	m.LeaveMock.callArgs = []*NetworkMockLeaveParams{}

	m.RemoteProcedureRegisterMock = mNetworkMockRemoteProcedureRegister{mock: m}
	m.RemoteProcedureRegisterMock.callArgs = []*NetworkMockRemoteProcedureRegisterParams{}

	return m
}

type mNetworkMockGetCert struct {
	mock               *NetworkMock
	defaultExpectation *NetworkMockGetCertExpectation
	expectations       []*NetworkMockGetCertExpectation

	callArgs []*NetworkMockGetCertParams
	mutex    sync.RWMutex
}

// NetworkMockGetCertExpectation specifies expectation struct of the Network.GetCert
type NetworkMockGetCertExpectation struct {
	mock    *NetworkMock
	params  *NetworkMockGetCertParams
	results *NetworkMockGetCertResults
	Counter uint64
}

// NetworkMockGetCertParams contains parameters of the Network.GetCert
type NetworkMockGetCertParams struct {
	ctx context.Context
	rp1 *mm_insolar.Reference
}

// NetworkMockGetCertResults contains results of the Network.GetCert
type NetworkMockGetCertResults struct {
	c2  mm_insolar.Certificate
	err error
}

// Expect sets up expected params for Network.GetCert
func (mmGetCert *mNetworkMockGetCert) Expect(ctx context.Context, rp1 *mm_insolar.Reference) *mNetworkMockGetCert {
	if mmGetCert.mock.funcGetCert != nil {
		mmGetCert.mock.t.Fatalf("NetworkMock.GetCert mock is already set by Set")
	}

	if mmGetCert.defaultExpectation == nil {
		mmGetCert.defaultExpectation = &NetworkMockGetCertExpectation{}
	}

	mmGetCert.defaultExpectation.params = &NetworkMockGetCertParams{ctx, rp1}
	for _, e := range mmGetCert.expectations {
		if minimock.Equal(e.params, mmGetCert.defaultExpectation.params) {
			mmGetCert.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCert.defaultExpectation.params)
		}
	}

	return mmGetCert
}

// Inspect accepts an inspector function that has same arguments as the Network.GetCert
func (mmGetCert *mNetworkMockGetCert) Inspect(f func(ctx context.Context, rp1 *mm_insolar.Reference)) *mNetworkMockGetCert {
	if mmGetCert.mock.inspectFuncGetCert != nil {
		mmGetCert.mock.t.Fatalf("Inspect function is already set for NetworkMock.GetCert")
	}

	mmGetCert.mock.inspectFuncGetCert = f

	return mmGetCert
}

// Return sets up results that will be returned by Network.GetCert
func (mmGetCert *mNetworkMockGetCert) Return(c2 mm_insolar.Certificate, err error) *NetworkMock {
	if mmGetCert.mock.funcGetCert != nil {
		mmGetCert.mock.t.Fatalf("NetworkMock.GetCert mock is already set by Set")
	}

	if mmGetCert.defaultExpectation == nil {
		mmGetCert.defaultExpectation = &NetworkMockGetCertExpectation{mock: mmGetCert.mock}
	}
	mmGetCert.defaultExpectation.results = &NetworkMockGetCertResults{c2, err}
	return mmGetCert.mock
}

//Set uses given function f to mock the Network.GetCert method
func (mmGetCert *mNetworkMockGetCert) Set(f func(ctx context.Context, rp1 *mm_insolar.Reference) (c2 mm_insolar.Certificate, err error)) *NetworkMock {
	if mmGetCert.defaultExpectation != nil {
		mmGetCert.mock.t.Fatalf("Default expectation is already set for the Network.GetCert method")
	}

	if len(mmGetCert.expectations) > 0 {
		mmGetCert.mock.t.Fatalf("Some expectations are already set for the Network.GetCert method")
	}

	mmGetCert.mock.funcGetCert = f
	return mmGetCert.mock
}

// When sets expectation for the Network.GetCert which will trigger the result defined by the following
// Then helper
func (mmGetCert *mNetworkMockGetCert) When(ctx context.Context, rp1 *mm_insolar.Reference) *NetworkMockGetCertExpectation {
	if mmGetCert.mock.funcGetCert != nil {
		mmGetCert.mock.t.Fatalf("NetworkMock.GetCert mock is already set by Set")
	}

	expectation := &NetworkMockGetCertExpectation{
		mock:   mmGetCert.mock,
		params: &NetworkMockGetCertParams{ctx, rp1},
	}
	mmGetCert.expectations = append(mmGetCert.expectations, expectation)
	return expectation
}

// Then sets up Network.GetCert return parameters for the expectation previously defined by the When method
func (e *NetworkMockGetCertExpectation) Then(c2 mm_insolar.Certificate, err error) *NetworkMock {
	e.results = &NetworkMockGetCertResults{c2, err}
	return e.mock
}

// GetCert implements insolar.Network
func (mmGetCert *NetworkMock) GetCert(ctx context.Context, rp1 *mm_insolar.Reference) (c2 mm_insolar.Certificate, err error) {
	mm_atomic.AddUint64(&mmGetCert.beforeGetCertCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCert.afterGetCertCounter, 1)

	if mmGetCert.inspectFuncGetCert != nil {
		mmGetCert.inspectFuncGetCert(ctx, rp1)
	}

	params := &NetworkMockGetCertParams{ctx, rp1}

	// Record call args
	mmGetCert.GetCertMock.mutex.Lock()
	mmGetCert.GetCertMock.callArgs = append(mmGetCert.GetCertMock.callArgs, params)
	mmGetCert.GetCertMock.mutex.Unlock()

	for _, e := range mmGetCert.GetCertMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmGetCert.GetCertMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCert.GetCertMock.defaultExpectation.Counter, 1)
		want := mmGetCert.GetCertMock.defaultExpectation.params
		got := NetworkMockGetCertParams{ctx, rp1}
		if want != nil && !minimock.Equal(*want, got) {
			mmGetCert.t.Errorf("NetworkMock.GetCert got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGetCert.GetCertMock.defaultExpectation.results
		if results == nil {
			mmGetCert.t.Fatal("No results are set for the NetworkMock.GetCert")
		}
		return (*results).c2, (*results).err
	}
	if mmGetCert.funcGetCert != nil {
		return mmGetCert.funcGetCert(ctx, rp1)
	}
	mmGetCert.t.Fatalf("Unexpected call to NetworkMock.GetCert. %v %v", ctx, rp1)
	return
}

// GetCertAfterCounter returns a count of finished NetworkMock.GetCert invocations
func (mmGetCert *NetworkMock) GetCertAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCert.afterGetCertCounter)
}

// GetCertBeforeCounter returns a count of NetworkMock.GetCert invocations
func (mmGetCert *NetworkMock) GetCertBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCert.beforeGetCertCounter)
}

// Calls returns a list of arguments used in each call to NetworkMock.GetCert.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCert *mNetworkMockGetCert) Calls() []*NetworkMockGetCertParams {
	mmGetCert.mutex.RLock()

	argCopy := make([]*NetworkMockGetCertParams, len(mmGetCert.callArgs))
	copy(argCopy, mmGetCert.callArgs)

	mmGetCert.mutex.RUnlock()

	return argCopy
}

// MinimockGetCertDone returns true if the count of the GetCert invocations corresponds
// the number of defined expectations
func (m *NetworkMock) MinimockGetCertDone() bool {
	for _, e := range m.GetCertMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCertMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCertCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCert != nil && mm_atomic.LoadUint64(&m.afterGetCertCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCertInspect logs each unmet expectation
func (m *NetworkMock) MinimockGetCertInspect() {
	for _, e := range m.GetCertMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NetworkMock.GetCert with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCertMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCertCounter) < 1 {
		if m.GetCertMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to NetworkMock.GetCert")
		} else {
			m.t.Errorf("Expected call to NetworkMock.GetCert with params: %#v", *m.GetCertMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCert != nil && mm_atomic.LoadUint64(&m.afterGetCertCounter) < 1 {
		m.t.Error("Expected call to NetworkMock.GetCert")
	}
}

type mNetworkMockLeave struct {
	mock               *NetworkMock
	defaultExpectation *NetworkMockLeaveExpectation
	expectations       []*NetworkMockLeaveExpectation

	callArgs []*NetworkMockLeaveParams
	mutex    sync.RWMutex
}

// NetworkMockLeaveExpectation specifies expectation struct of the Network.Leave
type NetworkMockLeaveExpectation struct {
	mock   *NetworkMock
	params *NetworkMockLeaveParams

	Counter uint64
}

// NetworkMockLeaveParams contains parameters of the Network.Leave
type NetworkMockLeaveParams struct {
	ctx context.Context
	ETA mm_insolar.PulseNumber
}

// Expect sets up expected params for Network.Leave
func (mmLeave *mNetworkMockLeave) Expect(ctx context.Context, ETA mm_insolar.PulseNumber) *mNetworkMockLeave {
	if mmLeave.mock.funcLeave != nil {
		mmLeave.mock.t.Fatalf("NetworkMock.Leave mock is already set by Set")
	}

	if mmLeave.defaultExpectation == nil {
		mmLeave.defaultExpectation = &NetworkMockLeaveExpectation{}
	}

	mmLeave.defaultExpectation.params = &NetworkMockLeaveParams{ctx, ETA}
	for _, e := range mmLeave.expectations {
		if minimock.Equal(e.params, mmLeave.defaultExpectation.params) {
			mmLeave.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLeave.defaultExpectation.params)
		}
	}

	return mmLeave
}

// Inspect accepts an inspector function that has same arguments as the Network.Leave
func (mmLeave *mNetworkMockLeave) Inspect(f func(ctx context.Context, ETA mm_insolar.PulseNumber)) *mNetworkMockLeave {
	if mmLeave.mock.inspectFuncLeave != nil {
		mmLeave.mock.t.Fatalf("Inspect function is already set for NetworkMock.Leave")
	}

	mmLeave.mock.inspectFuncLeave = f

	return mmLeave
}

// Return sets up results that will be returned by Network.Leave
func (mmLeave *mNetworkMockLeave) Return() *NetworkMock {
	if mmLeave.mock.funcLeave != nil {
		mmLeave.mock.t.Fatalf("NetworkMock.Leave mock is already set by Set")
	}

	if mmLeave.defaultExpectation == nil {
		mmLeave.defaultExpectation = &NetworkMockLeaveExpectation{mock: mmLeave.mock}
	}

	return mmLeave.mock
}

//Set uses given function f to mock the Network.Leave method
func (mmLeave *mNetworkMockLeave) Set(f func(ctx context.Context, ETA mm_insolar.PulseNumber)) *NetworkMock {
	if mmLeave.defaultExpectation != nil {
		mmLeave.mock.t.Fatalf("Default expectation is already set for the Network.Leave method")
	}

	if len(mmLeave.expectations) > 0 {
		mmLeave.mock.t.Fatalf("Some expectations are already set for the Network.Leave method")
	}

	mmLeave.mock.funcLeave = f
	return mmLeave.mock
}

// Leave implements insolar.Network
func (mmLeave *NetworkMock) Leave(ctx context.Context, ETA mm_insolar.PulseNumber) {
	mm_atomic.AddUint64(&mmLeave.beforeLeaveCounter, 1)
	defer mm_atomic.AddUint64(&mmLeave.afterLeaveCounter, 1)

	if mmLeave.inspectFuncLeave != nil {
		mmLeave.inspectFuncLeave(ctx, ETA)
	}

	params := &NetworkMockLeaveParams{ctx, ETA}

	// Record call args
	mmLeave.LeaveMock.mutex.Lock()
	mmLeave.LeaveMock.callArgs = append(mmLeave.LeaveMock.callArgs, params)
	mmLeave.LeaveMock.mutex.Unlock()

	for _, e := range mmLeave.LeaveMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmLeave.LeaveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLeave.LeaveMock.defaultExpectation.Counter, 1)
		want := mmLeave.LeaveMock.defaultExpectation.params
		got := NetworkMockLeaveParams{ctx, ETA}
		if want != nil && !minimock.Equal(*want, got) {
			mmLeave.t.Errorf("NetworkMock.Leave got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmLeave.funcLeave != nil {
		mmLeave.funcLeave(ctx, ETA)
		return
	}
	mmLeave.t.Fatalf("Unexpected call to NetworkMock.Leave. %v %v", ctx, ETA)

}

// LeaveAfterCounter returns a count of finished NetworkMock.Leave invocations
func (mmLeave *NetworkMock) LeaveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLeave.afterLeaveCounter)
}

// LeaveBeforeCounter returns a count of NetworkMock.Leave invocations
func (mmLeave *NetworkMock) LeaveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLeave.beforeLeaveCounter)
}

// Calls returns a list of arguments used in each call to NetworkMock.Leave.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLeave *mNetworkMockLeave) Calls() []*NetworkMockLeaveParams {
	mmLeave.mutex.RLock()

	argCopy := make([]*NetworkMockLeaveParams, len(mmLeave.callArgs))
	copy(argCopy, mmLeave.callArgs)

	mmLeave.mutex.RUnlock()

	return argCopy
}

// MinimockLeaveDone returns true if the count of the Leave invocations corresponds
// the number of defined expectations
func (m *NetworkMock) MinimockLeaveDone() bool {
	for _, e := range m.LeaveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LeaveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLeaveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLeave != nil && mm_atomic.LoadUint64(&m.afterLeaveCounter) < 1 {
		return false
	}
	return true
}

// MinimockLeaveInspect logs each unmet expectation
func (m *NetworkMock) MinimockLeaveInspect() {
	for _, e := range m.LeaveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NetworkMock.Leave with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LeaveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLeaveCounter) < 1 {
		if m.LeaveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to NetworkMock.Leave")
		} else {
			m.t.Errorf("Expected call to NetworkMock.Leave with params: %#v", *m.LeaveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLeave != nil && mm_atomic.LoadUint64(&m.afterLeaveCounter) < 1 {
		m.t.Error("Expected call to NetworkMock.Leave")
	}
}

type mNetworkMockRemoteProcedureRegister struct {
	mock               *NetworkMock
	defaultExpectation *NetworkMockRemoteProcedureRegisterExpectation
	expectations       []*NetworkMockRemoteProcedureRegisterExpectation

	callArgs []*NetworkMockRemoteProcedureRegisterParams
	mutex    sync.RWMutex
}

// NetworkMockRemoteProcedureRegisterExpectation specifies expectation struct of the Network.RemoteProcedureRegister
type NetworkMockRemoteProcedureRegisterExpectation struct {
	mock   *NetworkMock
	params *NetworkMockRemoteProcedureRegisterParams

	Counter uint64
}

// NetworkMockRemoteProcedureRegisterParams contains parameters of the Network.RemoteProcedureRegister
type NetworkMockRemoteProcedureRegisterParams struct {
	name   string
	method mm_insolar.RemoteProcedure
}

// Expect sets up expected params for Network.RemoteProcedureRegister
func (mmRemoteProcedureRegister *mNetworkMockRemoteProcedureRegister) Expect(name string, method mm_insolar.RemoteProcedure) *mNetworkMockRemoteProcedureRegister {
	if mmRemoteProcedureRegister.mock.funcRemoteProcedureRegister != nil {
		mmRemoteProcedureRegister.mock.t.Fatalf("NetworkMock.RemoteProcedureRegister mock is already set by Set")
	}

	if mmRemoteProcedureRegister.defaultExpectation == nil {
		mmRemoteProcedureRegister.defaultExpectation = &NetworkMockRemoteProcedureRegisterExpectation{}
	}

	mmRemoteProcedureRegister.defaultExpectation.params = &NetworkMockRemoteProcedureRegisterParams{name, method}
	for _, e := range mmRemoteProcedureRegister.expectations {
		if minimock.Equal(e.params, mmRemoteProcedureRegister.defaultExpectation.params) {
			mmRemoteProcedureRegister.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoteProcedureRegister.defaultExpectation.params)
		}
	}

	return mmRemoteProcedureRegister
}

// Inspect accepts an inspector function that has same arguments as the Network.RemoteProcedureRegister
func (mmRemoteProcedureRegister *mNetworkMockRemoteProcedureRegister) Inspect(f func(name string, method mm_insolar.RemoteProcedure)) *mNetworkMockRemoteProcedureRegister {
	if mmRemoteProcedureRegister.mock.inspectFuncRemoteProcedureRegister != nil {
		mmRemoteProcedureRegister.mock.t.Fatalf("Inspect function is already set for NetworkMock.RemoteProcedureRegister")
	}

	mmRemoteProcedureRegister.mock.inspectFuncRemoteProcedureRegister = f

	return mmRemoteProcedureRegister
}

// Return sets up results that will be returned by Network.RemoteProcedureRegister
func (mmRemoteProcedureRegister *mNetworkMockRemoteProcedureRegister) Return() *NetworkMock {
	if mmRemoteProcedureRegister.mock.funcRemoteProcedureRegister != nil {
		mmRemoteProcedureRegister.mock.t.Fatalf("NetworkMock.RemoteProcedureRegister mock is already set by Set")
	}

	if mmRemoteProcedureRegister.defaultExpectation == nil {
		mmRemoteProcedureRegister.defaultExpectation = &NetworkMockRemoteProcedureRegisterExpectation{mock: mmRemoteProcedureRegister.mock}
	}

	return mmRemoteProcedureRegister.mock
}

//Set uses given function f to mock the Network.RemoteProcedureRegister method
func (mmRemoteProcedureRegister *mNetworkMockRemoteProcedureRegister) Set(f func(name string, method mm_insolar.RemoteProcedure)) *NetworkMock {
	if mmRemoteProcedureRegister.defaultExpectation != nil {
		mmRemoteProcedureRegister.mock.t.Fatalf("Default expectation is already set for the Network.RemoteProcedureRegister method")
	}

	if len(mmRemoteProcedureRegister.expectations) > 0 {
		mmRemoteProcedureRegister.mock.t.Fatalf("Some expectations are already set for the Network.RemoteProcedureRegister method")
	}

	mmRemoteProcedureRegister.mock.funcRemoteProcedureRegister = f
	return mmRemoteProcedureRegister.mock
}

// RemoteProcedureRegister implements insolar.Network
func (mmRemoteProcedureRegister *NetworkMock) RemoteProcedureRegister(name string, method mm_insolar.RemoteProcedure) {
	mm_atomic.AddUint64(&mmRemoteProcedureRegister.beforeRemoteProcedureRegisterCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoteProcedureRegister.afterRemoteProcedureRegisterCounter, 1)

	if mmRemoteProcedureRegister.inspectFuncRemoteProcedureRegister != nil {
		mmRemoteProcedureRegister.inspectFuncRemoteProcedureRegister(name, method)
	}

	params := &NetworkMockRemoteProcedureRegisterParams{name, method}

	// Record call args
	mmRemoteProcedureRegister.RemoteProcedureRegisterMock.mutex.Lock()
	mmRemoteProcedureRegister.RemoteProcedureRegisterMock.callArgs = append(mmRemoteProcedureRegister.RemoteProcedureRegisterMock.callArgs, params)
	mmRemoteProcedureRegister.RemoteProcedureRegisterMock.mutex.Unlock()

	for _, e := range mmRemoteProcedureRegister.RemoteProcedureRegisterMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmRemoteProcedureRegister.RemoteProcedureRegisterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoteProcedureRegister.RemoteProcedureRegisterMock.defaultExpectation.Counter, 1)
		want := mmRemoteProcedureRegister.RemoteProcedureRegisterMock.defaultExpectation.params
		got := NetworkMockRemoteProcedureRegisterParams{name, method}
		if want != nil && !minimock.Equal(*want, got) {
			mmRemoteProcedureRegister.t.Errorf("NetworkMock.RemoteProcedureRegister got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmRemoteProcedureRegister.funcRemoteProcedureRegister != nil {
		mmRemoteProcedureRegister.funcRemoteProcedureRegister(name, method)
		return
	}
	mmRemoteProcedureRegister.t.Fatalf("Unexpected call to NetworkMock.RemoteProcedureRegister. %v %v", name, method)

}

// RemoteProcedureRegisterAfterCounter returns a count of finished NetworkMock.RemoteProcedureRegister invocations
func (mmRemoteProcedureRegister *NetworkMock) RemoteProcedureRegisterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoteProcedureRegister.afterRemoteProcedureRegisterCounter)
}

// RemoteProcedureRegisterBeforeCounter returns a count of NetworkMock.RemoteProcedureRegister invocations
func (mmRemoteProcedureRegister *NetworkMock) RemoteProcedureRegisterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoteProcedureRegister.beforeRemoteProcedureRegisterCounter)
}

// Calls returns a list of arguments used in each call to NetworkMock.RemoteProcedureRegister.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoteProcedureRegister *mNetworkMockRemoteProcedureRegister) Calls() []*NetworkMockRemoteProcedureRegisterParams {
	mmRemoteProcedureRegister.mutex.RLock()

	argCopy := make([]*NetworkMockRemoteProcedureRegisterParams, len(mmRemoteProcedureRegister.callArgs))
	copy(argCopy, mmRemoteProcedureRegister.callArgs)

	mmRemoteProcedureRegister.mutex.RUnlock()

	return argCopy
}

// MinimockRemoteProcedureRegisterDone returns true if the count of the RemoteProcedureRegister invocations corresponds
// the number of defined expectations
func (m *NetworkMock) MinimockRemoteProcedureRegisterDone() bool {
	for _, e := range m.RemoteProcedureRegisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoteProcedureRegisterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoteProcedureRegisterCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoteProcedureRegister != nil && mm_atomic.LoadUint64(&m.afterRemoteProcedureRegisterCounter) < 1 {
		return false
	}
	return true
}

// MinimockRemoteProcedureRegisterInspect logs each unmet expectation
func (m *NetworkMock) MinimockRemoteProcedureRegisterInspect() {
	for _, e := range m.RemoteProcedureRegisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NetworkMock.RemoteProcedureRegister with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoteProcedureRegisterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoteProcedureRegisterCounter) < 1 {
		if m.RemoteProcedureRegisterMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to NetworkMock.RemoteProcedureRegister")
		} else {
			m.t.Errorf("Expected call to NetworkMock.RemoteProcedureRegister with params: %#v", *m.RemoteProcedureRegisterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoteProcedureRegister != nil && mm_atomic.LoadUint64(&m.afterRemoteProcedureRegisterCounter) < 1 {
		m.t.Error("Expected call to NetworkMock.RemoteProcedureRegister")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *NetworkMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetCertInspect()

		m.MinimockLeaveInspect()

		m.MinimockRemoteProcedureRegisterInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *NetworkMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *NetworkMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetCertDone() &&
		m.MinimockLeaveDone() &&
		m.MinimockRemoteProcedureRegisterDone()
}
