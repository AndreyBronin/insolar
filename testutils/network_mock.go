package testutils

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	mm_insolar "github.com/insolar/insolar/insolar"
)

// NetworkMock implements insolar.Network
type NetworkMock struct {
	t minimock.Tester

	funcGetCert          func(ctx context.Context, rp1 *mm_insolar.Reference) (c2 mm_insolar.Certificate, err error)
	inspectFuncGetCert   func(ctx context.Context, rp1 *mm_insolar.Reference)
	afterGetCertCounter  uint64
	beforeGetCertCounter uint64
	GetCertMock          mNetworkMockGetCert

	funcGetState          func() (n1 mm_insolar.NetworkState)
	inspectFuncGetState   func()
	afterGetStateCounter  uint64
	beforeGetStateCounter uint64
	GetStateMock          mNetworkMockGetState

	funcLeave          func(ctx context.Context, ETA mm_insolar.PulseNumber)
	inspectFuncLeave   func(ctx context.Context, ETA mm_insolar.PulseNumber)
	afterLeaveCounter  uint64
	beforeLeaveCounter uint64
	LeaveMock          mNetworkMockLeave

	funcRemoteProcedureRegister          func(name string, method mm_insolar.RemoteProcedure)
	inspectFuncRemoteProcedureRegister   func(name string, method mm_insolar.RemoteProcedure)
	afterRemoteProcedureRegisterCounter  uint64
	beforeRemoteProcedureRegisterCounter uint64
	RemoteProcedureRegisterMock          mNetworkMockRemoteProcedureRegister

	funcSendCascadeMessage          func(data mm_insolar.Cascade, method string, msg mm_insolar.Parcel) (err error)
	inspectFuncSendCascadeMessage   func(data mm_insolar.Cascade, method string, msg mm_insolar.Parcel)
	afterSendCascadeMessageCounter  uint64
	beforeSendCascadeMessageCounter uint64
	SendCascadeMessageMock          mNetworkMockSendCascadeMessage

	funcSendMessage          func(nodeID mm_insolar.Reference, method string, msg mm_insolar.Parcel) (ba1 []byte, err error)
	inspectFuncSendMessage   func(nodeID mm_insolar.Reference, method string, msg mm_insolar.Parcel)
	afterSendMessageCounter  uint64
	beforeSendMessageCounter uint64
	SendMessageMock          mNetworkMockSendMessage
}

// NewNetworkMock returns a mock for insolar.Network
func NewNetworkMock(t minimock.Tester) *NetworkMock {
	m := &NetworkMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetCertMock = mNetworkMockGetCert{mock: m}
	m.GetCertMock.callArgs = []*NetworkMockGetCertParams{}

	m.GetStateMock = mNetworkMockGetState{mock: m}

	m.LeaveMock = mNetworkMockLeave{mock: m}
	m.LeaveMock.callArgs = []*NetworkMockLeaveParams{}

	m.RemoteProcedureRegisterMock = mNetworkMockRemoteProcedureRegister{mock: m}
	m.RemoteProcedureRegisterMock.callArgs = []*NetworkMockRemoteProcedureRegisterParams{}

	m.SendCascadeMessageMock = mNetworkMockSendCascadeMessage{mock: m}
	m.SendCascadeMessageMock.callArgs = []*NetworkMockSendCascadeMessageParams{}

	m.SendMessageMock = mNetworkMockSendMessage{mock: m}
	m.SendMessageMock.callArgs = []*NetworkMockSendMessageParams{}

	return m
}

type mNetworkMockGetCert struct {
	mock               *NetworkMock
	defaultExpectation *NetworkMockGetCertExpectation
	expectations       []*NetworkMockGetCertExpectation

	callArgs []*NetworkMockGetCertParams
	mutex    sync.RWMutex
}

// NetworkMockGetCertExpectation specifies expectation struct of the Network.GetCert
type NetworkMockGetCertExpectation struct {
	mock    *NetworkMock
	params  *NetworkMockGetCertParams
	results *NetworkMockGetCertResults
	Counter uint64
}

// NetworkMockGetCertParams contains parameters of the Network.GetCert
type NetworkMockGetCertParams struct {
	ctx context.Context
	rp1 *mm_insolar.Reference
}

// NetworkMockGetCertResults contains results of the Network.GetCert
type NetworkMockGetCertResults struct {
	c2  mm_insolar.Certificate
	err error
}

// Expect sets up expected params for Network.GetCert
func (mmGetCert *mNetworkMockGetCert) Expect(ctx context.Context, rp1 *mm_insolar.Reference) *mNetworkMockGetCert {
	if mmGetCert.mock.funcGetCert != nil {
		mmGetCert.mock.t.Fatalf("NetworkMock.GetCert mock is already set by Set")
	}

	if mmGetCert.defaultExpectation == nil {
		mmGetCert.defaultExpectation = &NetworkMockGetCertExpectation{}
	}

	mmGetCert.defaultExpectation.params = &NetworkMockGetCertParams{ctx, rp1}
	for _, e := range mmGetCert.expectations {
		if minimock.Equal(e.params, mmGetCert.defaultExpectation.params) {
			mmGetCert.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCert.defaultExpectation.params)
		}
	}

	return mmGetCert
}

// Inspect accepts an inspector function that has same arguments as the Network.GetCert
func (mmGetCert *mNetworkMockGetCert) Inspect(f func(ctx context.Context, rp1 *mm_insolar.Reference)) *mNetworkMockGetCert {
	if mmGetCert.mock.inspectFuncGetCert != nil {
		mmGetCert.mock.t.Fatalf("Inspect function is already set for NetworkMock.GetCert")
	}

	mmGetCert.mock.inspectFuncGetCert = f

	return mmGetCert
}

// Return sets up results that will be returned by Network.GetCert
func (mmGetCert *mNetworkMockGetCert) Return(c2 mm_insolar.Certificate, err error) *NetworkMock {
	if mmGetCert.mock.funcGetCert != nil {
		mmGetCert.mock.t.Fatalf("NetworkMock.GetCert mock is already set by Set")
	}

	if mmGetCert.defaultExpectation == nil {
		mmGetCert.defaultExpectation = &NetworkMockGetCertExpectation{mock: mmGetCert.mock}
	}
	mmGetCert.defaultExpectation.results = &NetworkMockGetCertResults{c2, err}
	return mmGetCert.mock
}

//Set uses given function f to mock the Network.GetCert method
func (mmGetCert *mNetworkMockGetCert) Set(f func(ctx context.Context, rp1 *mm_insolar.Reference) (c2 mm_insolar.Certificate, err error)) *NetworkMock {
	if mmGetCert.defaultExpectation != nil {
		mmGetCert.mock.t.Fatalf("Default expectation is already set for the Network.GetCert method")
	}

	if len(mmGetCert.expectations) > 0 {
		mmGetCert.mock.t.Fatalf("Some expectations are already set for the Network.GetCert method")
	}

	mmGetCert.mock.funcGetCert = f
	return mmGetCert.mock
}

// When sets expectation for the Network.GetCert which will trigger the result defined by the following
// Then helper
func (mmGetCert *mNetworkMockGetCert) When(ctx context.Context, rp1 *mm_insolar.Reference) *NetworkMockGetCertExpectation {
	if mmGetCert.mock.funcGetCert != nil {
		mmGetCert.mock.t.Fatalf("NetworkMock.GetCert mock is already set by Set")
	}

	expectation := &NetworkMockGetCertExpectation{
		mock:   mmGetCert.mock,
		params: &NetworkMockGetCertParams{ctx, rp1},
	}
	mmGetCert.expectations = append(mmGetCert.expectations, expectation)
	return expectation
}

// Then sets up Network.GetCert return parameters for the expectation previously defined by the When method
func (e *NetworkMockGetCertExpectation) Then(c2 mm_insolar.Certificate, err error) *NetworkMock {
	e.results = &NetworkMockGetCertResults{c2, err}
	return e.mock
}

// GetCert implements insolar.Network
func (mmGetCert *NetworkMock) GetCert(ctx context.Context, rp1 *mm_insolar.Reference) (c2 mm_insolar.Certificate, err error) {
	mm_atomic.AddUint64(&mmGetCert.beforeGetCertCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCert.afterGetCertCounter, 1)

	if mmGetCert.inspectFuncGetCert != nil {
		mmGetCert.inspectFuncGetCert(ctx, rp1)
	}

	params := &NetworkMockGetCertParams{ctx, rp1}

	// Record call args
	mmGetCert.GetCertMock.mutex.Lock()
	mmGetCert.GetCertMock.callArgs = append(mmGetCert.GetCertMock.callArgs, params)
	mmGetCert.GetCertMock.mutex.Unlock()

	for _, e := range mmGetCert.GetCertMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmGetCert.GetCertMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCert.GetCertMock.defaultExpectation.Counter, 1)
		want := mmGetCert.GetCertMock.defaultExpectation.params
		got := NetworkMockGetCertParams{ctx, rp1}
		if want != nil && !minimock.Equal(*want, got) {
			mmGetCert.t.Errorf("NetworkMock.GetCert got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGetCert.GetCertMock.defaultExpectation.results
		if results == nil {
			mmGetCert.t.Fatal("No results are set for the NetworkMock.GetCert")
		}
		return (*results).c2, (*results).err
	}
	if mmGetCert.funcGetCert != nil {
		return mmGetCert.funcGetCert(ctx, rp1)
	}
	mmGetCert.t.Fatalf("Unexpected call to NetworkMock.GetCert. %v %v", ctx, rp1)
	return
}

// GetCertAfterCounter returns a count of finished NetworkMock.GetCert invocations
func (mmGetCert *NetworkMock) GetCertAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCert.afterGetCertCounter)
}

// GetCertBeforeCounter returns a count of NetworkMock.GetCert invocations
func (mmGetCert *NetworkMock) GetCertBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCert.beforeGetCertCounter)
}

// Calls returns a list of arguments used in each call to NetworkMock.GetCert.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCert *mNetworkMockGetCert) Calls() []*NetworkMockGetCertParams {
	mmGetCert.mutex.RLock()

	argCopy := make([]*NetworkMockGetCertParams, len(mmGetCert.callArgs))
	copy(argCopy, mmGetCert.callArgs)

	mmGetCert.mutex.RUnlock()

	return argCopy
}

// MinimockGetCertDone returns true if the count of the GetCert invocations corresponds
// the number of defined expectations
func (m *NetworkMock) MinimockGetCertDone() bool {
	for _, e := range m.GetCertMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCertMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCertCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCert != nil && mm_atomic.LoadUint64(&m.afterGetCertCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCertInspect logs each unmet expectation
func (m *NetworkMock) MinimockGetCertInspect() {
	for _, e := range m.GetCertMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NetworkMock.GetCert with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCertMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCertCounter) < 1 {
		if m.GetCertMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to NetworkMock.GetCert")
		} else {
			m.t.Errorf("Expected call to NetworkMock.GetCert with params: %#v", *m.GetCertMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCert != nil && mm_atomic.LoadUint64(&m.afterGetCertCounter) < 1 {
		m.t.Error("Expected call to NetworkMock.GetCert")
	}
}

type mNetworkMockGetState struct {
	mock               *NetworkMock
	defaultExpectation *NetworkMockGetStateExpectation
	expectations       []*NetworkMockGetStateExpectation
}

// NetworkMockGetStateExpectation specifies expectation struct of the Network.GetState
type NetworkMockGetStateExpectation struct {
	mock *NetworkMock

	results *NetworkMockGetStateResults
	Counter uint64
}

// NetworkMockGetStateResults contains results of the Network.GetState
type NetworkMockGetStateResults struct {
	n1 mm_insolar.NetworkState
}

// Expect sets up expected params for Network.GetState
func (mmGetState *mNetworkMockGetState) Expect() *mNetworkMockGetState {
	if mmGetState.mock.funcGetState != nil {
		mmGetState.mock.t.Fatalf("NetworkMock.GetState mock is already set by Set")
	}

	if mmGetState.defaultExpectation == nil {
		mmGetState.defaultExpectation = &NetworkMockGetStateExpectation{}
	}

	return mmGetState
}

// Inspect accepts an inspector function that has same arguments as the Network.GetState
func (mmGetState *mNetworkMockGetState) Inspect(f func()) *mNetworkMockGetState {
	if mmGetState.mock.inspectFuncGetState != nil {
		mmGetState.mock.t.Fatalf("Inspect function is already set for NetworkMock.GetState")
	}

	mmGetState.mock.inspectFuncGetState = f

	return mmGetState
}

// Return sets up results that will be returned by Network.GetState
func (mmGetState *mNetworkMockGetState) Return(n1 mm_insolar.NetworkState) *NetworkMock {
	if mmGetState.mock.funcGetState != nil {
		mmGetState.mock.t.Fatalf("NetworkMock.GetState mock is already set by Set")
	}

	if mmGetState.defaultExpectation == nil {
		mmGetState.defaultExpectation = &NetworkMockGetStateExpectation{mock: mmGetState.mock}
	}
	mmGetState.defaultExpectation.results = &NetworkMockGetStateResults{n1}
	return mmGetState.mock
}

//Set uses given function f to mock the Network.GetState method
func (mmGetState *mNetworkMockGetState) Set(f func() (n1 mm_insolar.NetworkState)) *NetworkMock {
	if mmGetState.defaultExpectation != nil {
		mmGetState.mock.t.Fatalf("Default expectation is already set for the Network.GetState method")
	}

	if len(mmGetState.expectations) > 0 {
		mmGetState.mock.t.Fatalf("Some expectations are already set for the Network.GetState method")
	}

	mmGetState.mock.funcGetState = f
	return mmGetState.mock
}

// GetState implements insolar.Network
func (mmGetState *NetworkMock) GetState() (n1 mm_insolar.NetworkState) {
	mm_atomic.AddUint64(&mmGetState.beforeGetStateCounter, 1)
	defer mm_atomic.AddUint64(&mmGetState.afterGetStateCounter, 1)

	if mmGetState.inspectFuncGetState != nil {
		mmGetState.inspectFuncGetState()
	}

	if mmGetState.GetStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetState.GetStateMock.defaultExpectation.Counter, 1)

		results := mmGetState.GetStateMock.defaultExpectation.results
		if results == nil {
			mmGetState.t.Fatal("No results are set for the NetworkMock.GetState")
		}
		return (*results).n1
	}
	if mmGetState.funcGetState != nil {
		return mmGetState.funcGetState()
	}
	mmGetState.t.Fatalf("Unexpected call to NetworkMock.GetState.")
	return
}

// GetStateAfterCounter returns a count of finished NetworkMock.GetState invocations
func (mmGetState *NetworkMock) GetStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetState.afterGetStateCounter)
}

// GetStateBeforeCounter returns a count of NetworkMock.GetState invocations
func (mmGetState *NetworkMock) GetStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetState.beforeGetStateCounter)
}

// MinimockGetStateDone returns true if the count of the GetState invocations corresponds
// the number of defined expectations
func (m *NetworkMock) MinimockGetStateDone() bool {
	for _, e := range m.GetStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetStateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetState != nil && mm_atomic.LoadUint64(&m.afterGetStateCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetStateInspect logs each unmet expectation
func (m *NetworkMock) MinimockGetStateInspect() {
	for _, e := range m.GetStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NetworkMock.GetState")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetStateCounter) < 1 {
		m.t.Error("Expected call to NetworkMock.GetState")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetState != nil && mm_atomic.LoadUint64(&m.afterGetStateCounter) < 1 {
		m.t.Error("Expected call to NetworkMock.GetState")
	}
}

type mNetworkMockLeave struct {
	mock               *NetworkMock
	defaultExpectation *NetworkMockLeaveExpectation
	expectations       []*NetworkMockLeaveExpectation

	callArgs []*NetworkMockLeaveParams
	mutex    sync.RWMutex
}

// NetworkMockLeaveExpectation specifies expectation struct of the Network.Leave
type NetworkMockLeaveExpectation struct {
	mock   *NetworkMock
	params *NetworkMockLeaveParams

	Counter uint64
}

// NetworkMockLeaveParams contains parameters of the Network.Leave
type NetworkMockLeaveParams struct {
	ctx context.Context
	ETA mm_insolar.PulseNumber
}

// Expect sets up expected params for Network.Leave
func (mmLeave *mNetworkMockLeave) Expect(ctx context.Context, ETA mm_insolar.PulseNumber) *mNetworkMockLeave {
	if mmLeave.mock.funcLeave != nil {
		mmLeave.mock.t.Fatalf("NetworkMock.Leave mock is already set by Set")
	}

	if mmLeave.defaultExpectation == nil {
		mmLeave.defaultExpectation = &NetworkMockLeaveExpectation{}
	}

	mmLeave.defaultExpectation.params = &NetworkMockLeaveParams{ctx, ETA}
	for _, e := range mmLeave.expectations {
		if minimock.Equal(e.params, mmLeave.defaultExpectation.params) {
			mmLeave.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLeave.defaultExpectation.params)
		}
	}

	return mmLeave
}

// Inspect accepts an inspector function that has same arguments as the Network.Leave
func (mmLeave *mNetworkMockLeave) Inspect(f func(ctx context.Context, ETA mm_insolar.PulseNumber)) *mNetworkMockLeave {
	if mmLeave.mock.inspectFuncLeave != nil {
		mmLeave.mock.t.Fatalf("Inspect function is already set for NetworkMock.Leave")
	}

	mmLeave.mock.inspectFuncLeave = f

	return mmLeave
}

// Return sets up results that will be returned by Network.Leave
func (mmLeave *mNetworkMockLeave) Return() *NetworkMock {
	if mmLeave.mock.funcLeave != nil {
		mmLeave.mock.t.Fatalf("NetworkMock.Leave mock is already set by Set")
	}

	if mmLeave.defaultExpectation == nil {
		mmLeave.defaultExpectation = &NetworkMockLeaveExpectation{mock: mmLeave.mock}
	}

	return mmLeave.mock
}

//Set uses given function f to mock the Network.Leave method
func (mmLeave *mNetworkMockLeave) Set(f func(ctx context.Context, ETA mm_insolar.PulseNumber)) *NetworkMock {
	if mmLeave.defaultExpectation != nil {
		mmLeave.mock.t.Fatalf("Default expectation is already set for the Network.Leave method")
	}

	if len(mmLeave.expectations) > 0 {
		mmLeave.mock.t.Fatalf("Some expectations are already set for the Network.Leave method")
	}

	mmLeave.mock.funcLeave = f
	return mmLeave.mock
}

// Leave implements insolar.Network
func (mmLeave *NetworkMock) Leave(ctx context.Context, ETA mm_insolar.PulseNumber) {
	mm_atomic.AddUint64(&mmLeave.beforeLeaveCounter, 1)
	defer mm_atomic.AddUint64(&mmLeave.afterLeaveCounter, 1)

	if mmLeave.inspectFuncLeave != nil {
		mmLeave.inspectFuncLeave(ctx, ETA)
	}

	params := &NetworkMockLeaveParams{ctx, ETA}

	// Record call args
	mmLeave.LeaveMock.mutex.Lock()
	mmLeave.LeaveMock.callArgs = append(mmLeave.LeaveMock.callArgs, params)
	mmLeave.LeaveMock.mutex.Unlock()

	for _, e := range mmLeave.LeaveMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmLeave.LeaveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLeave.LeaveMock.defaultExpectation.Counter, 1)
		want := mmLeave.LeaveMock.defaultExpectation.params
		got := NetworkMockLeaveParams{ctx, ETA}
		if want != nil && !minimock.Equal(*want, got) {
			mmLeave.t.Errorf("NetworkMock.Leave got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmLeave.funcLeave != nil {
		mmLeave.funcLeave(ctx, ETA)
		return
	}
	mmLeave.t.Fatalf("Unexpected call to NetworkMock.Leave. %v %v", ctx, ETA)

}

// LeaveAfterCounter returns a count of finished NetworkMock.Leave invocations
func (mmLeave *NetworkMock) LeaveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLeave.afterLeaveCounter)
}

// LeaveBeforeCounter returns a count of NetworkMock.Leave invocations
func (mmLeave *NetworkMock) LeaveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLeave.beforeLeaveCounter)
}

// Calls returns a list of arguments used in each call to NetworkMock.Leave.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLeave *mNetworkMockLeave) Calls() []*NetworkMockLeaveParams {
	mmLeave.mutex.RLock()

	argCopy := make([]*NetworkMockLeaveParams, len(mmLeave.callArgs))
	copy(argCopy, mmLeave.callArgs)

	mmLeave.mutex.RUnlock()

	return argCopy
}

// MinimockLeaveDone returns true if the count of the Leave invocations corresponds
// the number of defined expectations
func (m *NetworkMock) MinimockLeaveDone() bool {
	for _, e := range m.LeaveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LeaveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLeaveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLeave != nil && mm_atomic.LoadUint64(&m.afterLeaveCounter) < 1 {
		return false
	}
	return true
}

// MinimockLeaveInspect logs each unmet expectation
func (m *NetworkMock) MinimockLeaveInspect() {
	for _, e := range m.LeaveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NetworkMock.Leave with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LeaveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLeaveCounter) < 1 {
		if m.LeaveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to NetworkMock.Leave")
		} else {
			m.t.Errorf("Expected call to NetworkMock.Leave with params: %#v", *m.LeaveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLeave != nil && mm_atomic.LoadUint64(&m.afterLeaveCounter) < 1 {
		m.t.Error("Expected call to NetworkMock.Leave")
	}
}

type mNetworkMockRemoteProcedureRegister struct {
	mock               *NetworkMock
	defaultExpectation *NetworkMockRemoteProcedureRegisterExpectation
	expectations       []*NetworkMockRemoteProcedureRegisterExpectation

	callArgs []*NetworkMockRemoteProcedureRegisterParams
	mutex    sync.RWMutex
}

// NetworkMockRemoteProcedureRegisterExpectation specifies expectation struct of the Network.RemoteProcedureRegister
type NetworkMockRemoteProcedureRegisterExpectation struct {
	mock   *NetworkMock
	params *NetworkMockRemoteProcedureRegisterParams

	Counter uint64
}

// NetworkMockRemoteProcedureRegisterParams contains parameters of the Network.RemoteProcedureRegister
type NetworkMockRemoteProcedureRegisterParams struct {
	name   string
	method mm_insolar.RemoteProcedure
}

// Expect sets up expected params for Network.RemoteProcedureRegister
func (mmRemoteProcedureRegister *mNetworkMockRemoteProcedureRegister) Expect(name string, method mm_insolar.RemoteProcedure) *mNetworkMockRemoteProcedureRegister {
	if mmRemoteProcedureRegister.mock.funcRemoteProcedureRegister != nil {
		mmRemoteProcedureRegister.mock.t.Fatalf("NetworkMock.RemoteProcedureRegister mock is already set by Set")
	}

	if mmRemoteProcedureRegister.defaultExpectation == nil {
		mmRemoteProcedureRegister.defaultExpectation = &NetworkMockRemoteProcedureRegisterExpectation{}
	}

	mmRemoteProcedureRegister.defaultExpectation.params = &NetworkMockRemoteProcedureRegisterParams{name, method}
	for _, e := range mmRemoteProcedureRegister.expectations {
		if minimock.Equal(e.params, mmRemoteProcedureRegister.defaultExpectation.params) {
			mmRemoteProcedureRegister.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoteProcedureRegister.defaultExpectation.params)
		}
	}

	return mmRemoteProcedureRegister
}

// Inspect accepts an inspector function that has same arguments as the Network.RemoteProcedureRegister
func (mmRemoteProcedureRegister *mNetworkMockRemoteProcedureRegister) Inspect(f func(name string, method mm_insolar.RemoteProcedure)) *mNetworkMockRemoteProcedureRegister {
	if mmRemoteProcedureRegister.mock.inspectFuncRemoteProcedureRegister != nil {
		mmRemoteProcedureRegister.mock.t.Fatalf("Inspect function is already set for NetworkMock.RemoteProcedureRegister")
	}

	mmRemoteProcedureRegister.mock.inspectFuncRemoteProcedureRegister = f

	return mmRemoteProcedureRegister
}

// Return sets up results that will be returned by Network.RemoteProcedureRegister
func (mmRemoteProcedureRegister *mNetworkMockRemoteProcedureRegister) Return() *NetworkMock {
	if mmRemoteProcedureRegister.mock.funcRemoteProcedureRegister != nil {
		mmRemoteProcedureRegister.mock.t.Fatalf("NetworkMock.RemoteProcedureRegister mock is already set by Set")
	}

	if mmRemoteProcedureRegister.defaultExpectation == nil {
		mmRemoteProcedureRegister.defaultExpectation = &NetworkMockRemoteProcedureRegisterExpectation{mock: mmRemoteProcedureRegister.mock}
	}

	return mmRemoteProcedureRegister.mock
}

//Set uses given function f to mock the Network.RemoteProcedureRegister method
func (mmRemoteProcedureRegister *mNetworkMockRemoteProcedureRegister) Set(f func(name string, method mm_insolar.RemoteProcedure)) *NetworkMock {
	if mmRemoteProcedureRegister.defaultExpectation != nil {
		mmRemoteProcedureRegister.mock.t.Fatalf("Default expectation is already set for the Network.RemoteProcedureRegister method")
	}

	if len(mmRemoteProcedureRegister.expectations) > 0 {
		mmRemoteProcedureRegister.mock.t.Fatalf("Some expectations are already set for the Network.RemoteProcedureRegister method")
	}

	mmRemoteProcedureRegister.mock.funcRemoteProcedureRegister = f
	return mmRemoteProcedureRegister.mock
}

// RemoteProcedureRegister implements insolar.Network
func (mmRemoteProcedureRegister *NetworkMock) RemoteProcedureRegister(name string, method mm_insolar.RemoteProcedure) {
	mm_atomic.AddUint64(&mmRemoteProcedureRegister.beforeRemoteProcedureRegisterCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoteProcedureRegister.afterRemoteProcedureRegisterCounter, 1)

	if mmRemoteProcedureRegister.inspectFuncRemoteProcedureRegister != nil {
		mmRemoteProcedureRegister.inspectFuncRemoteProcedureRegister(name, method)
	}

	params := &NetworkMockRemoteProcedureRegisterParams{name, method}

	// Record call args
	mmRemoteProcedureRegister.RemoteProcedureRegisterMock.mutex.Lock()
	mmRemoteProcedureRegister.RemoteProcedureRegisterMock.callArgs = append(mmRemoteProcedureRegister.RemoteProcedureRegisterMock.callArgs, params)
	mmRemoteProcedureRegister.RemoteProcedureRegisterMock.mutex.Unlock()

	for _, e := range mmRemoteProcedureRegister.RemoteProcedureRegisterMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmRemoteProcedureRegister.RemoteProcedureRegisterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoteProcedureRegister.RemoteProcedureRegisterMock.defaultExpectation.Counter, 1)
		want := mmRemoteProcedureRegister.RemoteProcedureRegisterMock.defaultExpectation.params
		got := NetworkMockRemoteProcedureRegisterParams{name, method}
		if want != nil && !minimock.Equal(*want, got) {
			mmRemoteProcedureRegister.t.Errorf("NetworkMock.RemoteProcedureRegister got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmRemoteProcedureRegister.funcRemoteProcedureRegister != nil {
		mmRemoteProcedureRegister.funcRemoteProcedureRegister(name, method)
		return
	}
	mmRemoteProcedureRegister.t.Fatalf("Unexpected call to NetworkMock.RemoteProcedureRegister. %v %v", name, method)

}

// RemoteProcedureRegisterAfterCounter returns a count of finished NetworkMock.RemoteProcedureRegister invocations
func (mmRemoteProcedureRegister *NetworkMock) RemoteProcedureRegisterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoteProcedureRegister.afterRemoteProcedureRegisterCounter)
}

// RemoteProcedureRegisterBeforeCounter returns a count of NetworkMock.RemoteProcedureRegister invocations
func (mmRemoteProcedureRegister *NetworkMock) RemoteProcedureRegisterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoteProcedureRegister.beforeRemoteProcedureRegisterCounter)
}

// Calls returns a list of arguments used in each call to NetworkMock.RemoteProcedureRegister.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoteProcedureRegister *mNetworkMockRemoteProcedureRegister) Calls() []*NetworkMockRemoteProcedureRegisterParams {
	mmRemoteProcedureRegister.mutex.RLock()

	argCopy := make([]*NetworkMockRemoteProcedureRegisterParams, len(mmRemoteProcedureRegister.callArgs))
	copy(argCopy, mmRemoteProcedureRegister.callArgs)

	mmRemoteProcedureRegister.mutex.RUnlock()

	return argCopy
}

// MinimockRemoteProcedureRegisterDone returns true if the count of the RemoteProcedureRegister invocations corresponds
// the number of defined expectations
func (m *NetworkMock) MinimockRemoteProcedureRegisterDone() bool {
	for _, e := range m.RemoteProcedureRegisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoteProcedureRegisterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoteProcedureRegisterCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoteProcedureRegister != nil && mm_atomic.LoadUint64(&m.afterRemoteProcedureRegisterCounter) < 1 {
		return false
	}
	return true
}

// MinimockRemoteProcedureRegisterInspect logs each unmet expectation
func (m *NetworkMock) MinimockRemoteProcedureRegisterInspect() {
	for _, e := range m.RemoteProcedureRegisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NetworkMock.RemoteProcedureRegister with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoteProcedureRegisterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoteProcedureRegisterCounter) < 1 {
		if m.RemoteProcedureRegisterMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to NetworkMock.RemoteProcedureRegister")
		} else {
			m.t.Errorf("Expected call to NetworkMock.RemoteProcedureRegister with params: %#v", *m.RemoteProcedureRegisterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoteProcedureRegister != nil && mm_atomic.LoadUint64(&m.afterRemoteProcedureRegisterCounter) < 1 {
		m.t.Error("Expected call to NetworkMock.RemoteProcedureRegister")
	}
}

type mNetworkMockSendCascadeMessage struct {
	mock               *NetworkMock
	defaultExpectation *NetworkMockSendCascadeMessageExpectation
	expectations       []*NetworkMockSendCascadeMessageExpectation

	callArgs []*NetworkMockSendCascadeMessageParams
	mutex    sync.RWMutex
}

// NetworkMockSendCascadeMessageExpectation specifies expectation struct of the Network.SendCascadeMessage
type NetworkMockSendCascadeMessageExpectation struct {
	mock    *NetworkMock
	params  *NetworkMockSendCascadeMessageParams
	results *NetworkMockSendCascadeMessageResults
	Counter uint64
}

// NetworkMockSendCascadeMessageParams contains parameters of the Network.SendCascadeMessage
type NetworkMockSendCascadeMessageParams struct {
	data   mm_insolar.Cascade
	method string
	msg    mm_insolar.Parcel
}

// NetworkMockSendCascadeMessageResults contains results of the Network.SendCascadeMessage
type NetworkMockSendCascadeMessageResults struct {
	err error
}

// Expect sets up expected params for Network.SendCascadeMessage
func (mmSendCascadeMessage *mNetworkMockSendCascadeMessage) Expect(data mm_insolar.Cascade, method string, msg mm_insolar.Parcel) *mNetworkMockSendCascadeMessage {
	if mmSendCascadeMessage.mock.funcSendCascadeMessage != nil {
		mmSendCascadeMessage.mock.t.Fatalf("NetworkMock.SendCascadeMessage mock is already set by Set")
	}

	if mmSendCascadeMessage.defaultExpectation == nil {
		mmSendCascadeMessage.defaultExpectation = &NetworkMockSendCascadeMessageExpectation{}
	}

	mmSendCascadeMessage.defaultExpectation.params = &NetworkMockSendCascadeMessageParams{data, method, msg}
	for _, e := range mmSendCascadeMessage.expectations {
		if minimock.Equal(e.params, mmSendCascadeMessage.defaultExpectation.params) {
			mmSendCascadeMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendCascadeMessage.defaultExpectation.params)
		}
	}

	return mmSendCascadeMessage
}

// Inspect accepts an inspector function that has same arguments as the Network.SendCascadeMessage
func (mmSendCascadeMessage *mNetworkMockSendCascadeMessage) Inspect(f func(data mm_insolar.Cascade, method string, msg mm_insolar.Parcel)) *mNetworkMockSendCascadeMessage {
	if mmSendCascadeMessage.mock.inspectFuncSendCascadeMessage != nil {
		mmSendCascadeMessage.mock.t.Fatalf("Inspect function is already set for NetworkMock.SendCascadeMessage")
	}

	mmSendCascadeMessage.mock.inspectFuncSendCascadeMessage = f

	return mmSendCascadeMessage
}

// Return sets up results that will be returned by Network.SendCascadeMessage
func (mmSendCascadeMessage *mNetworkMockSendCascadeMessage) Return(err error) *NetworkMock {
	if mmSendCascadeMessage.mock.funcSendCascadeMessage != nil {
		mmSendCascadeMessage.mock.t.Fatalf("NetworkMock.SendCascadeMessage mock is already set by Set")
	}

	if mmSendCascadeMessage.defaultExpectation == nil {
		mmSendCascadeMessage.defaultExpectation = &NetworkMockSendCascadeMessageExpectation{mock: mmSendCascadeMessage.mock}
	}
	mmSendCascadeMessage.defaultExpectation.results = &NetworkMockSendCascadeMessageResults{err}
	return mmSendCascadeMessage.mock
}

//Set uses given function f to mock the Network.SendCascadeMessage method
func (mmSendCascadeMessage *mNetworkMockSendCascadeMessage) Set(f func(data mm_insolar.Cascade, method string, msg mm_insolar.Parcel) (err error)) *NetworkMock {
	if mmSendCascadeMessage.defaultExpectation != nil {
		mmSendCascadeMessage.mock.t.Fatalf("Default expectation is already set for the Network.SendCascadeMessage method")
	}

	if len(mmSendCascadeMessage.expectations) > 0 {
		mmSendCascadeMessage.mock.t.Fatalf("Some expectations are already set for the Network.SendCascadeMessage method")
	}

	mmSendCascadeMessage.mock.funcSendCascadeMessage = f
	return mmSendCascadeMessage.mock
}

// When sets expectation for the Network.SendCascadeMessage which will trigger the result defined by the following
// Then helper
func (mmSendCascadeMessage *mNetworkMockSendCascadeMessage) When(data mm_insolar.Cascade, method string, msg mm_insolar.Parcel) *NetworkMockSendCascadeMessageExpectation {
	if mmSendCascadeMessage.mock.funcSendCascadeMessage != nil {
		mmSendCascadeMessage.mock.t.Fatalf("NetworkMock.SendCascadeMessage mock is already set by Set")
	}

	expectation := &NetworkMockSendCascadeMessageExpectation{
		mock:   mmSendCascadeMessage.mock,
		params: &NetworkMockSendCascadeMessageParams{data, method, msg},
	}
	mmSendCascadeMessage.expectations = append(mmSendCascadeMessage.expectations, expectation)
	return expectation
}

// Then sets up Network.SendCascadeMessage return parameters for the expectation previously defined by the When method
func (e *NetworkMockSendCascadeMessageExpectation) Then(err error) *NetworkMock {
	e.results = &NetworkMockSendCascadeMessageResults{err}
	return e.mock
}

// SendCascadeMessage implements insolar.Network
func (mmSendCascadeMessage *NetworkMock) SendCascadeMessage(data mm_insolar.Cascade, method string, msg mm_insolar.Parcel) (err error) {
	mm_atomic.AddUint64(&mmSendCascadeMessage.beforeSendCascadeMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmSendCascadeMessage.afterSendCascadeMessageCounter, 1)

	if mmSendCascadeMessage.inspectFuncSendCascadeMessage != nil {
		mmSendCascadeMessage.inspectFuncSendCascadeMessage(data, method, msg)
	}

	params := &NetworkMockSendCascadeMessageParams{data, method, msg}

	// Record call args
	mmSendCascadeMessage.SendCascadeMessageMock.mutex.Lock()
	mmSendCascadeMessage.SendCascadeMessageMock.callArgs = append(mmSendCascadeMessage.SendCascadeMessageMock.callArgs, params)
	mmSendCascadeMessage.SendCascadeMessageMock.mutex.Unlock()

	for _, e := range mmSendCascadeMessage.SendCascadeMessageMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendCascadeMessage.SendCascadeMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendCascadeMessage.SendCascadeMessageMock.defaultExpectation.Counter, 1)
		want := mmSendCascadeMessage.SendCascadeMessageMock.defaultExpectation.params
		got := NetworkMockSendCascadeMessageParams{data, method, msg}
		if want != nil && !minimock.Equal(*want, got) {
			mmSendCascadeMessage.t.Errorf("NetworkMock.SendCascadeMessage got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmSendCascadeMessage.SendCascadeMessageMock.defaultExpectation.results
		if results == nil {
			mmSendCascadeMessage.t.Fatal("No results are set for the NetworkMock.SendCascadeMessage")
		}
		return (*results).err
	}
	if mmSendCascadeMessage.funcSendCascadeMessage != nil {
		return mmSendCascadeMessage.funcSendCascadeMessage(data, method, msg)
	}
	mmSendCascadeMessage.t.Fatalf("Unexpected call to NetworkMock.SendCascadeMessage. %v %v %v", data, method, msg)
	return
}

// SendCascadeMessageAfterCounter returns a count of finished NetworkMock.SendCascadeMessage invocations
func (mmSendCascadeMessage *NetworkMock) SendCascadeMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendCascadeMessage.afterSendCascadeMessageCounter)
}

// SendCascadeMessageBeforeCounter returns a count of NetworkMock.SendCascadeMessage invocations
func (mmSendCascadeMessage *NetworkMock) SendCascadeMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendCascadeMessage.beforeSendCascadeMessageCounter)
}

// Calls returns a list of arguments used in each call to NetworkMock.SendCascadeMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendCascadeMessage *mNetworkMockSendCascadeMessage) Calls() []*NetworkMockSendCascadeMessageParams {
	mmSendCascadeMessage.mutex.RLock()

	argCopy := make([]*NetworkMockSendCascadeMessageParams, len(mmSendCascadeMessage.callArgs))
	copy(argCopy, mmSendCascadeMessage.callArgs)

	mmSendCascadeMessage.mutex.RUnlock()

	return argCopy
}

// MinimockSendCascadeMessageDone returns true if the count of the SendCascadeMessage invocations corresponds
// the number of defined expectations
func (m *NetworkMock) MinimockSendCascadeMessageDone() bool {
	for _, e := range m.SendCascadeMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendCascadeMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendCascadeMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendCascadeMessage != nil && mm_atomic.LoadUint64(&m.afterSendCascadeMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendCascadeMessageInspect logs each unmet expectation
func (m *NetworkMock) MinimockSendCascadeMessageInspect() {
	for _, e := range m.SendCascadeMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NetworkMock.SendCascadeMessage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendCascadeMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendCascadeMessageCounter) < 1 {
		if m.SendCascadeMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to NetworkMock.SendCascadeMessage")
		} else {
			m.t.Errorf("Expected call to NetworkMock.SendCascadeMessage with params: %#v", *m.SendCascadeMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendCascadeMessage != nil && mm_atomic.LoadUint64(&m.afterSendCascadeMessageCounter) < 1 {
		m.t.Error("Expected call to NetworkMock.SendCascadeMessage")
	}
}

type mNetworkMockSendMessage struct {
	mock               *NetworkMock
	defaultExpectation *NetworkMockSendMessageExpectation
	expectations       []*NetworkMockSendMessageExpectation

	callArgs []*NetworkMockSendMessageParams
	mutex    sync.RWMutex
}

// NetworkMockSendMessageExpectation specifies expectation struct of the Network.SendMessage
type NetworkMockSendMessageExpectation struct {
	mock    *NetworkMock
	params  *NetworkMockSendMessageParams
	results *NetworkMockSendMessageResults
	Counter uint64
}

// NetworkMockSendMessageParams contains parameters of the Network.SendMessage
type NetworkMockSendMessageParams struct {
	nodeID mm_insolar.Reference
	method string
	msg    mm_insolar.Parcel
}

// NetworkMockSendMessageResults contains results of the Network.SendMessage
type NetworkMockSendMessageResults struct {
	ba1 []byte
	err error
}

// Expect sets up expected params for Network.SendMessage
func (mmSendMessage *mNetworkMockSendMessage) Expect(nodeID mm_insolar.Reference, method string, msg mm_insolar.Parcel) *mNetworkMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("NetworkMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &NetworkMockSendMessageExpectation{}
	}

	mmSendMessage.defaultExpectation.params = &NetworkMockSendMessageParams{nodeID, method, msg}
	for _, e := range mmSendMessage.expectations {
		if minimock.Equal(e.params, mmSendMessage.defaultExpectation.params) {
			mmSendMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMessage.defaultExpectation.params)
		}
	}

	return mmSendMessage
}

// Inspect accepts an inspector function that has same arguments as the Network.SendMessage
func (mmSendMessage *mNetworkMockSendMessage) Inspect(f func(nodeID mm_insolar.Reference, method string, msg mm_insolar.Parcel)) *mNetworkMockSendMessage {
	if mmSendMessage.mock.inspectFuncSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("Inspect function is already set for NetworkMock.SendMessage")
	}

	mmSendMessage.mock.inspectFuncSendMessage = f

	return mmSendMessage
}

// Return sets up results that will be returned by Network.SendMessage
func (mmSendMessage *mNetworkMockSendMessage) Return(ba1 []byte, err error) *NetworkMock {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("NetworkMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &NetworkMockSendMessageExpectation{mock: mmSendMessage.mock}
	}
	mmSendMessage.defaultExpectation.results = &NetworkMockSendMessageResults{ba1, err}
	return mmSendMessage.mock
}

//Set uses given function f to mock the Network.SendMessage method
func (mmSendMessage *mNetworkMockSendMessage) Set(f func(nodeID mm_insolar.Reference, method string, msg mm_insolar.Parcel) (ba1 []byte, err error)) *NetworkMock {
	if mmSendMessage.defaultExpectation != nil {
		mmSendMessage.mock.t.Fatalf("Default expectation is already set for the Network.SendMessage method")
	}

	if len(mmSendMessage.expectations) > 0 {
		mmSendMessage.mock.t.Fatalf("Some expectations are already set for the Network.SendMessage method")
	}

	mmSendMessage.mock.funcSendMessage = f
	return mmSendMessage.mock
}

// When sets expectation for the Network.SendMessage which will trigger the result defined by the following
// Then helper
func (mmSendMessage *mNetworkMockSendMessage) When(nodeID mm_insolar.Reference, method string, msg mm_insolar.Parcel) *NetworkMockSendMessageExpectation {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("NetworkMock.SendMessage mock is already set by Set")
	}

	expectation := &NetworkMockSendMessageExpectation{
		mock:   mmSendMessage.mock,
		params: &NetworkMockSendMessageParams{nodeID, method, msg},
	}
	mmSendMessage.expectations = append(mmSendMessage.expectations, expectation)
	return expectation
}

// Then sets up Network.SendMessage return parameters for the expectation previously defined by the When method
func (e *NetworkMockSendMessageExpectation) Then(ba1 []byte, err error) *NetworkMock {
	e.results = &NetworkMockSendMessageResults{ba1, err}
	return e.mock
}

// SendMessage implements insolar.Network
func (mmSendMessage *NetworkMock) SendMessage(nodeID mm_insolar.Reference, method string, msg mm_insolar.Parcel) (ba1 []byte, err error) {
	mm_atomic.AddUint64(&mmSendMessage.beforeSendMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMessage.afterSendMessageCounter, 1)

	if mmSendMessage.inspectFuncSendMessage != nil {
		mmSendMessage.inspectFuncSendMessage(nodeID, method, msg)
	}

	params := &NetworkMockSendMessageParams{nodeID, method, msg}

	// Record call args
	mmSendMessage.SendMessageMock.mutex.Lock()
	mmSendMessage.SendMessageMock.callArgs = append(mmSendMessage.SendMessageMock.callArgs, params)
	mmSendMessage.SendMessageMock.mutex.Unlock()

	for _, e := range mmSendMessage.SendMessageMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ba1, e.results.err
		}
	}

	if mmSendMessage.SendMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMessage.SendMessageMock.defaultExpectation.Counter, 1)
		want := mmSendMessage.SendMessageMock.defaultExpectation.params
		got := NetworkMockSendMessageParams{nodeID, method, msg}
		if want != nil && !minimock.Equal(*want, got) {
			mmSendMessage.t.Errorf("NetworkMock.SendMessage got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmSendMessage.SendMessageMock.defaultExpectation.results
		if results == nil {
			mmSendMessage.t.Fatal("No results are set for the NetworkMock.SendMessage")
		}
		return (*results).ba1, (*results).err
	}
	if mmSendMessage.funcSendMessage != nil {
		return mmSendMessage.funcSendMessage(nodeID, method, msg)
	}
	mmSendMessage.t.Fatalf("Unexpected call to NetworkMock.SendMessage. %v %v %v", nodeID, method, msg)
	return
}

// SendMessageAfterCounter returns a count of finished NetworkMock.SendMessage invocations
func (mmSendMessage *NetworkMock) SendMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.afterSendMessageCounter)
}

// SendMessageBeforeCounter returns a count of NetworkMock.SendMessage invocations
func (mmSendMessage *NetworkMock) SendMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.beforeSendMessageCounter)
}

// Calls returns a list of arguments used in each call to NetworkMock.SendMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMessage *mNetworkMockSendMessage) Calls() []*NetworkMockSendMessageParams {
	mmSendMessage.mutex.RLock()

	argCopy := make([]*NetworkMockSendMessageParams, len(mmSendMessage.callArgs))
	copy(argCopy, mmSendMessage.callArgs)

	mmSendMessage.mutex.RUnlock()

	return argCopy
}

// MinimockSendMessageDone returns true if the count of the SendMessage invocations corresponds
// the number of defined expectations
func (m *NetworkMock) MinimockSendMessageDone() bool {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendMessageInspect logs each unmet expectation
func (m *NetworkMock) MinimockSendMessageInspect() {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NetworkMock.SendMessage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		if m.SendMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to NetworkMock.SendMessage")
		} else {
			m.t.Errorf("Expected call to NetworkMock.SendMessage with params: %#v", *m.SendMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		m.t.Error("Expected call to NetworkMock.SendMessage")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *NetworkMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetCertInspect()

		m.MinimockGetStateInspect()

		m.MinimockLeaveInspect()

		m.MinimockRemoteProcedureRegisterInspect()

		m.MinimockSendCascadeMessageInspect()

		m.MinimockSendMessageInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *NetworkMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *NetworkMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetCertDone() &&
		m.MinimockGetStateDone() &&
		m.MinimockLeaveDone() &&
		m.MinimockRemoteProcedureRegisterDone() &&
		m.MinimockSendCascadeMessageDone() &&
		m.MinimockSendMessageDone()
}
